{"ast":null,"code":"import { getClientSize } from \"../util\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport raf from \"@rc-component/util/es/raf\";\nimport { useRef, useState } from 'react';\nconst initialTransform = {\n  x: 0,\n  y: 0,\n  rotate: 0,\n  scale: 1,\n  flipX: false,\n  flipY: false\n};\nexport default function useImageTransform(imgRef, minScale, maxScale, onTransform) {\n  const frame = useRef(null);\n  const queue = useRef([]);\n  const [transform, setTransform] = useState(initialTransform);\n  const resetTransform = action => {\n    setTransform(initialTransform);\n    if (!isEqual(initialTransform, transform)) {\n      onTransform?.({\n        transform: initialTransform,\n        action\n      });\n    }\n  };\n\n  /** Direct update transform */\n  const updateTransform = (newTransform, action) => {\n    if (frame.current === null) {\n      queue.current = [];\n      frame.current = raf(() => {\n        setTransform(preState => {\n          let memoState = preState;\n          queue.current.forEach(queueState => {\n            memoState = {\n              ...memoState,\n              ...queueState\n            };\n          });\n          frame.current = null;\n          onTransform?.({\n            transform: memoState,\n            action\n          });\n          return memoState;\n        });\n      });\n    }\n    queue.current.push({\n      ...transform,\n      ...newTransform\n    });\n  };\n\n  /** Scale according to the position of centerX and centerY */\n  const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {\n    const {\n      width,\n      height,\n      offsetWidth,\n      offsetHeight,\n      offsetLeft,\n      offsetTop\n    } = imgRef.current;\n    let newRatio = ratio;\n    let newScale = transform.scale * ratio;\n    if (newScale > maxScale) {\n      newScale = maxScale;\n      newRatio = maxScale / transform.scale;\n    } else if (newScale < minScale) {\n      // For mobile interactions, allow scaling down to the minimum scale.\n      newScale = isTouch ? newScale : minScale;\n      newRatio = newScale / transform.scale;\n    }\n\n    /** Default center point scaling */\n    const mergedCenterX = centerX ?? innerWidth / 2;\n    const mergedCenterY = centerY ?? innerHeight / 2;\n    const diffRatio = newRatio - 1;\n    /** Deviation calculated from image size */\n    const diffImgX = diffRatio * width * 0.5;\n    const diffImgY = diffRatio * height * 0.5;\n    /** The difference between the click position and the edge of the document */\n    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);\n    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);\n    /** Final positioning */\n    let newX = transform.x - (diffOffsetLeft - diffImgX);\n    let newY = transform.y - (diffOffsetTop - diffImgY);\n\n    /**\n     * When zooming the image\n     * When the image size is smaller than the width and height of the window, the position is initialized\n     */\n    if (ratio < 1 && newScale === 1) {\n      const mergedWidth = offsetWidth * newScale;\n      const mergedHeight = offsetHeight * newScale;\n      const {\n        width: clientWidth,\n        height: clientHeight\n      } = getClientSize();\n      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {\n        newX = 0;\n        newY = 0;\n      }\n    }\n    updateTransform({\n      x: newX,\n      y: newY,\n      scale: newScale\n    }, action);\n  };\n  return {\n    transform,\n    resetTransform,\n    updateTransform,\n    dispatchZoomChange\n  };\n}","map":{"version":3,"names":["getClientSize","isEqual","raf","useRef","useState","initialTransform","x","y","rotate","scale","flipX","flipY","useImageTransform","imgRef","minScale","maxScale","onTransform","frame","queue","transform","setTransform","resetTransform","action","updateTransform","newTransform","current","preState","memoState","forEach","queueState","push","dispatchZoomChange","ratio","centerX","centerY","isTouch","width","height","offsetWidth","offsetHeight","offsetLeft","offsetTop","newRatio","newScale","mergedCenterX","innerWidth","mergedCenterY","innerHeight","diffRatio","diffImgX","diffImgY","diffOffsetLeft","diffOffsetTop","newX","newY","mergedWidth","mergedHeight","clientWidth","clientHeight"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/image/es/hooks/useImageTransform.js"],"sourcesContent":["import { getClientSize } from \"../util\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport raf from \"@rc-component/util/es/raf\";\nimport { useRef, useState } from 'react';\nconst initialTransform = {\n  x: 0,\n  y: 0,\n  rotate: 0,\n  scale: 1,\n  flipX: false,\n  flipY: false\n};\nexport default function useImageTransform(imgRef, minScale, maxScale, onTransform) {\n  const frame = useRef(null);\n  const queue = useRef([]);\n  const [transform, setTransform] = useState(initialTransform);\n  const resetTransform = action => {\n    setTransform(initialTransform);\n    if (!isEqual(initialTransform, transform)) {\n      onTransform?.({\n        transform: initialTransform,\n        action\n      });\n    }\n  };\n\n  /** Direct update transform */\n  const updateTransform = (newTransform, action) => {\n    if (frame.current === null) {\n      queue.current = [];\n      frame.current = raf(() => {\n        setTransform(preState => {\n          let memoState = preState;\n          queue.current.forEach(queueState => {\n            memoState = {\n              ...memoState,\n              ...queueState\n            };\n          });\n          frame.current = null;\n          onTransform?.({\n            transform: memoState,\n            action\n          });\n          return memoState;\n        });\n      });\n    }\n    queue.current.push({\n      ...transform,\n      ...newTransform\n    });\n  };\n\n  /** Scale according to the position of centerX and centerY */\n  const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {\n    const {\n      width,\n      height,\n      offsetWidth,\n      offsetHeight,\n      offsetLeft,\n      offsetTop\n    } = imgRef.current;\n    let newRatio = ratio;\n    let newScale = transform.scale * ratio;\n    if (newScale > maxScale) {\n      newScale = maxScale;\n      newRatio = maxScale / transform.scale;\n    } else if (newScale < minScale) {\n      // For mobile interactions, allow scaling down to the minimum scale.\n      newScale = isTouch ? newScale : minScale;\n      newRatio = newScale / transform.scale;\n    }\n\n    /** Default center point scaling */\n    const mergedCenterX = centerX ?? innerWidth / 2;\n    const mergedCenterY = centerY ?? innerHeight / 2;\n    const diffRatio = newRatio - 1;\n    /** Deviation calculated from image size */\n    const diffImgX = diffRatio * width * 0.5;\n    const diffImgY = diffRatio * height * 0.5;\n    /** The difference between the click position and the edge of the document */\n    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);\n    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);\n    /** Final positioning */\n    let newX = transform.x - (diffOffsetLeft - diffImgX);\n    let newY = transform.y - (diffOffsetTop - diffImgY);\n\n    /**\n     * When zooming the image\n     * When the image size is smaller than the width and height of the window, the position is initialized\n     */\n    if (ratio < 1 && newScale === 1) {\n      const mergedWidth = offsetWidth * newScale;\n      const mergedHeight = offsetHeight * newScale;\n      const {\n        width: clientWidth,\n        height: clientHeight\n      } = getClientSize();\n      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {\n        newX = 0;\n        newY = 0;\n      }\n    }\n    updateTransform({\n      x: newX,\n      y: newY,\n      scale: newScale\n    }, action);\n  };\n  return {\n    transform,\n    resetTransform,\n    updateTransform,\n    dispatchZoomChange\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}