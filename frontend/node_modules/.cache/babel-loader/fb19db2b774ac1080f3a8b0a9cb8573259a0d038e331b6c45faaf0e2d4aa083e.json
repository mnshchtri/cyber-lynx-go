{"ast":null,"code":"\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useContext } from 'react';\nimport RcColorPicker from '@rc-component/color-picker';\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { useForceUpdate } from '../../../_util/hooks';\nimport Segmented from '../../../segmented';\nimport { AggregationColor } from '../../color';\nimport { PanelPickerContext } from '../../context';\nimport { genAlphaColor, generateColor } from '../../util';\nimport ColorClear from '../ColorClear';\nimport ColorInput from '../ColorInput';\nimport ColorSlider from '../ColorSlider';\nimport GradientColorBar from './GradientColorBar';\nconst components = {\n  slider: ColorSlider\n};\nconst PanelPicker = () => {\n  const panelPickerContext = useContext(PanelPickerContext);\n  const {\n    mode,\n    onModeChange,\n    modeOptions,\n    prefixCls,\n    allowClear,\n    value,\n    disabledAlpha,\n    onChange,\n    onClear,\n    onChangeComplete,\n    activeIndex,\n    gradientDragging,\n    ...injectProps\n  } = panelPickerContext;\n  // ============================ Colors ============================\n  const colors = React.useMemo(() => {\n    if (!value.cleared) {\n      return value.getColors();\n    }\n    return [{\n      percent: 0,\n      color: new AggregationColor('')\n    }, {\n      percent: 100,\n      color: new AggregationColor('')\n    }];\n  }, [value]);\n  // ========================= Single Color =========================\n  const isSingle = !value.isGradient();\n  // We cache the point color in case user drag the gradient point across another one\n  const [lockedColor, setLockedColor] = React.useState(value);\n  // Use layout effect here since `useEffect` will cause a blink when mouseDown\n  useLayoutEffect(() => {\n    if (!isSingle) {\n      setLockedColor(colors[activeIndex]?.color);\n    }\n  }, [isSingle, colors, gradientDragging, activeIndex]);\n  const activeColor = React.useMemo(() => {\n    if (isSingle) {\n      return value;\n    }\n    // Use cache when dragging. User can not operation panel when dragging.\n    if (gradientDragging) {\n      return lockedColor;\n    }\n    return colors[activeIndex]?.color;\n  }, [colors, value, activeIndex, isSingle, lockedColor, gradientDragging]);\n  // ========================= Picker Color =========================\n  const [pickerColor, setPickerColor] = React.useState(activeColor);\n  const [forceSync, setForceSync] = useForceUpdate();\n  const mergedPickerColor = pickerColor?.equals(activeColor) ? activeColor : pickerColor;\n  useLayoutEffect(() => {\n    setPickerColor(activeColor);\n  }, [forceSync, activeColor?.toHexString()]);\n  // ============================ Change ============================\n  const fillColor = (nextColor, info) => {\n    let submitColor = generateColor(nextColor);\n    // Fill alpha color to 100% if origin is cleared color\n    if (value.cleared) {\n      const rgb = submitColor.toRgb();\n      // Auto fill color if origin is `0/0/0` to enhance user experience\n      if (!rgb.r && !rgb.g && !rgb.b && info) {\n        const {\n          type: infoType,\n          value: infoValue = 0\n        } = info;\n        submitColor = new AggregationColor({\n          h: infoType === 'hue' ? infoValue : 0,\n          s: 1,\n          b: 1,\n          a: infoType === 'alpha' ? infoValue / 100 : 1\n        });\n      } else {\n        submitColor = genAlphaColor(submitColor);\n      }\n    }\n    if (mode === 'single') {\n      return submitColor;\n    }\n    const nextColors = _toConsumableArray(colors);\n    nextColors[activeIndex] = {\n      ...nextColors[activeIndex],\n      color: submitColor\n    };\n    return new AggregationColor(nextColors);\n  };\n  const onPickerChange = (colorValue, fromPicker, info) => {\n    const nextColor = fillColor(colorValue, info);\n    setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);\n    onChange(nextColor, fromPicker);\n  };\n  const onInternalChangeComplete = (nextColor, info) => {\n    // Trigger complete event\n    onChangeComplete(fillColor(nextColor, info));\n    // Back of origin color in case in controlled\n    // This will set after `onChangeComplete` to avoid `setState` trigger rerender\n    // which will make `fillColor` get wrong `color.cleared` state\n    setForceSync();\n  };\n  const onInputChange = colorValue => {\n    onChange(fillColor(colorValue));\n  };\n  // ============================ Render ============================\n  // Operation bar\n  let operationNode = null;\n  const showMode = modeOptions.length > 1;\n  if (allowClear || showMode) {\n    operationNode = /*#__PURE__*/React.createElement(\"div\", {\n      className: `${prefixCls}-operation`\n    }, showMode && (/*#__PURE__*/React.createElement(Segmented, {\n      size: \"small\",\n      options: modeOptions,\n      value: mode,\n      onChange: onModeChange\n    })), /*#__PURE__*/React.createElement(ColorClear, {\n      prefixCls: prefixCls,\n      value: value,\n      onChange: clearColor => {\n        onChange(clearColor);\n        onClear?.();\n      },\n      ...injectProps\n    }));\n  }\n  // Return\n  return /*#__PURE__*/React.createElement(React.Fragment, null, operationNode, /*#__PURE__*/React.createElement(GradientColorBar, {\n    ...panelPickerContext,\n    colors: colors\n  }), /*#__PURE__*/React.createElement(RcColorPicker, {\n    prefixCls: prefixCls,\n    value: mergedPickerColor?.toHsb(),\n    disabledAlpha: disabledAlpha,\n    onChange: (colorValue, info) => {\n      onPickerChange(colorValue, true, info);\n    },\n    onChangeComplete: (colorValue, info) => {\n      onInternalChangeComplete(colorValue, info);\n    },\n    components: components\n  }), /*#__PURE__*/React.createElement(ColorInput, {\n    value: activeColor,\n    onChange: onInputChange,\n    prefixCls: prefixCls,\n    disabledAlpha: disabledAlpha,\n    ...injectProps\n  }));\n};\nexport default PanelPicker;","map":{"version":3,"names":["_toConsumableArray","React","useContext","RcColorPicker","useLayoutEffect","useForceUpdate","Segmented","AggregationColor","PanelPickerContext","genAlphaColor","generateColor","ColorClear","ColorInput","ColorSlider","GradientColorBar","components","slider","PanelPicker","panelPickerContext","mode","onModeChange","modeOptions","prefixCls","allowClear","value","disabledAlpha","onChange","onClear","onChangeComplete","activeIndex","gradientDragging","injectProps","colors","useMemo","cleared","getColors","percent","color","isSingle","isGradient","lockedColor","setLockedColor","useState","activeColor","pickerColor","setPickerColor","forceSync","setForceSync","mergedPickerColor","equals","toHexString","fillColor","nextColor","info","submitColor","rgb","toRgb","r","g","b","type","infoType","infoValue","h","s","a","nextColors","onPickerChange","colorValue","fromPicker","onInternalChangeComplete","onInputChange","operationNode","showMode","length","createElement","className","size","options","clearColor","Fragment","toHsb"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/antd/es/color-picker/components/PanelPicker/index.js"],"sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useContext } from 'react';\nimport RcColorPicker from '@rc-component/color-picker';\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { useForceUpdate } from '../../../_util/hooks';\nimport Segmented from '../../../segmented';\nimport { AggregationColor } from '../../color';\nimport { PanelPickerContext } from '../../context';\nimport { genAlphaColor, generateColor } from '../../util';\nimport ColorClear from '../ColorClear';\nimport ColorInput from '../ColorInput';\nimport ColorSlider from '../ColorSlider';\nimport GradientColorBar from './GradientColorBar';\nconst components = {\n  slider: ColorSlider\n};\nconst PanelPicker = () => {\n  const panelPickerContext = useContext(PanelPickerContext);\n  const {\n    mode,\n    onModeChange,\n    modeOptions,\n    prefixCls,\n    allowClear,\n    value,\n    disabledAlpha,\n    onChange,\n    onClear,\n    onChangeComplete,\n    activeIndex,\n    gradientDragging,\n    ...injectProps\n  } = panelPickerContext;\n  // ============================ Colors ============================\n  const colors = React.useMemo(() => {\n    if (!value.cleared) {\n      return value.getColors();\n    }\n    return [{\n      percent: 0,\n      color: new AggregationColor('')\n    }, {\n      percent: 100,\n      color: new AggregationColor('')\n    }];\n  }, [value]);\n  // ========================= Single Color =========================\n  const isSingle = !value.isGradient();\n  // We cache the point color in case user drag the gradient point across another one\n  const [lockedColor, setLockedColor] = React.useState(value);\n  // Use layout effect here since `useEffect` will cause a blink when mouseDown\n  useLayoutEffect(() => {\n    if (!isSingle) {\n      setLockedColor(colors[activeIndex]?.color);\n    }\n  }, [isSingle, colors, gradientDragging, activeIndex]);\n  const activeColor = React.useMemo(() => {\n    if (isSingle) {\n      return value;\n    }\n    // Use cache when dragging. User can not operation panel when dragging.\n    if (gradientDragging) {\n      return lockedColor;\n    }\n    return colors[activeIndex]?.color;\n  }, [colors, value, activeIndex, isSingle, lockedColor, gradientDragging]);\n  // ========================= Picker Color =========================\n  const [pickerColor, setPickerColor] = React.useState(activeColor);\n  const [forceSync, setForceSync] = useForceUpdate();\n  const mergedPickerColor = pickerColor?.equals(activeColor) ? activeColor : pickerColor;\n  useLayoutEffect(() => {\n    setPickerColor(activeColor);\n  }, [forceSync, activeColor?.toHexString()]);\n  // ============================ Change ============================\n  const fillColor = (nextColor, info) => {\n    let submitColor = generateColor(nextColor);\n    // Fill alpha color to 100% if origin is cleared color\n    if (value.cleared) {\n      const rgb = submitColor.toRgb();\n      // Auto fill color if origin is `0/0/0` to enhance user experience\n      if (!rgb.r && !rgb.g && !rgb.b && info) {\n        const {\n          type: infoType,\n          value: infoValue = 0\n        } = info;\n        submitColor = new AggregationColor({\n          h: infoType === 'hue' ? infoValue : 0,\n          s: 1,\n          b: 1,\n          a: infoType === 'alpha' ? infoValue / 100 : 1\n        });\n      } else {\n        submitColor = genAlphaColor(submitColor);\n      }\n    }\n    if (mode === 'single') {\n      return submitColor;\n    }\n    const nextColors = _toConsumableArray(colors);\n    nextColors[activeIndex] = {\n      ...nextColors[activeIndex],\n      color: submitColor\n    };\n    return new AggregationColor(nextColors);\n  };\n  const onPickerChange = (colorValue, fromPicker, info) => {\n    const nextColor = fillColor(colorValue, info);\n    setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);\n    onChange(nextColor, fromPicker);\n  };\n  const onInternalChangeComplete = (nextColor, info) => {\n    // Trigger complete event\n    onChangeComplete(fillColor(nextColor, info));\n    // Back of origin color in case in controlled\n    // This will set after `onChangeComplete` to avoid `setState` trigger rerender\n    // which will make `fillColor` get wrong `color.cleared` state\n    setForceSync();\n  };\n  const onInputChange = colorValue => {\n    onChange(fillColor(colorValue));\n  };\n  // ============================ Render ============================\n  // Operation bar\n  let operationNode = null;\n  const showMode = modeOptions.length > 1;\n  if (allowClear || showMode) {\n    operationNode = /*#__PURE__*/React.createElement(\"div\", {\n      className: `${prefixCls}-operation`\n    }, showMode && (/*#__PURE__*/React.createElement(Segmented, {\n      size: \"small\",\n      options: modeOptions,\n      value: mode,\n      onChange: onModeChange\n    })), /*#__PURE__*/React.createElement(ColorClear, {\n      prefixCls: prefixCls,\n      value: value,\n      onChange: clearColor => {\n        onChange(clearColor);\n        onClear?.();\n      },\n      ...injectProps\n    }));\n  }\n  // Return\n  return /*#__PURE__*/React.createElement(React.Fragment, null, operationNode, /*#__PURE__*/React.createElement(GradientColorBar, {\n    ...panelPickerContext,\n    colors: colors\n  }), /*#__PURE__*/React.createElement(RcColorPicker, {\n    prefixCls: prefixCls,\n    value: mergedPickerColor?.toHsb(),\n    disabledAlpha: disabledAlpha,\n    onChange: (colorValue, info) => {\n      onPickerChange(colorValue, true, info);\n    },\n    onChangeComplete: (colorValue, info) => {\n      onInternalChangeComplete(colorValue, info);\n    },\n    components: components\n  }), /*#__PURE__*/React.createElement(ColorInput, {\n    value: activeColor,\n    onChange: onInputChange,\n    prefixCls: prefixCls,\n    disabledAlpha: disabledAlpha,\n    ...injectProps\n  }));\n};\nexport default PanelPicker;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}