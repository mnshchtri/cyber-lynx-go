{"ast":null,"code":"import * as React from 'react';\nfunction parseColWidth(totalWidth, width = '') {\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (width.endsWith('%')) {\n    return totalWidth * parseFloat(width) / 100;\n  }\n  return null;\n}\n\n/**\n * Fill all column with width\n */\nexport default function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {\n  return React.useMemo(() => {\n    // Fill width if needed\n    if (scrollWidth && scrollWidth > 0) {\n      let totalWidth = 0;\n      let missWidthCount = 0;\n\n      // collect not given width column\n      flattenColumns.forEach(col => {\n        const colWidth = parseColWidth(scrollWidth, col.width);\n        if (colWidth) {\n          totalWidth += colWidth;\n        } else {\n          missWidthCount += 1;\n        }\n      });\n\n      // Fill width\n      const maxFitWidth = Math.max(scrollWidth, clientWidth);\n      let restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);\n      let restCount = missWidthCount;\n      const avgWidth = restWidth / missWidthCount;\n      let realTotal = 0;\n      const filledColumns = flattenColumns.map(col => {\n        const clone = {\n          ...col\n        };\n        const colWidth = parseColWidth(scrollWidth, clone.width);\n        if (colWidth) {\n          clone.width = colWidth;\n        } else {\n          const colAvgWidth = Math.floor(avgWidth);\n          clone.width = restCount === 1 ? restWidth : colAvgWidth;\n          restWidth -= colAvgWidth;\n          restCount -= 1;\n        }\n        realTotal += clone.width;\n        return clone;\n      });\n\n      // If realTotal is less than clientWidth,\n      // We need extend column width\n      if (realTotal < maxFitWidth) {\n        const scale = maxFitWidth / realTotal;\n        restWidth = maxFitWidth;\n        filledColumns.forEach((col, index) => {\n          const colWidth = Math.floor(col.width * scale);\n          col.width = index === filledColumns.length - 1 ? restWidth : colWidth;\n          restWidth -= colWidth;\n        });\n      }\n      return [filledColumns, Math.max(realTotal, maxFitWidth)];\n    }\n    return [flattenColumns, scrollWidth];\n  }, [flattenColumns, scrollWidth, clientWidth]);\n}","map":{"version":3,"names":["React","parseColWidth","totalWidth","width","endsWith","parseFloat","useWidthColumns","flattenColumns","scrollWidth","clientWidth","useMemo","missWidthCount","forEach","col","colWidth","maxFitWidth","Math","max","restWidth","restCount","avgWidth","realTotal","filledColumns","map","clone","colAvgWidth","floor","scale","index","length"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/table/es/hooks/useColumns/useWidthColumns.js"],"sourcesContent":["import * as React from 'react';\nfunction parseColWidth(totalWidth, width = '') {\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (width.endsWith('%')) {\n    return totalWidth * parseFloat(width) / 100;\n  }\n  return null;\n}\n\n/**\n * Fill all column with width\n */\nexport default function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {\n  return React.useMemo(() => {\n    // Fill width if needed\n    if (scrollWidth && scrollWidth > 0) {\n      let totalWidth = 0;\n      let missWidthCount = 0;\n\n      // collect not given width column\n      flattenColumns.forEach(col => {\n        const colWidth = parseColWidth(scrollWidth, col.width);\n        if (colWidth) {\n          totalWidth += colWidth;\n        } else {\n          missWidthCount += 1;\n        }\n      });\n\n      // Fill width\n      const maxFitWidth = Math.max(scrollWidth, clientWidth);\n      let restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);\n      let restCount = missWidthCount;\n      const avgWidth = restWidth / missWidthCount;\n      let realTotal = 0;\n      const filledColumns = flattenColumns.map(col => {\n        const clone = {\n          ...col\n        };\n        const colWidth = parseColWidth(scrollWidth, clone.width);\n        if (colWidth) {\n          clone.width = colWidth;\n        } else {\n          const colAvgWidth = Math.floor(avgWidth);\n          clone.width = restCount === 1 ? restWidth : colAvgWidth;\n          restWidth -= colAvgWidth;\n          restCount -= 1;\n        }\n        realTotal += clone.width;\n        return clone;\n      });\n\n      // If realTotal is less than clientWidth,\n      // We need extend column width\n      if (realTotal < maxFitWidth) {\n        const scale = maxFitWidth / realTotal;\n        restWidth = maxFitWidth;\n        filledColumns.forEach((col, index) => {\n          const colWidth = Math.floor(col.width * scale);\n          col.width = index === filledColumns.length - 1 ? restWidth : colWidth;\n          restWidth -= colWidth;\n        });\n      }\n      return [filledColumns, Math.max(realTotal, maxFitWidth)];\n    }\n    return [flattenColumns, scrollWidth];\n  }, [flattenColumns, scrollWidth, clientWidth]);\n}"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,aAAaA,CAACC,UAAU,EAAEC,KAAK,GAAG,EAAE,EAAE;EAC7C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOA,KAAK;EACd;EACA,IAAIA,KAAK,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;IACvB,OAAOF,UAAU,GAAGG,UAAU,CAACF,KAAK,CAAC,GAAG,GAAG;EAC7C;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA,eAAe,SAASG,eAAeA,CAACC,cAAc,EAAEC,WAAW,EAAEC,WAAW,EAAE;EAChF,OAAOT,KAAK,CAACU,OAAO,CAAC,MAAM;IACzB;IACA,IAAIF,WAAW,IAAIA,WAAW,GAAG,CAAC,EAAE;MAClC,IAAIN,UAAU,GAAG,CAAC;MAClB,IAAIS,cAAc,GAAG,CAAC;;MAEtB;MACAJ,cAAc,CAACK,OAAO,CAACC,GAAG,IAAI;QAC5B,MAAMC,QAAQ,GAAGb,aAAa,CAACO,WAAW,EAAEK,GAAG,CAACV,KAAK,CAAC;QACtD,IAAIW,QAAQ,EAAE;UACZZ,UAAU,IAAIY,QAAQ;QACxB,CAAC,MAAM;UACLH,cAAc,IAAI,CAAC;QACrB;MACF,CAAC,CAAC;;MAEF;MACA,MAAMI,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACT,WAAW,EAAEC,WAAW,CAAC;MACtD,IAAIS,SAAS,GAAGF,IAAI,CAACC,GAAG,CAACF,WAAW,GAAGb,UAAU,EAAES,cAAc,CAAC;MAClE,IAAIQ,SAAS,GAAGR,cAAc;MAC9B,MAAMS,QAAQ,GAAGF,SAAS,GAAGP,cAAc;MAC3C,IAAIU,SAAS,GAAG,CAAC;MACjB,MAAMC,aAAa,GAAGf,cAAc,CAACgB,GAAG,CAACV,GAAG,IAAI;QAC9C,MAAMW,KAAK,GAAG;UACZ,GAAGX;QACL,CAAC;QACD,MAAMC,QAAQ,GAAGb,aAAa,CAACO,WAAW,EAAEgB,KAAK,CAACrB,KAAK,CAAC;QACxD,IAAIW,QAAQ,EAAE;UACZU,KAAK,CAACrB,KAAK,GAAGW,QAAQ;QACxB,CAAC,MAAM;UACL,MAAMW,WAAW,GAAGT,IAAI,CAACU,KAAK,CAACN,QAAQ,CAAC;UACxCI,KAAK,CAACrB,KAAK,GAAGgB,SAAS,KAAK,CAAC,GAAGD,SAAS,GAAGO,WAAW;UACvDP,SAAS,IAAIO,WAAW;UACxBN,SAAS,IAAI,CAAC;QAChB;QACAE,SAAS,IAAIG,KAAK,CAACrB,KAAK;QACxB,OAAOqB,KAAK;MACd,CAAC,CAAC;;MAEF;MACA;MACA,IAAIH,SAAS,GAAGN,WAAW,EAAE;QAC3B,MAAMY,KAAK,GAAGZ,WAAW,GAAGM,SAAS;QACrCH,SAAS,GAAGH,WAAW;QACvBO,aAAa,CAACV,OAAO,CAAC,CAACC,GAAG,EAAEe,KAAK,KAAK;UACpC,MAAMd,QAAQ,GAAGE,IAAI,CAACU,KAAK,CAACb,GAAG,CAACV,KAAK,GAAGwB,KAAK,CAAC;UAC9Cd,GAAG,CAACV,KAAK,GAAGyB,KAAK,KAAKN,aAAa,CAACO,MAAM,GAAG,CAAC,GAAGX,SAAS,GAAGJ,QAAQ;UACrEI,SAAS,IAAIJ,QAAQ;QACvB,CAAC,CAAC;MACJ;MACA,OAAO,CAACQ,aAAa,EAAEN,IAAI,CAACC,GAAG,CAACI,SAAS,EAAEN,WAAW,CAAC,CAAC;IAC1D;IACA,OAAO,CAACR,cAAc,EAAEC,WAAW,CAAC;EACtC,CAAC,EAAE,CAACD,cAAc,EAAEC,WAAW,EAAEC,WAAW,CAAC,CAAC;AAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}