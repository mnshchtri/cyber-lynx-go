{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { BaseSelect } from '@rc-component/select';\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport { conductCheck } from \"@rc-component/tree/es/utils/conductUtil\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport * as React from 'react';\nimport useCache from \"./hooks/useCache\";\nimport useCheckedKeys from \"./hooks/useCheckedKeys\";\nimport useDataEntities from \"./hooks/useDataEntities\";\nimport useFilterTreeData from \"./hooks/useFilterTreeData\";\nimport useRefFunc from \"./hooks/useRefFunc\";\nimport useTreeData from \"./hooks/useTreeData\";\nimport LegacyContext from \"./LegacyContext\";\nimport OptionList from \"./OptionList\";\nimport TreeNode from \"./TreeNode\";\nimport TreeSelectContext from \"./TreeSelectContext\";\nimport { fillAdditionalInfo, fillLegacyProps } from \"./utils/legacyUtil\";\nimport { formatStrategyValues, SHOW_ALL, SHOW_CHILD, SHOW_PARENT } from \"./utils/strategyUtil\";\nimport { fillFieldNames, isNil, toArray } from \"./utils/valueUtil\";\nimport warningProps from \"./utils/warningPropsUtil\";\nimport useSearchConfig from \"./hooks/useSearchConfig\";\nfunction isRawValue(value) {\n  return !value || typeof value !== 'object';\n}\nconst TreeSelect = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    id,\n    prefixCls = 'rc-tree-select',\n    // Value\n    value,\n    defaultValue,\n    onChange,\n    onSelect,\n    onDeselect,\n    // Search\n    showSearch,\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp,\n    // Selector\n    showCheckedStrategy,\n    treeNodeLabelProp,\n    //  Mode\n    multiple,\n    treeCheckable,\n    treeCheckStrictly,\n    labelInValue,\n    maxCount,\n    // FieldNames\n    fieldNames,\n    // Data\n    treeDataSimpleMode,\n    treeData,\n    children,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    // Expanded\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeExpandAction,\n    // Options\n    virtual,\n    listHeight = 200,\n    listItemHeight = 20,\n    listItemScrollOffset = 0,\n    onPopupVisibleChange,\n    popupMatchSelectWidth = true,\n    // Tree\n    treeLine,\n    treeIcon,\n    showTreeIcon,\n    switcherIcon,\n    treeMotion,\n    treeTitleRender,\n    onPopupScroll,\n    classNames: treeSelectClassNames,\n    styles,\n    ...restProps\n  } = props;\n  const mergedId = useId(id);\n  const treeConduction = treeCheckable && !treeCheckStrictly;\n  const mergedCheckable = treeCheckable || treeCheckStrictly;\n  const mergedLabelInValue = treeCheckStrictly || labelInValue;\n  const mergedMultiple = mergedCheckable || multiple;\n  const searchProps = {\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp\n  };\n  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps);\n  const {\n    searchValue,\n    onSearch,\n    autoClearSearchValue = true,\n    filterTreeNode,\n    treeNodeFilterProp = 'value'\n  } = searchConfig;\n  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);\n\n  // `multiple` && `!treeCheckable` should be show all\n  const mergedShowCheckedStrategy = React.useMemo(() => {\n    if (!treeCheckable) {\n      return SHOW_ALL;\n    }\n    return showCheckedStrategy || SHOW_CHILD;\n  }, [showCheckedStrategy, treeCheckable]);\n\n  // ========================== Warning ===========================\n  if (process.env.NODE_ENV !== 'production') {\n    warningProps(props);\n  }\n\n  // ========================= FieldNames =========================\n  const mergedFieldNames = React.useMemo(() => fillFieldNames(fieldNames), /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify(fieldNames)]\n  /* eslint-enable react-hooks/exhaustive-deps */);\n\n  // =========================== Search ===========================\n  const [internalSearchValue, setSearchValue] = useControlledState('', searchValue);\n  const mergedSearchValue = internalSearchValue || '';\n  const onInternalSearch = searchText => {\n    setSearchValue(searchText);\n    onSearch?.(searchText);\n  };\n\n  // ============================ Data ============================\n  // `useTreeData` only do convert of `children` or `simpleMode`.\n  // Else will return origin `treeData` for perf consideration.\n  // Do not do anything to loop the data.\n  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);\n  const {\n    keyEntities,\n    valueEntities\n  } = useDataEntities(mergedTreeData, mergedFieldNames);\n\n  /** Get `missingRawValues` which not exist in the tree yet */\n  const splitRawValues = React.useCallback(newRawValues => {\n    const missingRawValues = [];\n    const existRawValues = [];\n\n    // Keep missing value in the cache\n    newRawValues.forEach(val => {\n      if (valueEntities.has(val)) {\n        existRawValues.push(val);\n      } else {\n        missingRawValues.push(val);\n      }\n    });\n    return {\n      missingRawValues,\n      existRawValues\n    };\n  }, [valueEntities]);\n\n  // Filtered Tree\n  const filteredTreeData = useFilterTreeData(mergedTreeData, mergedSearchValue, {\n    fieldNames: mergedFieldNames,\n    treeNodeFilterProp,\n    filterTreeNode\n  });\n\n  // =========================== Label ============================\n  const getLabel = React.useCallback(item => {\n    if (item) {\n      if (treeNodeLabelProp) {\n        return item[treeNodeLabelProp];\n      }\n\n      // Loop from fieldNames\n      const {\n        _title: titleList\n      } = mergedFieldNames;\n      for (let i = 0; i < titleList.length; i += 1) {\n        const title = item[titleList[i]];\n        if (title !== undefined) {\n          return title;\n        }\n      }\n    }\n  }, [mergedFieldNames, treeNodeLabelProp]);\n\n  // ========================= Wrap Value =========================\n  const toLabeledValues = React.useCallback(draftValues => {\n    const values = toArray(draftValues);\n    return values.map(val => {\n      if (isRawValue(val)) {\n        return {\n          value: val\n        };\n      }\n      return val;\n    });\n  }, []);\n  const convert2LabelValues = React.useCallback(draftValues => {\n    const values = toLabeledValues(draftValues);\n    return values.map(item => {\n      let {\n        label: rawLabel\n      } = item;\n      const {\n        value: rawValue,\n        halfChecked: rawHalfChecked\n      } = item;\n      let rawDisabled;\n      const entity = valueEntities.get(rawValue);\n\n      // Fill missing label & status\n      if (entity) {\n        rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel ?? getLabel(entity.node);\n        rawDisabled = entity.node.disabled;\n      } else if (rawLabel === undefined) {\n        // We try to find in current `labelInValue` value\n        const labelInValueItem = toLabeledValues(internalValue).find(labeledItem => labeledItem.value === rawValue);\n        rawLabel = labelInValueItem.label;\n      }\n      return {\n        label: rawLabel,\n        value: rawValue,\n        halfChecked: rawHalfChecked,\n        disabled: rawDisabled\n      };\n    });\n  }, [valueEntities, getLabel, toLabeledValues, internalValue]);\n\n  // =========================== Values ===========================\n  const rawMixedLabeledValues = React.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);\n\n  // Split value into full check and half check\n  const [rawLabeledValues, rawHalfLabeledValues] = React.useMemo(() => {\n    const fullCheckValues = [];\n    const halfCheckValues = [];\n    rawMixedLabeledValues.forEach(item => {\n      if (item.halfChecked) {\n        halfCheckValues.push(item);\n      } else {\n        fullCheckValues.push(item);\n      }\n    });\n    return [fullCheckValues, halfCheckValues];\n  }, [rawMixedLabeledValues]);\n\n  // const [mergedValues] = useCache(rawLabeledValues);\n  const rawValues = React.useMemo(() => rawLabeledValues.map(item => item.value), [rawLabeledValues]);\n\n  // Convert value to key. Will fill missed keys for conduct check.\n  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);\n\n  // Convert rawCheckedKeys to check strategy related values\n  const displayValues = React.useMemo(() => {\n    // Collect keys which need to show\n    const displayKeys = formatStrategyValues(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Convert to value and filled with label\n    const values = displayKeys.map(key => keyEntities[key]?.node?.[mergedFieldNames.value] ?? key);\n\n    // Back fill with origin label\n    const labeledValues = values.map(val => {\n      const targetItem = rawLabeledValues.find(item => item.value === val);\n      const label = labelInValue ? targetItem?.label : treeTitleRender?.(targetItem);\n      return {\n        value: val,\n        label\n      };\n    });\n    const rawDisplayValues = convert2LabelValues(labeledValues);\n    const firstVal = rawDisplayValues[0];\n    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {\n      return [];\n    }\n    return rawDisplayValues.map(item => ({\n      ...item,\n      label: item.label ?? item.value\n    }));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [mergedFieldNames, mergedMultiple, rawCheckedValues, rawLabeledValues, convert2LabelValues, mergedShowCheckedStrategy, keyEntities]);\n  const [cachedDisplayValues] = useCache(displayValues);\n\n  // ========================== MaxCount ==========================\n  const mergedMaxCount = React.useMemo(() => {\n    if (mergedMultiple && (mergedShowCheckedStrategy === 'SHOW_CHILD' || treeCheckStrictly || !treeCheckable)) {\n      return maxCount;\n    }\n    return null;\n  }, [maxCount, mergedMultiple, treeCheckStrictly, mergedShowCheckedStrategy, treeCheckable]);\n\n  // =========================== Change ===========================\n  const triggerChange = useRefFunc((newRawValues, extra, source) => {\n    const formattedKeyList = formatStrategyValues(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Not allow pass with `maxCount`\n    if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) {\n      return;\n    }\n    const labeledValues = convert2LabelValues(newRawValues);\n    setInternalValue(labeledValues);\n\n    // Clean up if needed\n    if (autoClearSearchValue) {\n      setSearchValue('');\n    }\n\n    // Generate rest parameters is costly, so only do it when necessary\n    if (onChange) {\n      let eventValues = newRawValues;\n      if (treeConduction) {\n        eventValues = formattedKeyList.map(key => {\n          const entity = valueEntities.get(key);\n          return entity ? entity.node[mergedFieldNames.value] : key;\n        });\n      }\n      const {\n        triggerValue,\n        selected\n      } = extra || {\n        triggerValue: undefined,\n        selected: undefined\n      };\n      let returnRawValues = eventValues;\n\n      // We need fill half check back\n      if (treeCheckStrictly) {\n        const halfValues = rawHalfLabeledValues.filter(item => !eventValues.includes(item.value));\n        returnRawValues = [...returnRawValues, ...halfValues];\n      }\n      const returnLabeledValues = convert2LabelValues(returnRawValues);\n      const additionalInfo = {\n        // [Legacy] Always return as array contains label & value\n        preValue: rawLabeledValues,\n        triggerValue\n      };\n\n      // [Legacy] Fill legacy data if user query.\n      // This is expansive that we only fill when user query\n      // https://github.com/react-component/tree-select/blob/fe33eb7c27830c9ac70cd1fdb1ebbe7bc679c16a/src/Select.jsx\n      let showPosition = true;\n      if (treeCheckStrictly || source === 'selection' && !selected) {\n        showPosition = false;\n      }\n      fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);\n      if (mergedCheckable) {\n        additionalInfo.checked = selected;\n      } else {\n        additionalInfo.selected = selected;\n      }\n      const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map(item => item.value);\n      onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map(item => item.label), additionalInfo);\n    }\n  });\n\n  // ========================== Options ===========================\n  /** Trigger by option list */\n  const onOptionSelect = React.useCallback((selectedKey, {\n    selected,\n    source\n  }) => {\n    const entity = keyEntities[selectedKey];\n    const node = entity?.node;\n    const selectedValue = node?.[mergedFieldNames.value] ?? selectedKey;\n\n    // Never be falsy but keep it safe\n    if (!mergedMultiple) {\n      // Single mode always set value\n      triggerChange([selectedValue], {\n        selected: true,\n        triggerValue: selectedValue\n      }, 'option');\n    } else {\n      let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter(v => v !== selectedValue);\n\n      // Add keys if tree conduction\n      if (treeConduction) {\n        // Should keep missing values\n        const {\n          missingRawValues,\n          existRawValues\n        } = splitRawValues(newRawValues);\n        const keyList = existRawValues.map(val => valueEntities.get(val).key);\n\n        // Conduction by selected or not\n        let checkedKeys;\n        if (selected) {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, true, keyEntities));\n        } else {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, {\n            checked: false,\n            halfCheckedKeys: rawHalfCheckedValues\n          }, keyEntities));\n        }\n\n        // Fill back of keys\n        newRawValues = [...missingRawValues, ...checkedKeys.map(key => keyEntities[key].node[mergedFieldNames.value])];\n      }\n      triggerChange(newRawValues, {\n        selected,\n        triggerValue: selectedValue\n      }, source || 'option');\n    }\n\n    // Trigger select event\n    if (selected || !mergedMultiple) {\n      onSelect?.(selectedValue, fillLegacyProps(node));\n    } else {\n      onDeselect?.(selectedValue, fillLegacyProps(node));\n    }\n  }, [splitRawValues, valueEntities, keyEntities, mergedFieldNames, mergedMultiple, rawValues, triggerChange, treeConduction, onSelect, onDeselect, rawCheckedValues, rawHalfCheckedValues, maxCount]);\n\n  // ========================== Dropdown ==========================\n  const onInternalPopupVisibleChange = React.useCallback(open => {\n    if (onPopupVisibleChange) {\n      onPopupVisibleChange(open);\n    }\n  }, [onPopupVisibleChange]);\n\n  // ====================== Display Change ========================\n  const onDisplayValuesChange = useRefFunc((newValues, info) => {\n    const newRawValues = newValues.map(item => item.value);\n    if (info.type === 'clear') {\n      triggerChange(newRawValues, {}, 'selection');\n      return;\n    }\n\n    // TreeSelect only have multiple mode which means display change only has remove\n    if (info.values.length) {\n      onOptionSelect(info.values[0].value, {\n        selected: false,\n        source: 'selection'\n      });\n    }\n  });\n\n  // ========================== Context ===========================\n  const treeSelectContext = React.useMemo(() => {\n    return {\n      virtual,\n      popupMatchSelectWidth,\n      listHeight,\n      listItemHeight,\n      listItemScrollOffset,\n      treeData: filteredTreeData,\n      fieldNames: mergedFieldNames,\n      onSelect: onOptionSelect,\n      treeExpandAction,\n      treeTitleRender,\n      onPopupScroll,\n      leftMaxCount: maxCount === undefined ? null : maxCount - cachedDisplayValues.length,\n      leafCountOnly: mergedShowCheckedStrategy === 'SHOW_CHILD' && !treeCheckStrictly && !!treeCheckable,\n      valueEntities,\n      classNames: treeSelectClassNames,\n      styles\n    };\n  }, [virtual, popupMatchSelectWidth, listHeight, listItemHeight, listItemScrollOffset, filteredTreeData, mergedFieldNames, onOptionSelect, treeExpandAction, treeTitleRender, onPopupScroll, maxCount, cachedDisplayValues.length, mergedShowCheckedStrategy, treeCheckStrictly, treeCheckable, valueEntities, treeSelectClassNames, styles]);\n\n  // ======================= Legacy Context =======================\n  const legacyContext = React.useMemo(() => ({\n    checkable: mergedCheckable,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    checkedKeys: rawCheckedValues,\n    halfCheckedKeys: rawHalfCheckedValues,\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeIcon,\n    treeMotion,\n    showTreeIcon,\n    switcherIcon,\n    treeLine,\n    treeNodeFilterProp,\n    keyEntities\n  }), [mergedCheckable, loadData, treeLoadedKeys, onTreeLoad, rawCheckedValues, rawHalfCheckedValues, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeIcon, treeMotion, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, keyEntities]);\n\n  // =========================== Render ===========================\n  return /*#__PURE__*/React.createElement(TreeSelectContext.Provider, {\n    value: treeSelectContext\n  }, /*#__PURE__*/React.createElement(LegacyContext.Provider, {\n    value: legacyContext\n  }, /*#__PURE__*/React.createElement(BaseSelect, _extends({\n    ref: ref\n  }, restProps, {\n    classNames: treeSelectClassNames,\n    styles: styles\n    // >>> MISC\n    ,\n\n    id: mergedId,\n    prefixCls: prefixCls,\n    mode: mergedMultiple ? 'multiple' : undefined\n    // >>> Display Value\n    ,\n\n    displayValues: cachedDisplayValues,\n    onDisplayValuesChange: onDisplayValuesChange\n    // >>> Search\n    ,\n\n    autoClearSearchValue: autoClearSearchValue,\n    showSearch: mergedShowSearch,\n    searchValue: mergedSearchValue,\n    onSearch: onInternalSearch\n    // >>> Options\n    ,\n\n    OptionList: OptionList,\n    emptyOptions: !mergedTreeData.length,\n    onPopupVisibleChange: onInternalPopupVisibleChange,\n    popupMatchSelectWidth: popupMatchSelectWidth\n  }))));\n});\n\n// Assign name for Debug\nif (process.env.NODE_ENV !== 'production') {\n  TreeSelect.displayName = 'TreeSelect';\n}\nconst GenericTreeSelect = TreeSelect;\nGenericTreeSelect.TreeNode = TreeNode;\nGenericTreeSelect.SHOW_ALL = SHOW_ALL;\nGenericTreeSelect.SHOW_PARENT = SHOW_PARENT;\nGenericTreeSelect.SHOW_CHILD = SHOW_CHILD;\nexport default GenericTreeSelect;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","BaseSelect","useId","conductCheck","useControlledState","React","useCache","useCheckedKeys","useDataEntities","useFilterTreeData","useRefFunc","useTreeData","LegacyContext","OptionList","TreeNode","TreeSelectContext","fillAdditionalInfo","fillLegacyProps","formatStrategyValues","SHOW_ALL","SHOW_CHILD","SHOW_PARENT","fillFieldNames","isNil","toArray","warningProps","useSearchConfig","isRawValue","value","TreeSelect","forwardRef","props","ref","id","prefixCls","defaultValue","onChange","onSelect","onDeselect","showSearch","searchValue","legacySearchValue","inputValue","legacyinputValue","onSearch","legacyOnSearch","autoClearSearchValue","legacyAutoClearSearchValue","filterTreeNode","legacyFilterTreeNode","treeNodeFilterProp","legacytreeNodeFilterProp","showCheckedStrategy","treeNodeLabelProp","multiple","treeCheckable","treeCheckStrictly","labelInValue","maxCount","fieldNames","treeDataSimpleMode","treeData","children","loadData","treeLoadedKeys","onTreeLoad","treeDefaultExpandAll","treeExpandedKeys","treeDefaultExpandedKeys","onTreeExpand","treeExpandAction","virtual","listHeight","listItemHeight","listItemScrollOffset","onPopupVisibleChange","popupMatchSelectWidth","treeLine","treeIcon","showTreeIcon","switcherIcon","treeMotion","treeTitleRender","onPopupScroll","classNames","treeSelectClassNames","styles","restProps","mergedId","treeConduction","mergedCheckable","mergedLabelInValue","mergedMultiple","searchProps","mergedShowSearch","searchConfig","internalValue","setInternalValue","mergedShowCheckedStrategy","useMemo","process","env","NODE_ENV","mergedFieldNames","JSON","stringify","internalSearchValue","setSearchValue","mergedSearchValue","onInternalSearch","searchText","mergedTreeData","keyEntities","valueEntities","splitRawValues","useCallback","newRawValues","missingRawValues","existRawValues","forEach","val","has","push","filteredTreeData","getLabel","item","_title","titleList","title","undefined","toLabeledValues","draftValues","values","map","convert2LabelValues","label","rawLabel","rawValue","halfChecked","rawHalfChecked","rawDisabled","entity","get","node","disabled","labelInValueItem","find","labeledItem","rawMixedLabeledValues","rawLabeledValues","rawHalfLabeledValues","fullCheckValues","halfCheckValues","rawValues","rawCheckedValues","rawHalfCheckedValues","displayValues","displayKeys","labeledValues","targetItem","rawDisplayValues","firstVal","cachedDisplayValues","mergedMaxCount","triggerChange","extra","formattedKeyList","eventValues","triggerValue","selected","returnRawValues","halfValues","filter","includes","returnLabeledValues","additionalInfo","preValue","showPosition","checked","returnValues","onOptionSelect","selectedKey","selectedValue","v","keyList","checkedKeys","halfCheckedKeys","onInternalPopupVisibleChange","open","onDisplayValuesChange","newValues","info","type","treeSelectContext","leftMaxCount","leafCountOnly","legacyContext","checkable","createElement","Provider","mode","emptyOptions","displayName","GenericTreeSelect"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/tree-select/es/TreeSelect.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport { BaseSelect } from '@rc-component/select';\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport { conductCheck } from \"@rc-component/tree/es/utils/conductUtil\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport * as React from 'react';\nimport useCache from \"./hooks/useCache\";\nimport useCheckedKeys from \"./hooks/useCheckedKeys\";\nimport useDataEntities from \"./hooks/useDataEntities\";\nimport useFilterTreeData from \"./hooks/useFilterTreeData\";\nimport useRefFunc from \"./hooks/useRefFunc\";\nimport useTreeData from \"./hooks/useTreeData\";\nimport LegacyContext from \"./LegacyContext\";\nimport OptionList from \"./OptionList\";\nimport TreeNode from \"./TreeNode\";\nimport TreeSelectContext from \"./TreeSelectContext\";\nimport { fillAdditionalInfo, fillLegacyProps } from \"./utils/legacyUtil\";\nimport { formatStrategyValues, SHOW_ALL, SHOW_CHILD, SHOW_PARENT } from \"./utils/strategyUtil\";\nimport { fillFieldNames, isNil, toArray } from \"./utils/valueUtil\";\nimport warningProps from \"./utils/warningPropsUtil\";\nimport useSearchConfig from \"./hooks/useSearchConfig\";\nfunction isRawValue(value) {\n  return !value || typeof value !== 'object';\n}\nconst TreeSelect = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    id,\n    prefixCls = 'rc-tree-select',\n    // Value\n    value,\n    defaultValue,\n    onChange,\n    onSelect,\n    onDeselect,\n    // Search\n    showSearch,\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp,\n    // Selector\n    showCheckedStrategy,\n    treeNodeLabelProp,\n    //  Mode\n    multiple,\n    treeCheckable,\n    treeCheckStrictly,\n    labelInValue,\n    maxCount,\n    // FieldNames\n    fieldNames,\n    // Data\n    treeDataSimpleMode,\n    treeData,\n    children,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    // Expanded\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeExpandAction,\n    // Options\n    virtual,\n    listHeight = 200,\n    listItemHeight = 20,\n    listItemScrollOffset = 0,\n    onPopupVisibleChange,\n    popupMatchSelectWidth = true,\n    // Tree\n    treeLine,\n    treeIcon,\n    showTreeIcon,\n    switcherIcon,\n    treeMotion,\n    treeTitleRender,\n    onPopupScroll,\n    classNames: treeSelectClassNames,\n    styles,\n    ...restProps\n  } = props;\n  const mergedId = useId(id);\n  const treeConduction = treeCheckable && !treeCheckStrictly;\n  const mergedCheckable = treeCheckable || treeCheckStrictly;\n  const mergedLabelInValue = treeCheckStrictly || labelInValue;\n  const mergedMultiple = mergedCheckable || multiple;\n  const searchProps = {\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp\n  };\n  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps);\n  const {\n    searchValue,\n    onSearch,\n    autoClearSearchValue = true,\n    filterTreeNode,\n    treeNodeFilterProp = 'value'\n  } = searchConfig;\n  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);\n\n  // `multiple` && `!treeCheckable` should be show all\n  const mergedShowCheckedStrategy = React.useMemo(() => {\n    if (!treeCheckable) {\n      return SHOW_ALL;\n    }\n    return showCheckedStrategy || SHOW_CHILD;\n  }, [showCheckedStrategy, treeCheckable]);\n\n  // ========================== Warning ===========================\n  if (process.env.NODE_ENV !== 'production') {\n    warningProps(props);\n  }\n\n  // ========================= FieldNames =========================\n  const mergedFieldNames = React.useMemo(() => fillFieldNames(fieldNames), /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify(fieldNames)]\n  /* eslint-enable react-hooks/exhaustive-deps */);\n\n  // =========================== Search ===========================\n  const [internalSearchValue, setSearchValue] = useControlledState('', searchValue);\n  const mergedSearchValue = internalSearchValue || '';\n  const onInternalSearch = searchText => {\n    setSearchValue(searchText);\n    onSearch?.(searchText);\n  };\n\n  // ============================ Data ============================\n  // `useTreeData` only do convert of `children` or `simpleMode`.\n  // Else will return origin `treeData` for perf consideration.\n  // Do not do anything to loop the data.\n  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);\n  const {\n    keyEntities,\n    valueEntities\n  } = useDataEntities(mergedTreeData, mergedFieldNames);\n\n  /** Get `missingRawValues` which not exist in the tree yet */\n  const splitRawValues = React.useCallback(newRawValues => {\n    const missingRawValues = [];\n    const existRawValues = [];\n\n    // Keep missing value in the cache\n    newRawValues.forEach(val => {\n      if (valueEntities.has(val)) {\n        existRawValues.push(val);\n      } else {\n        missingRawValues.push(val);\n      }\n    });\n    return {\n      missingRawValues,\n      existRawValues\n    };\n  }, [valueEntities]);\n\n  // Filtered Tree\n  const filteredTreeData = useFilterTreeData(mergedTreeData, mergedSearchValue, {\n    fieldNames: mergedFieldNames,\n    treeNodeFilterProp,\n    filterTreeNode\n  });\n\n  // =========================== Label ============================\n  const getLabel = React.useCallback(item => {\n    if (item) {\n      if (treeNodeLabelProp) {\n        return item[treeNodeLabelProp];\n      }\n\n      // Loop from fieldNames\n      const {\n        _title: titleList\n      } = mergedFieldNames;\n      for (let i = 0; i < titleList.length; i += 1) {\n        const title = item[titleList[i]];\n        if (title !== undefined) {\n          return title;\n        }\n      }\n    }\n  }, [mergedFieldNames, treeNodeLabelProp]);\n\n  // ========================= Wrap Value =========================\n  const toLabeledValues = React.useCallback(draftValues => {\n    const values = toArray(draftValues);\n    return values.map(val => {\n      if (isRawValue(val)) {\n        return {\n          value: val\n        };\n      }\n      return val;\n    });\n  }, []);\n  const convert2LabelValues = React.useCallback(draftValues => {\n    const values = toLabeledValues(draftValues);\n    return values.map(item => {\n      let {\n        label: rawLabel\n      } = item;\n      const {\n        value: rawValue,\n        halfChecked: rawHalfChecked\n      } = item;\n      let rawDisabled;\n      const entity = valueEntities.get(rawValue);\n\n      // Fill missing label & status\n      if (entity) {\n        rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel ?? getLabel(entity.node);\n        rawDisabled = entity.node.disabled;\n      } else if (rawLabel === undefined) {\n        // We try to find in current `labelInValue` value\n        const labelInValueItem = toLabeledValues(internalValue).find(labeledItem => labeledItem.value === rawValue);\n        rawLabel = labelInValueItem.label;\n      }\n      return {\n        label: rawLabel,\n        value: rawValue,\n        halfChecked: rawHalfChecked,\n        disabled: rawDisabled\n      };\n    });\n  }, [valueEntities, getLabel, toLabeledValues, internalValue]);\n\n  // =========================== Values ===========================\n  const rawMixedLabeledValues = React.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);\n\n  // Split value into full check and half check\n  const [rawLabeledValues, rawHalfLabeledValues] = React.useMemo(() => {\n    const fullCheckValues = [];\n    const halfCheckValues = [];\n    rawMixedLabeledValues.forEach(item => {\n      if (item.halfChecked) {\n        halfCheckValues.push(item);\n      } else {\n        fullCheckValues.push(item);\n      }\n    });\n    return [fullCheckValues, halfCheckValues];\n  }, [rawMixedLabeledValues]);\n\n  // const [mergedValues] = useCache(rawLabeledValues);\n  const rawValues = React.useMemo(() => rawLabeledValues.map(item => item.value), [rawLabeledValues]);\n\n  // Convert value to key. Will fill missed keys for conduct check.\n  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);\n\n  // Convert rawCheckedKeys to check strategy related values\n  const displayValues = React.useMemo(() => {\n    // Collect keys which need to show\n    const displayKeys = formatStrategyValues(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Convert to value and filled with label\n    const values = displayKeys.map(key => keyEntities[key]?.node?.[mergedFieldNames.value] ?? key);\n\n    // Back fill with origin label\n    const labeledValues = values.map(val => {\n      const targetItem = rawLabeledValues.find(item => item.value === val);\n      const label = labelInValue ? targetItem?.label : treeTitleRender?.(targetItem);\n      return {\n        value: val,\n        label\n      };\n    });\n    const rawDisplayValues = convert2LabelValues(labeledValues);\n    const firstVal = rawDisplayValues[0];\n    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {\n      return [];\n    }\n    return rawDisplayValues.map(item => ({\n      ...item,\n      label: item.label ?? item.value\n    }));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [mergedFieldNames, mergedMultiple, rawCheckedValues, rawLabeledValues, convert2LabelValues, mergedShowCheckedStrategy, keyEntities]);\n  const [cachedDisplayValues] = useCache(displayValues);\n\n  // ========================== MaxCount ==========================\n  const mergedMaxCount = React.useMemo(() => {\n    if (mergedMultiple && (mergedShowCheckedStrategy === 'SHOW_CHILD' || treeCheckStrictly || !treeCheckable)) {\n      return maxCount;\n    }\n    return null;\n  }, [maxCount, mergedMultiple, treeCheckStrictly, mergedShowCheckedStrategy, treeCheckable]);\n\n  // =========================== Change ===========================\n  const triggerChange = useRefFunc((newRawValues, extra, source) => {\n    const formattedKeyList = formatStrategyValues(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Not allow pass with `maxCount`\n    if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) {\n      return;\n    }\n    const labeledValues = convert2LabelValues(newRawValues);\n    setInternalValue(labeledValues);\n\n    // Clean up if needed\n    if (autoClearSearchValue) {\n      setSearchValue('');\n    }\n\n    // Generate rest parameters is costly, so only do it when necessary\n    if (onChange) {\n      let eventValues = newRawValues;\n      if (treeConduction) {\n        eventValues = formattedKeyList.map(key => {\n          const entity = valueEntities.get(key);\n          return entity ? entity.node[mergedFieldNames.value] : key;\n        });\n      }\n      const {\n        triggerValue,\n        selected\n      } = extra || {\n        triggerValue: undefined,\n        selected: undefined\n      };\n      let returnRawValues = eventValues;\n\n      // We need fill half check back\n      if (treeCheckStrictly) {\n        const halfValues = rawHalfLabeledValues.filter(item => !eventValues.includes(item.value));\n        returnRawValues = [...returnRawValues, ...halfValues];\n      }\n      const returnLabeledValues = convert2LabelValues(returnRawValues);\n      const additionalInfo = {\n        // [Legacy] Always return as array contains label & value\n        preValue: rawLabeledValues,\n        triggerValue\n      };\n\n      // [Legacy] Fill legacy data if user query.\n      // This is expansive that we only fill when user query\n      // https://github.com/react-component/tree-select/blob/fe33eb7c27830c9ac70cd1fdb1ebbe7bc679c16a/src/Select.jsx\n      let showPosition = true;\n      if (treeCheckStrictly || source === 'selection' && !selected) {\n        showPosition = false;\n      }\n      fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);\n      if (mergedCheckable) {\n        additionalInfo.checked = selected;\n      } else {\n        additionalInfo.selected = selected;\n      }\n      const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map(item => item.value);\n      onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map(item => item.label), additionalInfo);\n    }\n  });\n\n  // ========================== Options ===========================\n  /** Trigger by option list */\n  const onOptionSelect = React.useCallback((selectedKey, {\n    selected,\n    source\n  }) => {\n    const entity = keyEntities[selectedKey];\n    const node = entity?.node;\n    const selectedValue = node?.[mergedFieldNames.value] ?? selectedKey;\n\n    // Never be falsy but keep it safe\n    if (!mergedMultiple) {\n      // Single mode always set value\n      triggerChange([selectedValue], {\n        selected: true,\n        triggerValue: selectedValue\n      }, 'option');\n    } else {\n      let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter(v => v !== selectedValue);\n\n      // Add keys if tree conduction\n      if (treeConduction) {\n        // Should keep missing values\n        const {\n          missingRawValues,\n          existRawValues\n        } = splitRawValues(newRawValues);\n        const keyList = existRawValues.map(val => valueEntities.get(val).key);\n\n        // Conduction by selected or not\n        let checkedKeys;\n        if (selected) {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, true, keyEntities));\n        } else {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, {\n            checked: false,\n            halfCheckedKeys: rawHalfCheckedValues\n          }, keyEntities));\n        }\n\n        // Fill back of keys\n        newRawValues = [...missingRawValues, ...checkedKeys.map(key => keyEntities[key].node[mergedFieldNames.value])];\n      }\n      triggerChange(newRawValues, {\n        selected,\n        triggerValue: selectedValue\n      }, source || 'option');\n    }\n\n    // Trigger select event\n    if (selected || !mergedMultiple) {\n      onSelect?.(selectedValue, fillLegacyProps(node));\n    } else {\n      onDeselect?.(selectedValue, fillLegacyProps(node));\n    }\n  }, [splitRawValues, valueEntities, keyEntities, mergedFieldNames, mergedMultiple, rawValues, triggerChange, treeConduction, onSelect, onDeselect, rawCheckedValues, rawHalfCheckedValues, maxCount]);\n\n  // ========================== Dropdown ==========================\n  const onInternalPopupVisibleChange = React.useCallback(open => {\n    if (onPopupVisibleChange) {\n      onPopupVisibleChange(open);\n    }\n  }, [onPopupVisibleChange]);\n\n  // ====================== Display Change ========================\n  const onDisplayValuesChange = useRefFunc((newValues, info) => {\n    const newRawValues = newValues.map(item => item.value);\n    if (info.type === 'clear') {\n      triggerChange(newRawValues, {}, 'selection');\n      return;\n    }\n\n    // TreeSelect only have multiple mode which means display change only has remove\n    if (info.values.length) {\n      onOptionSelect(info.values[0].value, {\n        selected: false,\n        source: 'selection'\n      });\n    }\n  });\n\n  // ========================== Context ===========================\n  const treeSelectContext = React.useMemo(() => {\n    return {\n      virtual,\n      popupMatchSelectWidth,\n      listHeight,\n      listItemHeight,\n      listItemScrollOffset,\n      treeData: filteredTreeData,\n      fieldNames: mergedFieldNames,\n      onSelect: onOptionSelect,\n      treeExpandAction,\n      treeTitleRender,\n      onPopupScroll,\n      leftMaxCount: maxCount === undefined ? null : maxCount - cachedDisplayValues.length,\n      leafCountOnly: mergedShowCheckedStrategy === 'SHOW_CHILD' && !treeCheckStrictly && !!treeCheckable,\n      valueEntities,\n      classNames: treeSelectClassNames,\n      styles\n    };\n  }, [virtual, popupMatchSelectWidth, listHeight, listItemHeight, listItemScrollOffset, filteredTreeData, mergedFieldNames, onOptionSelect, treeExpandAction, treeTitleRender, onPopupScroll, maxCount, cachedDisplayValues.length, mergedShowCheckedStrategy, treeCheckStrictly, treeCheckable, valueEntities, treeSelectClassNames, styles]);\n\n  // ======================= Legacy Context =======================\n  const legacyContext = React.useMemo(() => ({\n    checkable: mergedCheckable,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    checkedKeys: rawCheckedValues,\n    halfCheckedKeys: rawHalfCheckedValues,\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeIcon,\n    treeMotion,\n    showTreeIcon,\n    switcherIcon,\n    treeLine,\n    treeNodeFilterProp,\n    keyEntities\n  }), [mergedCheckable, loadData, treeLoadedKeys, onTreeLoad, rawCheckedValues, rawHalfCheckedValues, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeIcon, treeMotion, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, keyEntities]);\n\n  // =========================== Render ===========================\n  return /*#__PURE__*/React.createElement(TreeSelectContext.Provider, {\n    value: treeSelectContext\n  }, /*#__PURE__*/React.createElement(LegacyContext.Provider, {\n    value: legacyContext\n  }, /*#__PURE__*/React.createElement(BaseSelect, _extends({\n    ref: ref\n  }, restProps, {\n    classNames: treeSelectClassNames,\n    styles: styles\n    // >>> MISC\n    ,\n    id: mergedId,\n    prefixCls: prefixCls,\n    mode: mergedMultiple ? 'multiple' : undefined\n    // >>> Display Value\n    ,\n    displayValues: cachedDisplayValues,\n    onDisplayValuesChange: onDisplayValuesChange\n    // >>> Search\n    ,\n    autoClearSearchValue: autoClearSearchValue,\n    showSearch: mergedShowSearch,\n    searchValue: mergedSearchValue,\n    onSearch: onInternalSearch\n    // >>> Options\n    ,\n    OptionList: OptionList,\n    emptyOptions: !mergedTreeData.length,\n    onPopupVisibleChange: onInternalPopupVisibleChange,\n    popupMatchSelectWidth: popupMatchSelectWidth\n  }))));\n});\n\n// Assign name for Debug\nif (process.env.NODE_ENV !== 'production') {\n  TreeSelect.displayName = 'TreeSelect';\n}\nconst GenericTreeSelect = TreeSelect;\nGenericTreeSelect.TreeNode = TreeNode;\nGenericTreeSelect.SHOW_ALL = SHOW_ALL;\nGenericTreeSelect.SHOW_PARENT = SHOW_PARENT;\nGenericTreeSelect.SHOW_CHILD = SHOW_CHILD;\nexport default GenericTreeSelect;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}