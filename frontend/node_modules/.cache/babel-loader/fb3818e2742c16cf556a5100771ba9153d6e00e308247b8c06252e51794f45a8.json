{"ast":null,"code":"import warning from \"@rc-component/util/es/warning\";\nimport getEntity from \"./keyUtil\";\nfunction removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {\n  const filteredKeys = new Set();\n  halfCheckedKeys.forEach(key => {\n    if (!checkedKeys.has(key)) {\n      filteredKeys.add(key);\n    }\n  });\n  return filteredKeys;\n}\nexport function isCheckDisabled(node) {\n  const {\n    disabled,\n    disableCheckbox,\n    checkable\n  } = node || {};\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\n// Fill miss keys\nfunction fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  const halfCheckedKeys = new Set();\n\n  // Add checked keys top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.add(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Add checked keys from bottom to top\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(({\n        key\n      }) => {\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (allChecked) {\n        checkedKeys.add(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n// Remove useless key\nfunction cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  let halfCheckedKeys = new Set(halfKeys);\n\n  // Remove checked keys from top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.delete(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Remove checked keys form bottom to top\n  halfCheckedKeys = new Set();\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(({\n        key\n      }) => {\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (!allChecked) {\n        checkedKeys.delete(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n/**\n * Conduct with keys.\n * @param keyList current key list\n * @param keyEntities key - dataEntity map\n * @param mode `fill` to fill missing key, `clean` to remove useless key\n */\nexport function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {\n  const warningMissKeys = [];\n  let syntheticGetCheckDisabled;\n  if (getCheckDisabled) {\n    syntheticGetCheckDisabled = getCheckDisabled;\n  } else {\n    syntheticGetCheckDisabled = isCheckDisabled;\n  }\n\n  // We only handle exist keys\n  const keys = new Set(keyList.filter(key => {\n    const hasEntity = !!getEntity(keyEntities, key);\n    if (!hasEntity) {\n      warningMissKeys.push(key);\n    }\n    return hasEntity;\n  }));\n  const levelEntities = new Map();\n  let maxLevel = 0;\n\n  // Convert entities by level for calculation\n  Object.keys(keyEntities).forEach(key => {\n    const entity = keyEntities[key];\n    const {\n      level\n    } = entity;\n    let levelSet = levelEntities.get(level);\n    if (!levelSet) {\n      levelSet = new Set();\n      levelEntities.set(level, levelSet);\n    }\n    levelSet.add(entity);\n    maxLevel = Math.max(maxLevel, level);\n  });\n  warning(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map(key => `'${key}'`).join(', ')}`);\n  let result;\n  if (checked === true) {\n    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  } else {\n    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  }\n  return result;\n}","map":{"version":3,"names":["warning","getEntity","removeFromCheckedKeys","halfCheckedKeys","checkedKeys","filteredKeys","Set","forEach","key","has","add","isCheckDisabled","node","disabled","disableCheckbox","checkable","fillConductCheck","keys","levelEntities","maxLevel","syntheticGetCheckDisabled","level","entities","get","entity","children","filter","childEntity","visitedKeys","parent","allChecked","partialChecked","checked","Array","from","cleanConductCheck","halfKeys","delete","conductCheck","keyList","keyEntities","getCheckDisabled","warningMissKeys","hasEntity","push","Map","Object","levelSet","set","Math","max","length","slice","map","join","result"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/tree/es/utils/conductUtil.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nimport getEntity from \"./keyUtil\";\nfunction removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {\n  const filteredKeys = new Set();\n  halfCheckedKeys.forEach(key => {\n    if (!checkedKeys.has(key)) {\n      filteredKeys.add(key);\n    }\n  });\n  return filteredKeys;\n}\nexport function isCheckDisabled(node) {\n  const {\n    disabled,\n    disableCheckbox,\n    checkable\n  } = node || {};\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\n// Fill miss keys\nfunction fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  const halfCheckedKeys = new Set();\n\n  // Add checked keys top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.add(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Add checked keys from bottom to top\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(({\n        key\n      }) => {\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (allChecked) {\n        checkedKeys.add(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n// Remove useless key\nfunction cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  let halfCheckedKeys = new Set(halfKeys);\n\n  // Remove checked keys from top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.delete(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Remove checked keys form bottom to top\n  halfCheckedKeys = new Set();\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(({\n        key\n      }) => {\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (!allChecked) {\n        checkedKeys.delete(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n/**\n * Conduct with keys.\n * @param keyList current key list\n * @param keyEntities key - dataEntity map\n * @param mode `fill` to fill missing key, `clean` to remove useless key\n */\nexport function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {\n  const warningMissKeys = [];\n  let syntheticGetCheckDisabled;\n  if (getCheckDisabled) {\n    syntheticGetCheckDisabled = getCheckDisabled;\n  } else {\n    syntheticGetCheckDisabled = isCheckDisabled;\n  }\n\n  // We only handle exist keys\n  const keys = new Set(keyList.filter(key => {\n    const hasEntity = !!getEntity(keyEntities, key);\n    if (!hasEntity) {\n      warningMissKeys.push(key);\n    }\n    return hasEntity;\n  }));\n  const levelEntities = new Map();\n  let maxLevel = 0;\n\n  // Convert entities by level for calculation\n  Object.keys(keyEntities).forEach(key => {\n    const entity = keyEntities[key];\n    const {\n      level\n    } = entity;\n    let levelSet = levelEntities.get(level);\n    if (!levelSet) {\n      levelSet = new Set();\n      levelEntities.set(level, levelSet);\n    }\n    levelSet.add(entity);\n    maxLevel = Math.max(maxLevel, level);\n  });\n  warning(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map(key => `'${key}'`).join(', ')}`);\n  let result;\n  if (checked === true) {\n    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  } else {\n    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  }\n  return result;\n}"],"mappings":"AAAA,OAAOA,OAAO,MAAM,+BAA+B;AACnD,OAAOC,SAAS,MAAM,WAAW;AACjC,SAASC,qBAAqBA,CAACC,eAAe,EAAEC,WAAW,EAAE;EAC3D,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC9BH,eAAe,CAACI,OAAO,CAACC,GAAG,IAAI;IAC7B,IAAI,CAACJ,WAAW,CAACK,GAAG,CAACD,GAAG,CAAC,EAAE;MACzBH,YAAY,CAACK,GAAG,CAACF,GAAG,CAAC;IACvB;EACF,CAAC,CAAC;EACF,OAAOH,YAAY;AACrB;AACA,OAAO,SAASM,eAAeA,CAACC,IAAI,EAAE;EACpC,MAAM;IACJC,QAAQ;IACRC,eAAe;IACfC;EACF,CAAC,GAAGH,IAAI,IAAI,CAAC,CAAC;EACd,OAAO,CAAC,EAAEC,QAAQ,IAAIC,eAAe,CAAC,IAAIC,SAAS,KAAK,KAAK;AAC/D;;AAEA;AACA,SAASC,gBAAgBA,CAACC,IAAI,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,yBAAyB,EAAE;EAClF,MAAMhB,WAAW,GAAG,IAAIE,GAAG,CAACW,IAAI,CAAC;EACjC,MAAMd,eAAe,GAAG,IAAIG,GAAG,CAAC,CAAC;;EAEjC;EACA,KAAK,IAAIe,KAAK,GAAG,CAAC,EAAEA,KAAK,IAAIF,QAAQ,EAAEE,KAAK,IAAI,CAAC,EAAE;IACjD,MAAMC,QAAQ,GAAGJ,aAAa,CAACK,GAAG,CAACF,KAAK,CAAC,IAAI,IAAIf,GAAG,CAAC,CAAC;IACtDgB,QAAQ,CAACf,OAAO,CAACiB,MAAM,IAAI;MACzB,MAAM;QACJhB,GAAG;QACHI,IAAI;QACJa,QAAQ,GAAG;MACb,CAAC,GAAGD,MAAM;MACV,IAAIpB,WAAW,CAACK,GAAG,CAACD,GAAG,CAAC,IAAI,CAACY,yBAAyB,CAACR,IAAI,CAAC,EAAE;QAC5Da,QAAQ,CAACC,MAAM,CAACC,WAAW,IAAI,CAACP,yBAAyB,CAACO,WAAW,CAACf,IAAI,CAAC,CAAC,CAACL,OAAO,CAACoB,WAAW,IAAI;UAClGvB,WAAW,CAACM,GAAG,CAACiB,WAAW,CAACnB,GAAG,CAAC;QAClC,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMoB,WAAW,GAAG,IAAItB,GAAG,CAAC,CAAC;EAC7B,KAAK,IAAIe,KAAK,GAAGF,QAAQ,EAAEE,KAAK,IAAI,CAAC,EAAEA,KAAK,IAAI,CAAC,EAAE;IACjD,MAAMC,QAAQ,GAAGJ,aAAa,CAACK,GAAG,CAACF,KAAK,CAAC,IAAI,IAAIf,GAAG,CAAC,CAAC;IACtDgB,QAAQ,CAACf,OAAO,CAACiB,MAAM,IAAI;MACzB,MAAM;QACJK,MAAM;QACNjB;MACF,CAAC,GAAGY,MAAM;;MAEV;MACA,IAAIJ,yBAAyB,CAACR,IAAI,CAAC,IAAI,CAACY,MAAM,CAACK,MAAM,IAAID,WAAW,CAACnB,GAAG,CAACe,MAAM,CAACK,MAAM,CAACrB,GAAG,CAAC,EAAE;QAC3F;MACF;;MAEA;MACA,IAAIY,yBAAyB,CAACI,MAAM,CAACK,MAAM,CAACjB,IAAI,CAAC,EAAE;QACjDgB,WAAW,CAAClB,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;QAC3B;MACF;MACA,IAAIsB,UAAU,GAAG,IAAI;MACrB,IAAIC,cAAc,GAAG,KAAK;MAC1B,CAACF,MAAM,CAACJ,QAAQ,IAAI,EAAE,EAAEC,MAAM,CAACC,WAAW,IAAI,CAACP,yBAAyB,CAACO,WAAW,CAACf,IAAI,CAAC,CAAC,CAACL,OAAO,CAAC,CAAC;QACnGC;MACF,CAAC,KAAK;QACJ,MAAMwB,OAAO,GAAG5B,WAAW,CAACK,GAAG,CAACD,GAAG,CAAC;QACpC,IAAIsB,UAAU,IAAI,CAACE,OAAO,EAAE;UAC1BF,UAAU,GAAG,KAAK;QACpB;QACA,IAAI,CAACC,cAAc,KAAKC,OAAO,IAAI7B,eAAe,CAACM,GAAG,CAACD,GAAG,CAAC,CAAC,EAAE;UAC5DuB,cAAc,GAAG,IAAI;QACvB;MACF,CAAC,CAAC;MACF,IAAID,UAAU,EAAE;QACd1B,WAAW,CAACM,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;MAC7B;MACA,IAAIuB,cAAc,EAAE;QAClB5B,eAAe,CAACO,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;MACjC;MACAoB,WAAW,CAAClB,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;IAC7B,CAAC,CAAC;EACJ;EACA,OAAO;IACLJ,WAAW,EAAE6B,KAAK,CAACC,IAAI,CAAC9B,WAAW,CAAC;IACpCD,eAAe,EAAE8B,KAAK,CAACC,IAAI,CAAChC,qBAAqB,CAACC,eAAe,EAAEC,WAAW,CAAC;EACjF,CAAC;AACH;;AAEA;AACA,SAAS+B,iBAAiBA,CAAClB,IAAI,EAAEmB,QAAQ,EAAElB,aAAa,EAAEC,QAAQ,EAAEC,yBAAyB,EAAE;EAC7F,MAAMhB,WAAW,GAAG,IAAIE,GAAG,CAACW,IAAI,CAAC;EACjC,IAAId,eAAe,GAAG,IAAIG,GAAG,CAAC8B,QAAQ,CAAC;;EAEvC;EACA,KAAK,IAAIf,KAAK,GAAG,CAAC,EAAEA,KAAK,IAAIF,QAAQ,EAAEE,KAAK,IAAI,CAAC,EAAE;IACjD,MAAMC,QAAQ,GAAGJ,aAAa,CAACK,GAAG,CAACF,KAAK,CAAC,IAAI,IAAIf,GAAG,CAAC,CAAC;IACtDgB,QAAQ,CAACf,OAAO,CAACiB,MAAM,IAAI;MACzB,MAAM;QACJhB,GAAG;QACHI,IAAI;QACJa,QAAQ,GAAG;MACb,CAAC,GAAGD,MAAM;MACV,IAAI,CAACpB,WAAW,CAACK,GAAG,CAACD,GAAG,CAAC,IAAI,CAACL,eAAe,CAACM,GAAG,CAACD,GAAG,CAAC,IAAI,CAACY,yBAAyB,CAACR,IAAI,CAAC,EAAE;QAC1Fa,QAAQ,CAACC,MAAM,CAACC,WAAW,IAAI,CAACP,yBAAyB,CAACO,WAAW,CAACf,IAAI,CAAC,CAAC,CAACL,OAAO,CAACoB,WAAW,IAAI;UAClGvB,WAAW,CAACiC,MAAM,CAACV,WAAW,CAACnB,GAAG,CAAC;QACrC,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;;EAEA;EACAL,eAAe,GAAG,IAAIG,GAAG,CAAC,CAAC;EAC3B,MAAMsB,WAAW,GAAG,IAAItB,GAAG,CAAC,CAAC;EAC7B,KAAK,IAAIe,KAAK,GAAGF,QAAQ,EAAEE,KAAK,IAAI,CAAC,EAAEA,KAAK,IAAI,CAAC,EAAE;IACjD,MAAMC,QAAQ,GAAGJ,aAAa,CAACK,GAAG,CAACF,KAAK,CAAC,IAAI,IAAIf,GAAG,CAAC,CAAC;IACtDgB,QAAQ,CAACf,OAAO,CAACiB,MAAM,IAAI;MACzB,MAAM;QACJK,MAAM;QACNjB;MACF,CAAC,GAAGY,MAAM;;MAEV;MACA,IAAIJ,yBAAyB,CAACR,IAAI,CAAC,IAAI,CAACY,MAAM,CAACK,MAAM,IAAID,WAAW,CAACnB,GAAG,CAACe,MAAM,CAACK,MAAM,CAACrB,GAAG,CAAC,EAAE;QAC3F;MACF;;MAEA;MACA,IAAIY,yBAAyB,CAACI,MAAM,CAACK,MAAM,CAACjB,IAAI,CAAC,EAAE;QACjDgB,WAAW,CAAClB,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;QAC3B;MACF;MACA,IAAIsB,UAAU,GAAG,IAAI;MACrB,IAAIC,cAAc,GAAG,KAAK;MAC1B,CAACF,MAAM,CAACJ,QAAQ,IAAI,EAAE,EAAEC,MAAM,CAACC,WAAW,IAAI,CAACP,yBAAyB,CAACO,WAAW,CAACf,IAAI,CAAC,CAAC,CAACL,OAAO,CAAC,CAAC;QACnGC;MACF,CAAC,KAAK;QACJ,MAAMwB,OAAO,GAAG5B,WAAW,CAACK,GAAG,CAACD,GAAG,CAAC;QACpC,IAAIsB,UAAU,IAAI,CAACE,OAAO,EAAE;UAC1BF,UAAU,GAAG,KAAK;QACpB;QACA,IAAI,CAACC,cAAc,KAAKC,OAAO,IAAI7B,eAAe,CAACM,GAAG,CAACD,GAAG,CAAC,CAAC,EAAE;UAC5DuB,cAAc,GAAG,IAAI;QACvB;MACF,CAAC,CAAC;MACF,IAAI,CAACD,UAAU,EAAE;QACf1B,WAAW,CAACiC,MAAM,CAACR,MAAM,CAACrB,GAAG,CAAC;MAChC;MACA,IAAIuB,cAAc,EAAE;QAClB5B,eAAe,CAACO,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;MACjC;MACAoB,WAAW,CAAClB,GAAG,CAACmB,MAAM,CAACrB,GAAG,CAAC;IAC7B,CAAC,CAAC;EACJ;EACA,OAAO;IACLJ,WAAW,EAAE6B,KAAK,CAACC,IAAI,CAAC9B,WAAW,CAAC;IACpCD,eAAe,EAAE8B,KAAK,CAACC,IAAI,CAAChC,qBAAqB,CAACC,eAAe,EAAEC,WAAW,CAAC;EACjF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkC,YAAYA,CAACC,OAAO,EAAEP,OAAO,EAAEQ,WAAW,EAAEC,gBAAgB,EAAE;EAC5E,MAAMC,eAAe,GAAG,EAAE;EAC1B,IAAItB,yBAAyB;EAC7B,IAAIqB,gBAAgB,EAAE;IACpBrB,yBAAyB,GAAGqB,gBAAgB;EAC9C,CAAC,MAAM;IACLrB,yBAAyB,GAAGT,eAAe;EAC7C;;EAEA;EACA,MAAMM,IAAI,GAAG,IAAIX,GAAG,CAACiC,OAAO,CAACb,MAAM,CAAClB,GAAG,IAAI;IACzC,MAAMmC,SAAS,GAAG,CAAC,CAAC1C,SAAS,CAACuC,WAAW,EAAEhC,GAAG,CAAC;IAC/C,IAAI,CAACmC,SAAS,EAAE;MACdD,eAAe,CAACE,IAAI,CAACpC,GAAG,CAAC;IAC3B;IACA,OAAOmC,SAAS;EAClB,CAAC,CAAC,CAAC;EACH,MAAMzB,aAAa,GAAG,IAAI2B,GAAG,CAAC,CAAC;EAC/B,IAAI1B,QAAQ,GAAG,CAAC;;EAEhB;EACA2B,MAAM,CAAC7B,IAAI,CAACuB,WAAW,CAAC,CAACjC,OAAO,CAACC,GAAG,IAAI;IACtC,MAAMgB,MAAM,GAAGgB,WAAW,CAAChC,GAAG,CAAC;IAC/B,MAAM;MACJa;IACF,CAAC,GAAGG,MAAM;IACV,IAAIuB,QAAQ,GAAG7B,aAAa,CAACK,GAAG,CAACF,KAAK,CAAC;IACvC,IAAI,CAAC0B,QAAQ,EAAE;MACbA,QAAQ,GAAG,IAAIzC,GAAG,CAAC,CAAC;MACpBY,aAAa,CAAC8B,GAAG,CAAC3B,KAAK,EAAE0B,QAAQ,CAAC;IACpC;IACAA,QAAQ,CAACrC,GAAG,CAACc,MAAM,CAAC;IACpBL,QAAQ,GAAG8B,IAAI,CAACC,GAAG,CAAC/B,QAAQ,EAAEE,KAAK,CAAC;EACtC,CAAC,CAAC;EACFrB,OAAO,CAAC,CAAC0C,eAAe,CAACS,MAAM,EAAE,6BAA6BT,eAAe,CAACU,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAACC,GAAG,CAAC7C,GAAG,IAAI,IAAIA,GAAG,GAAG,CAAC,CAAC8C,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;EAChI,IAAIC,MAAM;EACV,IAAIvB,OAAO,KAAK,IAAI,EAAE;IACpBuB,MAAM,GAAGvC,gBAAgB,CAACC,IAAI,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,yBAAyB,CAAC;EACrF,CAAC,MAAM;IACLmC,MAAM,GAAGpB,iBAAiB,CAAClB,IAAI,EAAEe,OAAO,CAAC7B,eAAe,EAAEe,aAAa,EAAEC,QAAQ,EAAEC,yBAAyB,CAAC;EAC/G;EACA,OAAOmC,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}