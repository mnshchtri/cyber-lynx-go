{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n// TODO: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/treeview/treeview-2/treeview-2a.html\n// Fully accessibility support\n\nimport { clsx } from 'clsx';\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  static defaultProps = {\n    prefixCls: 'rc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true,\n    expandAction: false\n  };\n  static TreeNode = TreeNode;\n  destroyed = false;\n  delayedDragEnterLogic;\n  loadingRetryTimes = {};\n  state = {\n    keyEntities: {},\n    indent: null,\n    selectedKeys: [],\n    checkedKeys: [],\n    halfCheckedKeys: [],\n    loadedKeys: [],\n    loadingKeys: [],\n    expandedKeys: [],\n    draggingNodeKey: null,\n    dragChildrenKeys: [],\n    // dropTargetKey is the key of abstract-drop-node\n    // the abstract-drop-node is the real drop node when drag and drop\n    // not the DOM drag over node\n    dropTargetKey: null,\n    dropPosition: null,\n    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n    dropContainerKey: null,\n    // the container key of abstract-drop-node if dropPosition is -1 or 1\n    dropLevelOffset: null,\n    // the drop level offset of abstract-drag-over-node\n    dropTargetPos: null,\n    // the pos of abstract-drop-node\n    dropAllowed: true,\n    // if drop to abstract-drop-node is allowed\n    // the abstract-drag-over-node\n    // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n    // abstract-drag-over-node is the top node\n    dragOverNodeKey: null,\n    treeData: [],\n    flattenNodes: [],\n    focused: false,\n    activeKey: null,\n    listChanging: false,\n    prevProps: null,\n    fieldNames: fillFieldNames()\n  };\n  dragStartMousePosition = null;\n  dragNodeProps = null;\n  currentMouseOverDroppableNodeKey = null;\n  listRef = /*#__PURE__*/React.createRef();\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = {\n        [MOTION_KEY]: MotionEntity,\n        ...entitiesMap.keyEntities\n      };\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = {\n        ...keyEntities\n      };\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  onNodeDragStart = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities\n    } = this.state;\n    const {\n      onDragStart\n    } = this.props;\n    const {\n      eventKey\n    } = nodeProps;\n    this.dragNodeProps = nodeProps;\n    this.dragStartMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const newExpandedKeys = arrDel(expandedKeys, eventKey);\n    this.setState({\n      draggingNodeKey: eventKey,\n      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n      indent: this.listRef.current.getIndentWidth()\n    });\n    this.setExpandedKeys(newExpandedKeys);\n    window.addEventListener('dragend', this.onWindowDragEnd);\n    onDragStart?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  /**\n   * [Legacy] Select handler is smaller than node,\n   * so that this will trigger when drag enter node or select handler.\n   * This is a little tricky if customize css without padding.\n   * Better for use mouse move event to refresh drag state.\n   * But let's just keep it to avoid event trigger logic change.\n   */\n  onNodeDragEnter = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities,\n      dragChildrenKeys,\n      flattenNodes,\n      indent\n    } = this.state;\n    const {\n      onDragEnter,\n      onExpand,\n      allowDrop,\n      direction\n    } = this.props;\n    const {\n      pos,\n      eventKey\n    } = nodeProps;\n\n    // record the key of node which is latest entered, used in dragleave event.\n    if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n      this.currentMouseOverDroppableNodeKey = eventKey;\n    }\n    if (!this.dragNodeProps) {\n      this.resetDragState();\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (\n    // don't allow drop inside its children\n    dragChildrenKeys.includes(dropTargetKey) ||\n    // don't allow drop when drop is not allowed caculated by calcDropPosition\n    !dropAllowed) {\n      this.resetDragState();\n      return;\n    }\n\n    // Side effect for delay drag\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(key => {\n      clearTimeout(this.delayedDragEnterLogic[key]);\n    });\n    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n      // hoist expand logic here\n      // since if logic is on the bottom\n      // it will be blocked by abstract dragover node check\n      //   => if you dragenter from top, you mouse will still be consider as in the top node\n      event.persist();\n      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n        if (this.state.draggingNodeKey === null) {\n          return;\n        }\n        let newExpandedKeys = [...expandedKeys];\n        const entity = getEntity(keyEntities, nodeProps.eventKey);\n        if (entity && (entity.children || []).length) {\n          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n        }\n        if (!this.props.hasOwnProperty('expandedKeys')) {\n          this.setExpandedKeys(newExpandedKeys);\n        }\n        onExpand?.(newExpandedKeys, {\n          node: convertNodePropsToEventData(nodeProps),\n          expanded: true,\n          nativeEvent: event.nativeEvent\n        });\n      }, 800);\n    }\n\n    // Skip if drag node is self\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      this.resetDragState();\n      return;\n    }\n\n    // Update drag over node and drag state\n    this.setState({\n      dragOverNodeKey,\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed\n    });\n    onDragEnter?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps),\n      expandedKeys\n    });\n  };\n  onNodeDragOver = (event, nodeProps) => {\n    const {\n      dragChildrenKeys,\n      flattenNodes,\n      keyEntities,\n      expandedKeys,\n      indent\n    } = this.state;\n    const {\n      onDragOver,\n      allowDrop,\n      direction\n    } = this.props;\n    if (!this.dragNodeProps) {\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n      // don't allow drop inside its children\n      // don't allow drop when drop is not allowed calculated by calcDropPosition\n      return;\n    }\n\n    // Update drag position\n\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n        this.resetDragState();\n      }\n    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n      this.setState({\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      });\n    }\n    onDragOver?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n  onNodeDragLeave = (event, nodeProps) => {\n    // if it is outside the droppable area\n    // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n      this.resetDragState();\n      this.currentMouseOverDroppableNodeKey = null;\n    }\n    const {\n      onDragLeave\n    } = this.props;\n    onDragLeave?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  // since stopPropagation() is called in treeNode\n  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n  onWindowDragEnd = event => {\n    this.onNodeDragEnd(event, null, true);\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n\n  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n  onNodeDragEnd = (event, nodeProps) => {\n    const {\n      onDragEnd\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    onDragEnd?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n    this.dragNodeProps = null;\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n  onNodeDrop = (event, _, outsideTree = false) => {\n    const {\n      dragChildrenKeys,\n      dropPosition,\n      dropTargetKey,\n      dropTargetPos,\n      dropAllowed\n    } = this.state;\n    if (!dropAllowed) {\n      return;\n    }\n    const {\n      onDrop\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    if (dropTargetKey === null) return;\n    const abstractDropNodeProps = {\n      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),\n      active: this.getActiveItem()?.key === dropTargetKey,\n      data: getEntity(this.state.keyEntities, dropTargetKey).node\n    };\n    const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n    warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n    const posArr = posToArr(dropTargetPos);\n    const dropResult = {\n      event,\n      node: convertNodePropsToEventData(abstractDropNodeProps),\n      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,\n      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n      dropToGap: dropPosition !== 0,\n      dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (!outsideTree) {\n      onDrop?.(dropResult);\n    }\n    this.dragNodeProps = null;\n  };\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  cleanDragState = () => {\n    const {\n      draggingNodeKey\n    } = this.state;\n    if (draggingNodeKey !== null) {\n      this.setState({\n        draggingNodeKey: null,\n        dropPosition: null,\n        dropContainerKey: null,\n        dropTargetKey: null,\n        dropLevelOffset: null,\n        dropAllowed: true,\n        dragOverNodeKey: null\n      });\n    }\n    this.dragStartMousePosition = null;\n    this.currentMouseOverDroppableNodeKey = null;\n  };\n  triggerExpandActionExpand = (e, treeNode) => {\n    const {\n      expandedKeys,\n      flattenNodes\n    } = this.state;\n    const {\n      expanded,\n      key,\n      isLeaf\n    } = treeNode;\n    if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n    const eventNode = convertNodePropsToEventData({\n      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),\n      data: node.data\n    });\n    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n    this.onNodeExpand(e, eventNode);\n  };\n  onNodeClick = (e, treeNode) => {\n    const {\n      onClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'click') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onClick?.(e, treeNode);\n  };\n  onNodeDoubleClick = (e, treeNode) => {\n    const {\n      onDoubleClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'doubleClick') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onDoubleClick?.(e, treeNode);\n  };\n  onNodeSelect = (e, treeNode) => {\n    let {\n      selectedKeys\n    } = this.state;\n    const {\n      keyEntities,\n      fieldNames\n    } = this.state;\n    const {\n      onSelect,\n      multiple\n    } = this.props;\n    const {\n      selected\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n    const targetSelected = !selected;\n\n    // Update selected keys\n    if (!targetSelected) {\n      selectedKeys = arrDel(selectedKeys, key);\n    } else if (!multiple) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = arrAdd(selectedKeys, key);\n    }\n\n    // [Legacy] Not found related usage in doc or upper libs\n    const selectedNodes = selectedKeys.map(selectedKey => {\n      const entity = getEntity(keyEntities, selectedKey);\n      return entity ? entity.node : null;\n    }).filter(Boolean);\n    this.setUncontrolledState({\n      selectedKeys\n    });\n    onSelect?.(selectedKeys, {\n      event: 'select',\n      selected: targetSelected,\n      node: treeNode,\n      selectedNodes,\n      nativeEvent: e.nativeEvent\n    });\n  };\n  onNodeCheck = (e, treeNode, checked) => {\n    const {\n      keyEntities,\n      checkedKeys: oriCheckedKeys,\n      halfCheckedKeys: oriHalfCheckedKeys\n    } = this.state;\n    const {\n      checkStrictly,\n      onCheck\n    } = this.props;\n    const {\n      key\n    } = treeNode;\n\n    // Prepare trigger arguments\n    let checkedObj;\n    const eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked,\n      nativeEvent: e.nativeEvent\n    };\n    if (checkStrictly) {\n      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n      checkedObj = {\n        checked: checkedKeys,\n        halfChecked: halfCheckedKeys\n      };\n      eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n      this.setUncontrolledState({\n        checkedKeys\n      });\n    } else {\n      // Always fill first\n      let {\n        checkedKeys,\n        halfCheckedKeys\n      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n      // If remove, we do it again to correction\n      if (!checked) {\n        const keySet = new Set(checkedKeys);\n        keySet.delete(key);\n        ({\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck(Array.from(keySet), {\n          checked: false,\n          halfCheckedKeys\n        }, keyEntities));\n      }\n      checkedObj = checkedKeys;\n\n      // [Legacy] This is used for `rc-tree-select`\n      eventObj.checkedNodes = [];\n      eventObj.checkedNodesPositions = [];\n      eventObj.halfCheckedKeys = halfCheckedKeys;\n      checkedKeys.forEach(checkedKey => {\n        const entity = getEntity(keyEntities, checkedKey);\n        if (!entity) return;\n        const {\n          node,\n          pos\n        } = entity;\n        eventObj.checkedNodes.push(node);\n        eventObj.checkedNodesPositions.push({\n          node,\n          pos\n        });\n      });\n      this.setUncontrolledState({\n        checkedKeys\n      }, false, {\n        halfCheckedKeys\n      });\n    }\n    onCheck?.(checkedObj, eventObj);\n  };\n  onNodeLoad = treeNode => {\n    const {\n      key\n    } = treeNode;\n    const {\n      keyEntities\n    } = this.state;\n\n    // Skip if has children already\n    const entity = getEntity(keyEntities, key);\n    if (entity?.children?.length) {\n      return;\n    }\n    const loadPromise = new Promise((resolve, reject) => {\n      // We need to get the latest state of loading/loaded keys\n      this.setState(({\n        loadedKeys = [],\n        loadingKeys = []\n      }) => {\n        const {\n          loadData,\n          onLoad\n        } = this.props;\n        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n          return null;\n        }\n\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const {\n            loadedKeys: currentLoadedKeys\n          } = this.state;\n          const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          onLoad?.(newLoadedKeys, {\n            event: 'load',\n            node: treeNode\n          });\n          this.setUncontrolledState({\n            loadedKeys: newLoadedKeys\n          });\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n          resolve();\n        }).catch(e => {\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n\n          // If exceed max retry times, we give up retry\n          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            this.setUncontrolledState({\n              loadedKeys: arrAdd(currentLoadedKeys, key)\n            });\n            resolve();\n          }\n          reject(e);\n        });\n        return {\n          loadingKeys: arrAdd(loadingKeys, key)\n        };\n      });\n    });\n\n    // Not care warning if we ignore this\n    loadPromise.catch(() => {});\n    return loadPromise;\n  };\n  onNodeMouseEnter = (event, node) => {\n    const {\n      onMouseEnter\n    } = this.props;\n    onMouseEnter?.({\n      event,\n      node\n    });\n  };\n  onNodeMouseLeave = (event, node) => {\n    const {\n      onMouseLeave\n    } = this.props;\n    onMouseLeave?.({\n      event,\n      node\n    });\n  };\n  onNodeContextMenu = (event, node) => {\n    const {\n      onRightClick\n    } = this.props;\n    if (onRightClick) {\n      event.preventDefault();\n      onRightClick({\n        event,\n        node\n      });\n    }\n  };\n  onFocus = (...args) => {\n    const {\n      onFocus\n    } = this.props;\n    this.setState({\n      focused: true\n    });\n    onFocus?.(...args);\n  };\n  onBlur = (...args) => {\n    const {\n      onBlur\n    } = this.props;\n    this.setState({\n      focused: false\n    });\n    this.onActiveChange(null);\n    onBlur?.(...args);\n  };\n  getTreeNodeRequiredProps = () => {\n    const {\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities\n    } = this.state;\n    return {\n      expandedKeys: expandedKeys || [],\n      selectedKeys: selectedKeys || [],\n      loadedKeys: loadedKeys || [],\n      loadingKeys: loadingKeys || [],\n      checkedKeys: checkedKeys || [],\n      halfCheckedKeys: halfCheckedKeys || [],\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities: keyEntities\n    };\n  };\n\n  // =========================== Expanded ===========================\n  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n  setExpandedKeys = expandedKeys => {\n    const {\n      treeData,\n      fieldNames\n    } = this.state;\n    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n    this.setUncontrolledState({\n      expandedKeys,\n      flattenNodes\n    }, true);\n  };\n  onNodeExpand = (e, treeNode) => {\n    let {\n      expandedKeys\n    } = this.state;\n    const {\n      listChanging,\n      fieldNames\n    } = this.state;\n    const {\n      onExpand,\n      loadData\n    } = this.props;\n    const {\n      expanded\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n\n    // Do nothing when motion is in progress\n    if (listChanging) {\n      return;\n    }\n\n    // Update selected keys\n    const certain = expandedKeys.includes(key);\n    const targetExpanded = !expanded;\n    warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n    this.setExpandedKeys(expandedKeys);\n    onExpand?.(expandedKeys, {\n      node: treeNode,\n      expanded: targetExpanded,\n      nativeEvent: e.nativeEvent\n    });\n\n    // Async Load data\n    if (targetExpanded && loadData) {\n      const loadPromise = this.onNodeLoad(treeNode);\n      if (loadPromise) {\n        loadPromise.then(() => {\n          // [Legacy] Refresh logic\n          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n          this.setUncontrolledState({\n            flattenNodes: newFlattenTreeData\n          });\n        }).catch(() => {\n          const {\n            expandedKeys: currentExpandedKeys\n          } = this.state;\n          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n          this.setExpandedKeys(expandedKeysToRestore);\n        });\n      }\n    }\n  };\n  onListChangeStart = () => {\n    this.setUncontrolledState({\n      listChanging: true\n    });\n  };\n  onListChangeEnd = () => {\n    setTimeout(() => {\n      this.setUncontrolledState({\n        listChanging: false\n      });\n    });\n  };\n\n  // =========================== Keyboard ===========================\n  onActiveChange = newActiveKey => {\n    const {\n      activeKey\n    } = this.state;\n    const {\n      onActiveChange,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey === newActiveKey) {\n      return;\n    }\n    this.setState({\n      activeKey: newActiveKey\n    });\n    if (newActiveKey !== null) {\n      this.scrollTo({\n        key: newActiveKey,\n        offset: itemScrollOffset\n      });\n    }\n    onActiveChange?.(newActiveKey);\n  };\n  getActiveItem = () => {\n    const {\n      activeKey,\n      flattenNodes\n    } = this.state;\n    if (activeKey === null) {\n      return null;\n    }\n    return flattenNodes.find(({\n      key\n    }) => key === activeKey) || null;\n  };\n  offsetActiveKey = offset => {\n    const {\n      flattenNodes,\n      activeKey\n    } = this.state;\n    let index = flattenNodes.findIndex(({\n      key\n    }) => key === activeKey);\n\n    // Align with index\n    if (index === -1 && offset < 0) {\n      index = flattenNodes.length;\n    }\n    index = (index + offset + flattenNodes.length) % flattenNodes.length;\n    const item = flattenNodes[index];\n    if (item) {\n      const {\n        key\n      } = item;\n      this.onActiveChange(key);\n    } else {\n      this.onActiveChange(null);\n    }\n  };\n  onKeyDown = event => {\n    const {\n      activeKey,\n      expandedKeys,\n      checkedKeys,\n      fieldNames\n    } = this.state;\n    const {\n      onKeyDown,\n      checkable,\n      selectable\n    } = this.props;\n\n    // >>>>>>>>>> Direction\n    switch (event.which) {\n      case KeyCode.UP:\n        {\n          this.offsetActiveKey(-1);\n          event.preventDefault();\n          break;\n        }\n      case KeyCode.DOWN:\n        {\n          this.offsetActiveKey(1);\n          event.preventDefault();\n          break;\n        }\n    }\n\n    // >>>>>>>>>> Expand & Selection\n    const activeItem = this.getActiveItem();\n    if (activeItem && activeItem.data) {\n      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n      const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;\n      const eventNode = convertNodePropsToEventData({\n        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),\n        data: activeItem.data,\n        active: true\n      });\n      switch (event.which) {\n        // >>> Expand\n        case KeyCode.LEFT:\n          {\n            // Collapse if possible\n            if (expandable && expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.parent) {\n              this.onActiveChange(activeItem.parent.key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            // Expand if possible\n            if (expandable && !expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.children && activeItem.children.length) {\n              this.onActiveChange(activeItem.children[0].key);\n            }\n            event.preventDefault();\n            break;\n          }\n\n        // Selection\n        case KeyCode.ENTER:\n        case KeyCode.SPACE:\n          {\n            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {\n              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n      }\n    }\n    onKeyDown?.(event);\n  };\n\n  /**\n   * Only update the value which is not in props\n   */\n  setUncontrolledState = (state, atomic = false, forceState = null) => {\n    if (!this.destroyed) {\n      let needSync = false;\n      let allPassed = true;\n      const newState = {};\n      Object.keys(state).forEach(name => {\n        if (this.props.hasOwnProperty(name)) {\n          allPassed = false;\n          return;\n        }\n        needSync = true;\n        newState[name] = state[name];\n      });\n      if (needSync && (!atomic || allPassed)) {\n        this.setState({\n          ...newState,\n          ...forceState\n        });\n      }\n    }\n  };\n  scrollTo = scroll => {\n    this.listRef.current.scrollTo(scroll);\n  };\n  render() {\n    const {\n      focused,\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      activeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [`${prefixCls}-show-line`]: showLine,\n        [`${prefixCls}-focused`]: focused,\n        [`${prefixCls}-active-focused`]: activeKey !== null\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      focused: focused,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\nexport default Tree;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","KeyCode","pickAttrs","warning","React","TreeContext","DropIndicator","NodeList","MOTION_KEY","MotionEntity","TreeNode","arrAdd","arrDel","calcDropPosition","calcSelectedKeys","conductExpandParent","getDragChildrenKeys","parseCheckedKeys","posToArr","conductCheck","getEntity","convertDataToEntities","convertNodePropsToEventData","convertTreeToData","fillFieldNames","flattenTreeData","getTreeNodeProps","warningWithoutKey","MAX_RETRY_TIMES","Tree","Component","defaultProps","prefixCls","showLine","showIcon","selectable","multiple","checkable","disabled","checkStrictly","draggable","defaultExpandParent","autoExpandParent","defaultExpandAll","defaultExpandedKeys","defaultCheckedKeys","defaultSelectedKeys","dropIndicatorRender","allowDrop","expandAction","destroyed","delayedDragEnterLogic","loadingRetryTimes","state","keyEntities","indent","selectedKeys","checkedKeys","halfCheckedKeys","loadedKeys","loadingKeys","expandedKeys","draggingNodeKey","dragChildrenKeys","dropTargetKey","dropPosition","dropContainerKey","dropLevelOffset","dropTargetPos","dropAllowed","dragOverNodeKey","treeData","flattenNodes","focused","activeKey","listChanging","prevProps","fieldNames","dragStartMousePosition","dragNodeProps","currentMouseOverDroppableNodeKey","listRef","createRef","componentDidMount","onUpdated","componentDidUpdate","itemScrollOffset","props","undefined","setState","scrollTo","offset","componentWillUnmount","window","removeEventListener","onWindowDragEnd","getDerivedStateFromProps","prevState","newState","needSync","name","children","entitiesMap","process","env","NODE_ENV","cloneKeyEntities","nextExpandedKeys","keys","forEach","entity","push","checkedKeyEntity","conductKeys","onNodeDragStart","event","nodeProps","onDragStart","eventKey","x","clientX","y","clientY","newExpandedKeys","current","getIndentWidth","setExpandedKeys","addEventListener","node","onNodeDragEnter","onDragEnter","onExpand","direction","pos","resetDragState","includes","clearTimeout","persist","setTimeout","expanded","nativeEvent","onNodeDragOver","onDragOver","onNodeDragLeave","currentTarget","contains","relatedTarget","onDragLeave","onNodeDragEnd","onDragEnd","cleanDragState","onNodeDrop","_","outsideTree","onDrop","abstractDropNodeProps","getTreeNodeRequiredProps","active","getActiveItem","data","dropToChild","posArr","dropResult","dragNode","dragNodesKeys","concat","dropToGap","Number","triggerExpandActionExpand","e","treeNode","isLeaf","shiftKey","metaKey","ctrlKey","filter","nodeItem","eventNode","onNodeExpand","onNodeClick","onClick","onNodeDoubleClick","onDoubleClick","onNodeSelect","onSelect","selected","targetSelected","selectedNodes","map","selectedKey","Boolean","setUncontrolledState","onNodeCheck","checked","oriCheckedKeys","oriHalfCheckedKeys","onCheck","checkedObj","eventObj","halfChecked","checkedNodes","checkedKey","keySet","Set","delete","Array","from","checkedNodesPositions","onNodeLoad","loadPromise","Promise","resolve","reject","loadData","onLoad","promise","then","currentLoadedKeys","newLoadedKeys","catch","onNodeMouseEnter","onMouseEnter","onNodeMouseLeave","onMouseLeave","onNodeContextMenu","onRightClick","preventDefault","onFocus","args","onBlur","onActiveChange","certain","targetExpanded","newFlattenTreeData","currentExpandedKeys","expandedKeysToRestore","onListChangeStart","onListChangeEnd","newActiveKey","find","offsetActiveKey","index","findIndex","item","onKeyDown","which","UP","DOWN","activeItem","treeNodeRequiredProps","expandable","LEFT","parent","RIGHT","ENTER","SPACE","disableCheckbox","atomic","forceState","allPassed","scroll","render","className","style","styles","classNames","treeClassNames","focusable","tabIndex","icon","switcherIcon","motion","filterTreeNode","height","itemHeight","scrollWidth","virtual","titleRender","onContextMenu","onScroll","rootClassName","rootStyle","domProps","aria","draggableConfig","nodeDraggable","contextValue","createElement","Provider","value","ref","dragging"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/tree/es/Tree.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n// TODO: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/treeview/treeview-2/treeview-2a.html\n// Fully accessibility support\n\nimport { clsx } from 'clsx';\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  static defaultProps = {\n    prefixCls: 'rc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true,\n    expandAction: false\n  };\n  static TreeNode = TreeNode;\n  destroyed = false;\n  delayedDragEnterLogic;\n  loadingRetryTimes = {};\n  state = {\n    keyEntities: {},\n    indent: null,\n    selectedKeys: [],\n    checkedKeys: [],\n    halfCheckedKeys: [],\n    loadedKeys: [],\n    loadingKeys: [],\n    expandedKeys: [],\n    draggingNodeKey: null,\n    dragChildrenKeys: [],\n    // dropTargetKey is the key of abstract-drop-node\n    // the abstract-drop-node is the real drop node when drag and drop\n    // not the DOM drag over node\n    dropTargetKey: null,\n    dropPosition: null,\n    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n    dropContainerKey: null,\n    // the container key of abstract-drop-node if dropPosition is -1 or 1\n    dropLevelOffset: null,\n    // the drop level offset of abstract-drag-over-node\n    dropTargetPos: null,\n    // the pos of abstract-drop-node\n    dropAllowed: true,\n    // if drop to abstract-drop-node is allowed\n    // the abstract-drag-over-node\n    // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n    // abstract-drag-over-node is the top node\n    dragOverNodeKey: null,\n    treeData: [],\n    flattenNodes: [],\n    focused: false,\n    activeKey: null,\n    listChanging: false,\n    prevProps: null,\n    fieldNames: fillFieldNames()\n  };\n  dragStartMousePosition = null;\n  dragNodeProps = null;\n  currentMouseOverDroppableNodeKey = null;\n  listRef = /*#__PURE__*/React.createRef();\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = {\n        [MOTION_KEY]: MotionEntity,\n        ...entitiesMap.keyEntities\n      };\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = {\n        ...keyEntities\n      };\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  onNodeDragStart = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities\n    } = this.state;\n    const {\n      onDragStart\n    } = this.props;\n    const {\n      eventKey\n    } = nodeProps;\n    this.dragNodeProps = nodeProps;\n    this.dragStartMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const newExpandedKeys = arrDel(expandedKeys, eventKey);\n    this.setState({\n      draggingNodeKey: eventKey,\n      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n      indent: this.listRef.current.getIndentWidth()\n    });\n    this.setExpandedKeys(newExpandedKeys);\n    window.addEventListener('dragend', this.onWindowDragEnd);\n    onDragStart?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  /**\n   * [Legacy] Select handler is smaller than node,\n   * so that this will trigger when drag enter node or select handler.\n   * This is a little tricky if customize css without padding.\n   * Better for use mouse move event to refresh drag state.\n   * But let's just keep it to avoid event trigger logic change.\n   */\n  onNodeDragEnter = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities,\n      dragChildrenKeys,\n      flattenNodes,\n      indent\n    } = this.state;\n    const {\n      onDragEnter,\n      onExpand,\n      allowDrop,\n      direction\n    } = this.props;\n    const {\n      pos,\n      eventKey\n    } = nodeProps;\n\n    // record the key of node which is latest entered, used in dragleave event.\n    if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n      this.currentMouseOverDroppableNodeKey = eventKey;\n    }\n    if (!this.dragNodeProps) {\n      this.resetDragState();\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (\n    // don't allow drop inside its children\n    dragChildrenKeys.includes(dropTargetKey) ||\n    // don't allow drop when drop is not allowed caculated by calcDropPosition\n    !dropAllowed) {\n      this.resetDragState();\n      return;\n    }\n\n    // Side effect for delay drag\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(key => {\n      clearTimeout(this.delayedDragEnterLogic[key]);\n    });\n    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n      // hoist expand logic here\n      // since if logic is on the bottom\n      // it will be blocked by abstract dragover node check\n      //   => if you dragenter from top, you mouse will still be consider as in the top node\n      event.persist();\n      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n        if (this.state.draggingNodeKey === null) {\n          return;\n        }\n        let newExpandedKeys = [...expandedKeys];\n        const entity = getEntity(keyEntities, nodeProps.eventKey);\n        if (entity && (entity.children || []).length) {\n          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n        }\n        if (!this.props.hasOwnProperty('expandedKeys')) {\n          this.setExpandedKeys(newExpandedKeys);\n        }\n        onExpand?.(newExpandedKeys, {\n          node: convertNodePropsToEventData(nodeProps),\n          expanded: true,\n          nativeEvent: event.nativeEvent\n        });\n      }, 800);\n    }\n\n    // Skip if drag node is self\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      this.resetDragState();\n      return;\n    }\n\n    // Update drag over node and drag state\n    this.setState({\n      dragOverNodeKey,\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed\n    });\n    onDragEnter?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps),\n      expandedKeys\n    });\n  };\n  onNodeDragOver = (event, nodeProps) => {\n    const {\n      dragChildrenKeys,\n      flattenNodes,\n      keyEntities,\n      expandedKeys,\n      indent\n    } = this.state;\n    const {\n      onDragOver,\n      allowDrop,\n      direction\n    } = this.props;\n    if (!this.dragNodeProps) {\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n      // don't allow drop inside its children\n      // don't allow drop when drop is not allowed calculated by calcDropPosition\n      return;\n    }\n\n    // Update drag position\n\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n        this.resetDragState();\n      }\n    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n      this.setState({\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      });\n    }\n    onDragOver?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n  onNodeDragLeave = (event, nodeProps) => {\n    // if it is outside the droppable area\n    // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n      this.resetDragState();\n      this.currentMouseOverDroppableNodeKey = null;\n    }\n    const {\n      onDragLeave\n    } = this.props;\n    onDragLeave?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  // since stopPropagation() is called in treeNode\n  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n  onWindowDragEnd = event => {\n    this.onNodeDragEnd(event, null, true);\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n\n  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n  onNodeDragEnd = (event, nodeProps) => {\n    const {\n      onDragEnd\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    onDragEnd?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n    this.dragNodeProps = null;\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n  onNodeDrop = (event, _, outsideTree = false) => {\n    const {\n      dragChildrenKeys,\n      dropPosition,\n      dropTargetKey,\n      dropTargetPos,\n      dropAllowed\n    } = this.state;\n    if (!dropAllowed) {\n      return;\n    }\n    const {\n      onDrop\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    if (dropTargetKey === null) return;\n    const abstractDropNodeProps = {\n      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),\n      active: this.getActiveItem()?.key === dropTargetKey,\n      data: getEntity(this.state.keyEntities, dropTargetKey).node\n    };\n    const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n    warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n    const posArr = posToArr(dropTargetPos);\n    const dropResult = {\n      event,\n      node: convertNodePropsToEventData(abstractDropNodeProps),\n      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,\n      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n      dropToGap: dropPosition !== 0,\n      dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (!outsideTree) {\n      onDrop?.(dropResult);\n    }\n    this.dragNodeProps = null;\n  };\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  cleanDragState = () => {\n    const {\n      draggingNodeKey\n    } = this.state;\n    if (draggingNodeKey !== null) {\n      this.setState({\n        draggingNodeKey: null,\n        dropPosition: null,\n        dropContainerKey: null,\n        dropTargetKey: null,\n        dropLevelOffset: null,\n        dropAllowed: true,\n        dragOverNodeKey: null\n      });\n    }\n    this.dragStartMousePosition = null;\n    this.currentMouseOverDroppableNodeKey = null;\n  };\n  triggerExpandActionExpand = (e, treeNode) => {\n    const {\n      expandedKeys,\n      flattenNodes\n    } = this.state;\n    const {\n      expanded,\n      key,\n      isLeaf\n    } = treeNode;\n    if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n    const eventNode = convertNodePropsToEventData({\n      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),\n      data: node.data\n    });\n    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n    this.onNodeExpand(e, eventNode);\n  };\n  onNodeClick = (e, treeNode) => {\n    const {\n      onClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'click') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onClick?.(e, treeNode);\n  };\n  onNodeDoubleClick = (e, treeNode) => {\n    const {\n      onDoubleClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'doubleClick') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onDoubleClick?.(e, treeNode);\n  };\n  onNodeSelect = (e, treeNode) => {\n    let {\n      selectedKeys\n    } = this.state;\n    const {\n      keyEntities,\n      fieldNames\n    } = this.state;\n    const {\n      onSelect,\n      multiple\n    } = this.props;\n    const {\n      selected\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n    const targetSelected = !selected;\n\n    // Update selected keys\n    if (!targetSelected) {\n      selectedKeys = arrDel(selectedKeys, key);\n    } else if (!multiple) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = arrAdd(selectedKeys, key);\n    }\n\n    // [Legacy] Not found related usage in doc or upper libs\n    const selectedNodes = selectedKeys.map(selectedKey => {\n      const entity = getEntity(keyEntities, selectedKey);\n      return entity ? entity.node : null;\n    }).filter(Boolean);\n    this.setUncontrolledState({\n      selectedKeys\n    });\n    onSelect?.(selectedKeys, {\n      event: 'select',\n      selected: targetSelected,\n      node: treeNode,\n      selectedNodes,\n      nativeEvent: e.nativeEvent\n    });\n  };\n  onNodeCheck = (e, treeNode, checked) => {\n    const {\n      keyEntities,\n      checkedKeys: oriCheckedKeys,\n      halfCheckedKeys: oriHalfCheckedKeys\n    } = this.state;\n    const {\n      checkStrictly,\n      onCheck\n    } = this.props;\n    const {\n      key\n    } = treeNode;\n\n    // Prepare trigger arguments\n    let checkedObj;\n    const eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked,\n      nativeEvent: e.nativeEvent\n    };\n    if (checkStrictly) {\n      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n      checkedObj = {\n        checked: checkedKeys,\n        halfChecked: halfCheckedKeys\n      };\n      eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n      this.setUncontrolledState({\n        checkedKeys\n      });\n    } else {\n      // Always fill first\n      let {\n        checkedKeys,\n        halfCheckedKeys\n      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n      // If remove, we do it again to correction\n      if (!checked) {\n        const keySet = new Set(checkedKeys);\n        keySet.delete(key);\n        ({\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck(Array.from(keySet), {\n          checked: false,\n          halfCheckedKeys\n        }, keyEntities));\n      }\n      checkedObj = checkedKeys;\n\n      // [Legacy] This is used for `rc-tree-select`\n      eventObj.checkedNodes = [];\n      eventObj.checkedNodesPositions = [];\n      eventObj.halfCheckedKeys = halfCheckedKeys;\n      checkedKeys.forEach(checkedKey => {\n        const entity = getEntity(keyEntities, checkedKey);\n        if (!entity) return;\n        const {\n          node,\n          pos\n        } = entity;\n        eventObj.checkedNodes.push(node);\n        eventObj.checkedNodesPositions.push({\n          node,\n          pos\n        });\n      });\n      this.setUncontrolledState({\n        checkedKeys\n      }, false, {\n        halfCheckedKeys\n      });\n    }\n    onCheck?.(checkedObj, eventObj);\n  };\n  onNodeLoad = treeNode => {\n    const {\n      key\n    } = treeNode;\n    const {\n      keyEntities\n    } = this.state;\n\n    // Skip if has children already\n    const entity = getEntity(keyEntities, key);\n    if (entity?.children?.length) {\n      return;\n    }\n    const loadPromise = new Promise((resolve, reject) => {\n      // We need to get the latest state of loading/loaded keys\n      this.setState(({\n        loadedKeys = [],\n        loadingKeys = []\n      }) => {\n        const {\n          loadData,\n          onLoad\n        } = this.props;\n        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n          return null;\n        }\n\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const {\n            loadedKeys: currentLoadedKeys\n          } = this.state;\n          const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          onLoad?.(newLoadedKeys, {\n            event: 'load',\n            node: treeNode\n          });\n          this.setUncontrolledState({\n            loadedKeys: newLoadedKeys\n          });\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n          resolve();\n        }).catch(e => {\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n\n          // If exceed max retry times, we give up retry\n          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            this.setUncontrolledState({\n              loadedKeys: arrAdd(currentLoadedKeys, key)\n            });\n            resolve();\n          }\n          reject(e);\n        });\n        return {\n          loadingKeys: arrAdd(loadingKeys, key)\n        };\n      });\n    });\n\n    // Not care warning if we ignore this\n    loadPromise.catch(() => {});\n    return loadPromise;\n  };\n  onNodeMouseEnter = (event, node) => {\n    const {\n      onMouseEnter\n    } = this.props;\n    onMouseEnter?.({\n      event,\n      node\n    });\n  };\n  onNodeMouseLeave = (event, node) => {\n    const {\n      onMouseLeave\n    } = this.props;\n    onMouseLeave?.({\n      event,\n      node\n    });\n  };\n  onNodeContextMenu = (event, node) => {\n    const {\n      onRightClick\n    } = this.props;\n    if (onRightClick) {\n      event.preventDefault();\n      onRightClick({\n        event,\n        node\n      });\n    }\n  };\n  onFocus = (...args) => {\n    const {\n      onFocus\n    } = this.props;\n    this.setState({\n      focused: true\n    });\n    onFocus?.(...args);\n  };\n  onBlur = (...args) => {\n    const {\n      onBlur\n    } = this.props;\n    this.setState({\n      focused: false\n    });\n    this.onActiveChange(null);\n    onBlur?.(...args);\n  };\n  getTreeNodeRequiredProps = () => {\n    const {\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities\n    } = this.state;\n    return {\n      expandedKeys: expandedKeys || [],\n      selectedKeys: selectedKeys || [],\n      loadedKeys: loadedKeys || [],\n      loadingKeys: loadingKeys || [],\n      checkedKeys: checkedKeys || [],\n      halfCheckedKeys: halfCheckedKeys || [],\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities: keyEntities\n    };\n  };\n\n  // =========================== Expanded ===========================\n  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n  setExpandedKeys = expandedKeys => {\n    const {\n      treeData,\n      fieldNames\n    } = this.state;\n    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n    this.setUncontrolledState({\n      expandedKeys,\n      flattenNodes\n    }, true);\n  };\n  onNodeExpand = (e, treeNode) => {\n    let {\n      expandedKeys\n    } = this.state;\n    const {\n      listChanging,\n      fieldNames\n    } = this.state;\n    const {\n      onExpand,\n      loadData\n    } = this.props;\n    const {\n      expanded\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n\n    // Do nothing when motion is in progress\n    if (listChanging) {\n      return;\n    }\n\n    // Update selected keys\n    const certain = expandedKeys.includes(key);\n    const targetExpanded = !expanded;\n    warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n    this.setExpandedKeys(expandedKeys);\n    onExpand?.(expandedKeys, {\n      node: treeNode,\n      expanded: targetExpanded,\n      nativeEvent: e.nativeEvent\n    });\n\n    // Async Load data\n    if (targetExpanded && loadData) {\n      const loadPromise = this.onNodeLoad(treeNode);\n      if (loadPromise) {\n        loadPromise.then(() => {\n          // [Legacy] Refresh logic\n          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n          this.setUncontrolledState({\n            flattenNodes: newFlattenTreeData\n          });\n        }).catch(() => {\n          const {\n            expandedKeys: currentExpandedKeys\n          } = this.state;\n          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n          this.setExpandedKeys(expandedKeysToRestore);\n        });\n      }\n    }\n  };\n  onListChangeStart = () => {\n    this.setUncontrolledState({\n      listChanging: true\n    });\n  };\n  onListChangeEnd = () => {\n    setTimeout(() => {\n      this.setUncontrolledState({\n        listChanging: false\n      });\n    });\n  };\n\n  // =========================== Keyboard ===========================\n  onActiveChange = newActiveKey => {\n    const {\n      activeKey\n    } = this.state;\n    const {\n      onActiveChange,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey === newActiveKey) {\n      return;\n    }\n    this.setState({\n      activeKey: newActiveKey\n    });\n    if (newActiveKey !== null) {\n      this.scrollTo({\n        key: newActiveKey,\n        offset: itemScrollOffset\n      });\n    }\n    onActiveChange?.(newActiveKey);\n  };\n  getActiveItem = () => {\n    const {\n      activeKey,\n      flattenNodes\n    } = this.state;\n    if (activeKey === null) {\n      return null;\n    }\n    return flattenNodes.find(({\n      key\n    }) => key === activeKey) || null;\n  };\n  offsetActiveKey = offset => {\n    const {\n      flattenNodes,\n      activeKey\n    } = this.state;\n    let index = flattenNodes.findIndex(({\n      key\n    }) => key === activeKey);\n\n    // Align with index\n    if (index === -1 && offset < 0) {\n      index = flattenNodes.length;\n    }\n    index = (index + offset + flattenNodes.length) % flattenNodes.length;\n    const item = flattenNodes[index];\n    if (item) {\n      const {\n        key\n      } = item;\n      this.onActiveChange(key);\n    } else {\n      this.onActiveChange(null);\n    }\n  };\n  onKeyDown = event => {\n    const {\n      activeKey,\n      expandedKeys,\n      checkedKeys,\n      fieldNames\n    } = this.state;\n    const {\n      onKeyDown,\n      checkable,\n      selectable\n    } = this.props;\n\n    // >>>>>>>>>> Direction\n    switch (event.which) {\n      case KeyCode.UP:\n        {\n          this.offsetActiveKey(-1);\n          event.preventDefault();\n          break;\n        }\n      case KeyCode.DOWN:\n        {\n          this.offsetActiveKey(1);\n          event.preventDefault();\n          break;\n        }\n    }\n\n    // >>>>>>>>>> Expand & Selection\n    const activeItem = this.getActiveItem();\n    if (activeItem && activeItem.data) {\n      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n      const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;\n      const eventNode = convertNodePropsToEventData({\n        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),\n        data: activeItem.data,\n        active: true\n      });\n      switch (event.which) {\n        // >>> Expand\n        case KeyCode.LEFT:\n          {\n            // Collapse if possible\n            if (expandable && expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.parent) {\n              this.onActiveChange(activeItem.parent.key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            // Expand if possible\n            if (expandable && !expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.children && activeItem.children.length) {\n              this.onActiveChange(activeItem.children[0].key);\n            }\n            event.preventDefault();\n            break;\n          }\n\n        // Selection\n        case KeyCode.ENTER:\n        case KeyCode.SPACE:\n          {\n            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {\n              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n      }\n    }\n    onKeyDown?.(event);\n  };\n\n  /**\n   * Only update the value which is not in props\n   */\n  setUncontrolledState = (state, atomic = false, forceState = null) => {\n    if (!this.destroyed) {\n      let needSync = false;\n      let allPassed = true;\n      const newState = {};\n      Object.keys(state).forEach(name => {\n        if (this.props.hasOwnProperty(name)) {\n          allPassed = false;\n          return;\n        }\n        needSync = true;\n        newState[name] = state[name];\n      });\n      if (needSync && (!atomic || allPassed)) {\n        this.setState({\n          ...newState,\n          ...forceState\n        });\n      }\n    }\n  };\n  scrollTo = scroll => {\n    this.listRef.current.scrollTo(scroll);\n  };\n  render() {\n    const {\n      focused,\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      activeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [`${prefixCls}-show-line`]: showLine,\n        [`${prefixCls}-focused`]: focused,\n        [`${prefixCls}-active-focused`]: activeKey !== null\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      focused: focused,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\nexport default Tree;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}