{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport * as React from 'react';\nimport useForm from \"./useForm\";\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport FormContext from \"./FormContext\";\nimport { isSimilar } from \"./utils/valueUtil\";\nimport ListContext from \"./ListContext\";\nimport BatchUpdate from \"./BatchUpdate\";\nconst Form = ({\n  name,\n  initialValues,\n  fields,\n  form,\n  preserve,\n  children,\n  component: Component = 'form',\n  validateMessages,\n  validateTrigger = 'onChange',\n  onValuesChange,\n  onFieldsChange,\n  onFinish,\n  onFinishFailed,\n  clearOnDestroy,\n  ...restProps\n}, ref) => {\n  const nativeElementRef = React.useRef(null);\n  const formContext = React.useContext(FormContext);\n\n  // We customize handle event since Context will makes all the consumer re-render:\n  // https://reactjs.org/docs/context.html#contextprovider\n  const [formInstance] = useForm(form);\n  const {\n    useSubscribe,\n    setInitialValues,\n    setCallbacks,\n    setValidateMessages,\n    setPreserve,\n    destroyForm,\n    setBatchUpdate\n  } = formInstance.getInternalHooks(HOOK_MARK);\n\n  // Pass ref with form instance\n  React.useImperativeHandle(ref, () => ({\n    ...formInstance,\n    nativeElement: nativeElementRef.current\n  }));\n\n  // Register form into Context\n  React.useEffect(() => {\n    formContext.registerForm(name, formInstance);\n    return () => {\n      formContext.unregisterForm(name);\n    };\n  }, [formContext, formInstance, name]);\n\n  // Pass props to store\n  setValidateMessages({\n    ...formContext.validateMessages,\n    ...validateMessages\n  });\n  setCallbacks({\n    onValuesChange,\n    onFieldsChange: (changedFields, ...rest) => {\n      formContext.triggerFormChange(name, changedFields);\n      if (onFieldsChange) {\n        onFieldsChange(changedFields, ...rest);\n      }\n    },\n    onFinish: values => {\n      formContext.triggerFormFinish(name, values);\n      if (onFinish) {\n        onFinish(values);\n      }\n    },\n    onFinishFailed\n  });\n  setPreserve(preserve);\n\n  // Set initial value, init store value when first mount\n  const mountRef = React.useRef(null);\n  setInitialValues(initialValues, !mountRef.current);\n  if (!mountRef.current) {\n    mountRef.current = true;\n  }\n\n  // ======================== Batch Update ========================\n  // zombieJ:\n  // To avoid Form self re-render,\n  // We create a sub component `BatchUpdate` to handle batch update logic.\n  // When the call with do not change immediate, we will batch the update\n  // and flush it in `useLayoutEffect` for next tick.\n\n  // Set batch update ref\n  const batchUpdateRef = React.useRef(null);\n  const batchUpdateTasksRef = React.useRef([]);\n  const tryFlushBatch = () => {\n    if (batchUpdateRef.current) {\n      batchUpdateTasksRef.current.forEach(([key, fn]) => {\n        batchUpdateRef.current.batch(key, fn);\n      });\n      batchUpdateTasksRef.current = [];\n    }\n  };\n\n  // Ref update\n  const setBatchUpdateRef = React.useCallback(batchUpdate => {\n    batchUpdateRef.current = batchUpdate;\n    tryFlushBatch();\n  }, []);\n\n  // Task list\n\n  const batchUpdate = (key, callback) => {\n    batchUpdateTasksRef.current.push([key, callback]);\n    tryFlushBatch();\n  };\n  setBatchUpdate(batchUpdate);\n\n  // ========================== Unmount ===========================\n  React.useEffect(() => () => destroyForm(clearOnDestroy),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n\n  // Prepare children by `children` type\n  let childrenNode;\n  const childrenRenderProps = typeof children === 'function';\n  if (childrenRenderProps) {\n    const values = formInstance.getFieldsValue(true);\n    childrenNode = children(values, formInstance);\n  } else {\n    childrenNode = children;\n  }\n\n  // Not use subscribe when using render props\n  useSubscribe(!childrenRenderProps);\n\n  // Listen if fields provided. We use ref to save prev data here to avoid additional render\n  const prevFieldsRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {\n      formInstance.setFields(fields || []);\n    }\n    prevFieldsRef.current = fields;\n  }, [fields, formInstance]);\n\n  // =========================== Render ===========================\n  const formContextValue = React.useMemo(() => ({\n    ...formInstance,\n    validateTrigger\n  }), [formInstance, validateTrigger]);\n  const wrapperNode = /*#__PURE__*/React.createElement(ListContext.Provider, {\n    value: null\n  }, /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: formContextValue\n  }, childrenNode), /*#__PURE__*/React.createElement(BatchUpdate, {\n    ref: setBatchUpdateRef\n  }));\n  if (Component === false) {\n    return wrapperNode;\n  }\n  return /*#__PURE__*/React.createElement(Component, _extends({}, restProps, {\n    ref: nativeElementRef,\n    onSubmit: event => {\n      event.preventDefault();\n      event.stopPropagation();\n      formInstance.submit();\n    },\n    onReset: event => {\n      event.preventDefault();\n      formInstance.resetFields();\n      restProps.onReset?.(event);\n    }\n  }), wrapperNode);\n};\nexport default Form;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","React","useForm","FieldContext","HOOK_MARK","FormContext","isSimilar","ListContext","BatchUpdate","Form","name","initialValues","fields","form","preserve","children","component","Component","validateMessages","validateTrigger","onValuesChange","onFieldsChange","onFinish","onFinishFailed","clearOnDestroy","restProps","ref","nativeElementRef","useRef","formContext","useContext","formInstance","useSubscribe","setInitialValues","setCallbacks","setValidateMessages","setPreserve","destroyForm","setBatchUpdate","getInternalHooks","useImperativeHandle","nativeElement","current","useEffect","registerForm","unregisterForm","changedFields","rest","triggerFormChange","values","triggerFormFinish","mountRef","batchUpdateRef","batchUpdateTasksRef","tryFlushBatch","forEach","fn","batch","setBatchUpdateRef","useCallback","batchUpdate","callback","push","childrenNode","childrenRenderProps","getFieldsValue","prevFieldsRef","setFields","formContextValue","useMemo","wrapperNode","createElement","Provider","value","onSubmit","event","preventDefault","stopPropagation","submit","onReset","resetFields"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/form/es/Form.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport * as React from 'react';\nimport useForm from \"./useForm\";\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport FormContext from \"./FormContext\";\nimport { isSimilar } from \"./utils/valueUtil\";\nimport ListContext from \"./ListContext\";\nimport BatchUpdate from \"./BatchUpdate\";\nconst Form = ({\n  name,\n  initialValues,\n  fields,\n  form,\n  preserve,\n  children,\n  component: Component = 'form',\n  validateMessages,\n  validateTrigger = 'onChange',\n  onValuesChange,\n  onFieldsChange,\n  onFinish,\n  onFinishFailed,\n  clearOnDestroy,\n  ...restProps\n}, ref) => {\n  const nativeElementRef = React.useRef(null);\n  const formContext = React.useContext(FormContext);\n\n  // We customize handle event since Context will makes all the consumer re-render:\n  // https://reactjs.org/docs/context.html#contextprovider\n  const [formInstance] = useForm(form);\n  const {\n    useSubscribe,\n    setInitialValues,\n    setCallbacks,\n    setValidateMessages,\n    setPreserve,\n    destroyForm,\n    setBatchUpdate\n  } = formInstance.getInternalHooks(HOOK_MARK);\n\n  // Pass ref with form instance\n  React.useImperativeHandle(ref, () => ({\n    ...formInstance,\n    nativeElement: nativeElementRef.current\n  }));\n\n  // Register form into Context\n  React.useEffect(() => {\n    formContext.registerForm(name, formInstance);\n    return () => {\n      formContext.unregisterForm(name);\n    };\n  }, [formContext, formInstance, name]);\n\n  // Pass props to store\n  setValidateMessages({\n    ...formContext.validateMessages,\n    ...validateMessages\n  });\n  setCallbacks({\n    onValuesChange,\n    onFieldsChange: (changedFields, ...rest) => {\n      formContext.triggerFormChange(name, changedFields);\n      if (onFieldsChange) {\n        onFieldsChange(changedFields, ...rest);\n      }\n    },\n    onFinish: values => {\n      formContext.triggerFormFinish(name, values);\n      if (onFinish) {\n        onFinish(values);\n      }\n    },\n    onFinishFailed\n  });\n  setPreserve(preserve);\n\n  // Set initial value, init store value when first mount\n  const mountRef = React.useRef(null);\n  setInitialValues(initialValues, !mountRef.current);\n  if (!mountRef.current) {\n    mountRef.current = true;\n  }\n\n  // ======================== Batch Update ========================\n  // zombieJ:\n  // To avoid Form self re-render,\n  // We create a sub component `BatchUpdate` to handle batch update logic.\n  // When the call with do not change immediate, we will batch the update\n  // and flush it in `useLayoutEffect` for next tick.\n\n  // Set batch update ref\n  const batchUpdateRef = React.useRef(null);\n  const batchUpdateTasksRef = React.useRef([]);\n  const tryFlushBatch = () => {\n    if (batchUpdateRef.current) {\n      batchUpdateTasksRef.current.forEach(([key, fn]) => {\n        batchUpdateRef.current.batch(key, fn);\n      });\n      batchUpdateTasksRef.current = [];\n    }\n  };\n\n  // Ref update\n  const setBatchUpdateRef = React.useCallback(batchUpdate => {\n    batchUpdateRef.current = batchUpdate;\n    tryFlushBatch();\n  }, []);\n\n  // Task list\n\n  const batchUpdate = (key, callback) => {\n    batchUpdateTasksRef.current.push([key, callback]);\n    tryFlushBatch();\n  };\n  setBatchUpdate(batchUpdate);\n\n  // ========================== Unmount ===========================\n  React.useEffect(() => () => destroyForm(clearOnDestroy),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n\n  // Prepare children by `children` type\n  let childrenNode;\n  const childrenRenderProps = typeof children === 'function';\n  if (childrenRenderProps) {\n    const values = formInstance.getFieldsValue(true);\n    childrenNode = children(values, formInstance);\n  } else {\n    childrenNode = children;\n  }\n\n  // Not use subscribe when using render props\n  useSubscribe(!childrenRenderProps);\n\n  // Listen if fields provided. We use ref to save prev data here to avoid additional render\n  const prevFieldsRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {\n      formInstance.setFields(fields || []);\n    }\n    prevFieldsRef.current = fields;\n  }, [fields, formInstance]);\n\n  // =========================== Render ===========================\n  const formContextValue = React.useMemo(() => ({\n    ...formInstance,\n    validateTrigger\n  }), [formInstance, validateTrigger]);\n  const wrapperNode = /*#__PURE__*/React.createElement(ListContext.Provider, {\n    value: null\n  }, /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: formContextValue\n  }, childrenNode), /*#__PURE__*/React.createElement(BatchUpdate, {\n    ref: setBatchUpdateRef\n  }));\n  if (Component === false) {\n    return wrapperNode;\n  }\n  return /*#__PURE__*/React.createElement(Component, _extends({}, restProps, {\n    ref: nativeElementRef,\n    onSubmit: event => {\n      event.preventDefault();\n      event.stopPropagation();\n      formInstance.submit();\n    },\n    onReset: event => {\n      event.preventDefault();\n      formInstance.resetFields();\n      restProps.onReset?.(event);\n    }\n  }), wrapperNode);\n};\nexport default Form;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}