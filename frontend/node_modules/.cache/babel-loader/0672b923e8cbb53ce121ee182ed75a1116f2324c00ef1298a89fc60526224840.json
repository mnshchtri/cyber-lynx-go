{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { clsx } from 'clsx';\nimport Overflow from 'rc-overflow';\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { useImperativeHandle } from 'react';\nimport { flushSync } from 'react-dom';\nimport { IdContext } from \"./context/IdContext\";\nimport MenuContextProvider from \"./context/MenuContext\";\nimport { PathRegisterContext, PathUserContext } from \"./context/PathContext\";\nimport PrivateContext from \"./context/PrivateContext\";\nimport { getFocusableElements, refreshElements, useAccessibility } from \"./hooks/useAccessibility\";\nimport useKeyRecords, { OVERFLOW_KEY } from \"./hooks/useKeyRecords\";\nimport useMemoCallback from \"./hooks/useMemoCallback\";\nimport MenuItem from \"./MenuItem\";\nimport SubMenu from \"./SubMenu\";\nimport { parseItems } from \"./utils/nodeUtil\";\nimport { warnItemProp } from \"./utils/warnUtil\";\n\n/**\n * Menu modify after refactor:\n * ## Add\n * - disabled\n *\n * ## Remove\n * - openTransitionName\n * - openAnimation\n * - onDestroy\n * - siderCollapsed: Seems antd do not use this prop (Need test in antd)\n * - collapsedWidth: Seems this logic should be handle by antd Layout.Sider\n */\n\n// optimize for render\nconst EMPTY_LIST = [];\nconst Menu = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    prefixCls = 'rc-menu',\n    rootClassName,\n    style,\n    className,\n    styles,\n    classNames: menuClassNames,\n    tabIndex = 0,\n    items,\n    children,\n    direction,\n    id,\n    // Mode\n    mode = 'vertical',\n    inlineCollapsed,\n    // Disabled\n    disabled,\n    disabledOverflow,\n    // Open\n    subMenuOpenDelay = 0.1,\n    subMenuCloseDelay = 0.1,\n    forceSubMenuRender,\n    defaultOpenKeys,\n    openKeys,\n    // Active\n    activeKey,\n    defaultActiveFirst,\n    // Selection\n    selectable = true,\n    multiple = false,\n    defaultSelectedKeys,\n    selectedKeys,\n    onSelect,\n    onDeselect,\n    // Level\n    inlineIndent = 24,\n    // Motion\n    motion,\n    defaultMotions,\n    // Popup\n    triggerSubMenuAction = 'hover',\n    builtinPlacements,\n    // Icon\n    itemIcon,\n    expandIcon,\n    overflowedIndicator = '...',\n    overflowedIndicatorPopupClassName,\n    // Function\n    getPopupContainer,\n    // Events\n    onClick,\n    onOpenChange,\n    onKeyDown,\n    // Deprecated\n    openAnimation,\n    openTransitionName,\n    // Internal\n    _internalRenderMenuItem,\n    _internalRenderSubMenuItem,\n    _internalComponents,\n    popupRender,\n    ...restProps\n  } = props;\n  const [childList, measureChildList] = React.useMemo(() => [parseItems(children, items, EMPTY_LIST, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST, {}, prefixCls)], [children, items, _internalComponents]);\n  const [mounted, setMounted] = React.useState(false);\n  const containerRef = React.useRef();\n  const uuid = useId(id ? `rc-menu-uuid-${id}` : 'rc-menu-uuid');\n  const isRtl = direction === 'rtl';\n\n  // ========================= Warn =========================\n  if (process.env.NODE_ENV !== 'production') {\n    warning(!openAnimation && !openTransitionName, '`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.');\n  }\n\n  // ========================= Open =========================\n  const [innerOpenKeys, setMergedOpenKeys] = useControlledState(defaultOpenKeys, openKeys);\n  const mergedOpenKeys = innerOpenKeys || EMPTY_LIST;\n\n  // React 18 will merge mouse event which means we open key will not sync\n  // ref: https://github.com/ant-design/ant-design/issues/38818\n  const triggerOpenKeys = (keys, forceFlush = false) => {\n    function doUpdate() {\n      setMergedOpenKeys(keys);\n      onOpenChange?.(keys);\n    }\n    if (forceFlush) {\n      flushSync(doUpdate);\n    } else {\n      doUpdate();\n    }\n  };\n\n  // >>>>> Cache & Reset open keys when inlineCollapsed changed\n  const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = React.useState(mergedOpenKeys);\n  const mountRef = React.useRef(false);\n\n  // ========================= Mode =========================\n  const [mergedMode, mergedInlineCollapsed] = React.useMemo(() => {\n    if ((mode === 'inline' || mode === 'vertical') && inlineCollapsed) {\n      return ['vertical', inlineCollapsed];\n    }\n    return [mode, false];\n  }, [mode, inlineCollapsed]);\n  const isInlineMode = mergedMode === 'inline';\n  const [internalMode, setInternalMode] = React.useState(mergedMode);\n  const [internalInlineCollapsed, setInternalInlineCollapsed] = React.useState(mergedInlineCollapsed);\n  React.useEffect(() => {\n    setInternalMode(mergedMode);\n    setInternalInlineCollapsed(mergedInlineCollapsed);\n    if (!mountRef.current) {\n      return;\n    }\n    // Synchronously update MergedOpenKeys\n    if (isInlineMode) {\n      setMergedOpenKeys(inlineCacheOpenKeys);\n    } else {\n      // Trigger open event in case its in control\n      triggerOpenKeys(EMPTY_LIST);\n    }\n  }, [mergedMode, mergedInlineCollapsed]);\n\n  // ====================== Responsive ======================\n  const [lastVisibleIndex, setLastVisibleIndex] = React.useState(0);\n  const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== 'horizontal' || disabledOverflow;\n\n  // Cache\n  React.useEffect(() => {\n    if (isInlineMode) {\n      setInlineCacheOpenKeys(mergedOpenKeys);\n    }\n  }, [mergedOpenKeys]);\n  React.useEffect(() => {\n    mountRef.current = true;\n    return () => {\n      mountRef.current = false;\n    };\n  }, []);\n\n  // ========================= Path =========================\n  const {\n    registerPath,\n    unregisterPath,\n    refreshOverflowKeys,\n    isSubPathKey,\n    getKeyPath,\n    getKeys,\n    getSubPathKeys\n  } = useKeyRecords();\n  const registerPathContext = React.useMemo(() => ({\n    registerPath,\n    unregisterPath\n  }), [registerPath, unregisterPath]);\n  const pathUserContext = React.useMemo(() => ({\n    isSubPathKey\n  }), [isSubPathKey]);\n  React.useEffect(() => {\n    refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map(child => child.key));\n  }, [lastVisibleIndex, allVisible]);\n\n  // ======================== Active ========================\n  const [mergedActiveKey, setMergedActiveKey] = useControlledState(activeKey || defaultActiveFirst && childList[0]?.key, activeKey);\n  const onActive = useMemoCallback(key => {\n    setMergedActiveKey(key);\n  });\n  const onInactive = useMemoCallback(() => {\n    setMergedActiveKey(undefined);\n  });\n  useImperativeHandle(ref, () => {\n    return {\n      list: containerRef.current,\n      focus: options => {\n        const keys = getKeys();\n        const {\n          elements,\n          key2element,\n          element2key\n        } = refreshElements(keys, uuid);\n        const focusableElements = getFocusableElements(containerRef.current, elements);\n        let shouldFocusKey;\n        if (mergedActiveKey && keys.includes(mergedActiveKey)) {\n          shouldFocusKey = mergedActiveKey;\n        } else {\n          shouldFocusKey = focusableElements[0] ? element2key.get(focusableElements[0]) : childList.find(node => !node.props.disabled)?.key;\n        }\n        const elementToFocus = key2element.get(shouldFocusKey);\n        if (shouldFocusKey && elementToFocus) {\n          elementToFocus?.focus?.(options);\n        }\n      },\n      findItem: ({\n        key: itemKey\n      }) => {\n        const keys = getKeys();\n        const {\n          key2element\n        } = refreshElements(keys, uuid);\n        return key2element.get(itemKey) || null;\n      }\n    };\n  });\n\n  // ======================== Select ========================\n  // >>>>> Select keys\n  const [internalSelectKeys, setMergedSelectKeys] = useControlledState(defaultSelectedKeys || [], selectedKeys);\n  const mergedSelectKeys = React.useMemo(() => {\n    if (Array.isArray(internalSelectKeys)) {\n      return internalSelectKeys;\n    }\n    if (internalSelectKeys === null || internalSelectKeys === undefined) {\n      return EMPTY_LIST;\n    }\n    return [internalSelectKeys];\n  }, [internalSelectKeys]);\n\n  // >>>>> Trigger select\n  const triggerSelection = info => {\n    if (selectable) {\n      // Insert or Remove\n      const {\n        key: targetKey\n      } = info;\n      const exist = mergedSelectKeys.includes(targetKey);\n      let newSelectKeys;\n      if (multiple) {\n        if (exist) {\n          newSelectKeys = mergedSelectKeys.filter(key => key !== targetKey);\n        } else {\n          newSelectKeys = [...mergedSelectKeys, targetKey];\n        }\n      } else {\n        newSelectKeys = [targetKey];\n      }\n      setMergedSelectKeys(newSelectKeys);\n\n      // Trigger event\n      const selectInfo = {\n        ...info,\n        selectedKeys: newSelectKeys\n      };\n      if (exist) {\n        onDeselect?.(selectInfo);\n      } else {\n        onSelect?.(selectInfo);\n      }\n    }\n\n    // Whatever selectable, always close it\n    if (!multiple && mergedOpenKeys.length && internalMode !== 'inline') {\n      triggerOpenKeys(EMPTY_LIST);\n    }\n  };\n\n  // ========================= Open =========================\n  /**\n   * Click for item. SubMenu do not have selection status\n   */\n  const onInternalClick = useMemoCallback(info => {\n    onClick?.(warnItemProp(info));\n    triggerSelection(info);\n  });\n  const onInternalOpenChange = useMemoCallback((key, open) => {\n    let newOpenKeys = mergedOpenKeys.filter(k => k !== key);\n    if (open) {\n      newOpenKeys.push(key);\n    } else if (internalMode !== 'inline') {\n      // We need find all related popup to close\n      const subPathKeys = getSubPathKeys(key);\n      newOpenKeys = newOpenKeys.filter(k => !subPathKeys.has(k));\n    }\n    if (!isEqual(mergedOpenKeys, newOpenKeys, true)) {\n      triggerOpenKeys(newOpenKeys, true);\n    }\n  });\n\n  // ==================== Accessibility =====================\n  const triggerAccessibilityOpen = (key, open) => {\n    const nextOpen = open ?? !mergedOpenKeys.includes(key);\n    onInternalOpenChange(key, nextOpen);\n  };\n  const onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);\n\n  // ======================== Effect ========================\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // ======================= Context ========================\n  const privateContext = React.useMemo(() => ({\n    _internalRenderMenuItem,\n    _internalRenderSubMenuItem\n  }), [_internalRenderMenuItem, _internalRenderSubMenuItem]);\n\n  // ======================== Render ========================\n\n  // >>>>> Children\n  const wrappedChildList = internalMode !== 'horizontal' || disabledOverflow ? childList :\n  // Need wrap for overflow dropdown that do not response for open\n  childList.map((child, index) => /*#__PURE__*/\n  // Always wrap provider to avoid sub node re-mount\n  React.createElement(MenuContextProvider, {\n    key: child.key,\n    overflowDisabled: index > lastVisibleIndex,\n    classNames: menuClassNames,\n    styles: styles\n  }, child));\n\n  // >>>>> Container\n  const container = /*#__PURE__*/React.createElement(Overflow, _extends({\n    id: id,\n    ref: containerRef,\n    prefixCls: `${prefixCls}-overflow`,\n    component: \"ul\",\n    itemComponent: MenuItem,\n    className: clsx(prefixCls, `${prefixCls}-root`, `${prefixCls}-${internalMode}`, className, {\n      [`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,\n      [`${prefixCls}-rtl`]: isRtl\n    }, rootClassName),\n    dir: direction,\n    style: style,\n    role: \"menu\",\n    tabIndex: tabIndex,\n    data: wrappedChildList,\n    renderRawItem: node => node,\n    renderRawRest: omitItems => {\n      // We use origin list since wrapped list use context to prevent open\n      const len = omitItems.length;\n      const originOmitItems = len ? childList.slice(-len) : null;\n      return /*#__PURE__*/React.createElement(SubMenu, {\n        eventKey: OVERFLOW_KEY,\n        title: overflowedIndicator,\n        disabled: allVisible,\n        internalPopupClose: len === 0,\n        popupClassName: overflowedIndicatorPopupClassName\n      }, originOmitItems);\n    },\n    maxCount: internalMode !== 'horizontal' || disabledOverflow ? Overflow.INVALIDATE : Overflow.RESPONSIVE,\n    ssr: \"full\",\n    \"data-menu-list\": true,\n    onVisibleChange: newLastIndex => {\n      setLastVisibleIndex(newLastIndex);\n    },\n    onKeyDown: onInternalKeyDown\n  }, restProps));\n\n  // >>>>> Render\n  return /*#__PURE__*/React.createElement(PrivateContext.Provider, {\n    value: privateContext\n  }, /*#__PURE__*/React.createElement(IdContext.Provider, {\n    value: uuid\n  }, /*#__PURE__*/React.createElement(MenuContextProvider, {\n    prefixCls: prefixCls,\n    rootClassName: rootClassName,\n    classNames: menuClassNames,\n    styles: styles,\n    mode: internalMode,\n    openKeys: mergedOpenKeys,\n    rtl: isRtl\n    // Disabled\n    ,\n\n    disabled: disabled\n    // Motion\n    ,\n\n    motion: mounted ? motion : null,\n    defaultMotions: mounted ? defaultMotions : null\n    // Active\n    ,\n\n    activeKey: mergedActiveKey,\n    onActive: onActive,\n    onInactive: onInactive\n    // Selection\n    ,\n\n    selectedKeys: mergedSelectKeys\n    // Level\n    ,\n\n    inlineIndent: inlineIndent\n    // Popup\n    ,\n\n    subMenuOpenDelay: subMenuOpenDelay,\n    subMenuCloseDelay: subMenuCloseDelay,\n    forceSubMenuRender: forceSubMenuRender,\n    builtinPlacements: builtinPlacements,\n    triggerSubMenuAction: triggerSubMenuAction,\n    getPopupContainer: getPopupContainer\n    // Icon\n    ,\n\n    itemIcon: itemIcon,\n    expandIcon: expandIcon\n    // Events\n    ,\n\n    onItemClick: onInternalClick,\n    onOpenChange: onInternalOpenChange,\n    popupRender: popupRender\n  }, /*#__PURE__*/React.createElement(PathUserContext.Provider, {\n    value: pathUserContext\n  }, container), /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none'\n    },\n    \"aria-hidden\": true\n  }, /*#__PURE__*/React.createElement(PathRegisterContext.Provider, {\n    value: registerPathContext\n  }, measureChildList)))));\n});\nexport default Menu;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","Overflow","useControlledState","useId","isEqual","warning","React","useImperativeHandle","flushSync","IdContext","MenuContextProvider","PathRegisterContext","PathUserContext","PrivateContext","getFocusableElements","refreshElements","useAccessibility","useKeyRecords","OVERFLOW_KEY","useMemoCallback","MenuItem","SubMenu","parseItems","warnItemProp","EMPTY_LIST","Menu","forwardRef","props","ref","prefixCls","rootClassName","style","className","styles","classNames","menuClassNames","tabIndex","items","children","direction","id","mode","inlineCollapsed","disabled","disabledOverflow","subMenuOpenDelay","subMenuCloseDelay","forceSubMenuRender","defaultOpenKeys","openKeys","activeKey","defaultActiveFirst","selectable","multiple","defaultSelectedKeys","selectedKeys","onSelect","onDeselect","inlineIndent","motion","defaultMotions","triggerSubMenuAction","builtinPlacements","itemIcon","expandIcon","overflowedIndicator","overflowedIndicatorPopupClassName","getPopupContainer","onClick","onOpenChange","onKeyDown","openAnimation","openTransitionName","_internalRenderMenuItem","_internalRenderSubMenuItem","_internalComponents","popupRender","restProps","childList","measureChildList","useMemo","mounted","setMounted","useState","containerRef","useRef","uuid","isRtl","process","env","NODE_ENV","innerOpenKeys","setMergedOpenKeys","mergedOpenKeys","triggerOpenKeys","keys","forceFlush","doUpdate","inlineCacheOpenKeys","setInlineCacheOpenKeys","mountRef","mergedMode","mergedInlineCollapsed","isInlineMode","internalMode","setInternalMode","internalInlineCollapsed","setInternalInlineCollapsed","useEffect","current","lastVisibleIndex","setLastVisibleIndex","allVisible","registerPath","unregisterPath","refreshOverflowKeys","isSubPathKey","getKeyPath","getKeys","getSubPathKeys","registerPathContext","pathUserContext","slice","map","child","mergedActiveKey","setMergedActiveKey","onActive","onInactive","undefined","list","focus","options","elements","key2element","element2key","focusableElements","shouldFocusKey","includes","get","find","node","elementToFocus","findItem","itemKey","internalSelectKeys","setMergedSelectKeys","mergedSelectKeys","Array","isArray","triggerSelection","info","targetKey","exist","newSelectKeys","filter","selectInfo","onInternalClick","onInternalOpenChange","open","newOpenKeys","k","push","subPathKeys","has","triggerAccessibilityOpen","nextOpen","onInternalKeyDown","privateContext","wrappedChildList","index","createElement","overflowDisabled","container","component","itemComponent","dir","role","data","renderRawItem","renderRawRest","omitItems","len","originOmitItems","eventKey","title","internalPopupClose","popupClassName","maxCount","INVALIDATE","RESPONSIVE","ssr","onVisibleChange","newLastIndex","Provider","value","rtl","onItemClick","display"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/menu/es/Menu.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport { clsx } from 'clsx';\nimport Overflow from 'rc-overflow';\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { useImperativeHandle } from 'react';\nimport { flushSync } from 'react-dom';\nimport { IdContext } from \"./context/IdContext\";\nimport MenuContextProvider from \"./context/MenuContext\";\nimport { PathRegisterContext, PathUserContext } from \"./context/PathContext\";\nimport PrivateContext from \"./context/PrivateContext\";\nimport { getFocusableElements, refreshElements, useAccessibility } from \"./hooks/useAccessibility\";\nimport useKeyRecords, { OVERFLOW_KEY } from \"./hooks/useKeyRecords\";\nimport useMemoCallback from \"./hooks/useMemoCallback\";\nimport MenuItem from \"./MenuItem\";\nimport SubMenu from \"./SubMenu\";\nimport { parseItems } from \"./utils/nodeUtil\";\nimport { warnItemProp } from \"./utils/warnUtil\";\n\n/**\n * Menu modify after refactor:\n * ## Add\n * - disabled\n *\n * ## Remove\n * - openTransitionName\n * - openAnimation\n * - onDestroy\n * - siderCollapsed: Seems antd do not use this prop (Need test in antd)\n * - collapsedWidth: Seems this logic should be handle by antd Layout.Sider\n */\n\n// optimize for render\nconst EMPTY_LIST = [];\nconst Menu = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    prefixCls = 'rc-menu',\n    rootClassName,\n    style,\n    className,\n    styles,\n    classNames: menuClassNames,\n    tabIndex = 0,\n    items,\n    children,\n    direction,\n    id,\n    // Mode\n    mode = 'vertical',\n    inlineCollapsed,\n    // Disabled\n    disabled,\n    disabledOverflow,\n    // Open\n    subMenuOpenDelay = 0.1,\n    subMenuCloseDelay = 0.1,\n    forceSubMenuRender,\n    defaultOpenKeys,\n    openKeys,\n    // Active\n    activeKey,\n    defaultActiveFirst,\n    // Selection\n    selectable = true,\n    multiple = false,\n    defaultSelectedKeys,\n    selectedKeys,\n    onSelect,\n    onDeselect,\n    // Level\n    inlineIndent = 24,\n    // Motion\n    motion,\n    defaultMotions,\n    // Popup\n    triggerSubMenuAction = 'hover',\n    builtinPlacements,\n    // Icon\n    itemIcon,\n    expandIcon,\n    overflowedIndicator = '...',\n    overflowedIndicatorPopupClassName,\n    // Function\n    getPopupContainer,\n    // Events\n    onClick,\n    onOpenChange,\n    onKeyDown,\n    // Deprecated\n    openAnimation,\n    openTransitionName,\n    // Internal\n    _internalRenderMenuItem,\n    _internalRenderSubMenuItem,\n    _internalComponents,\n    popupRender,\n    ...restProps\n  } = props;\n  const [childList, measureChildList] = React.useMemo(() => [parseItems(children, items, EMPTY_LIST, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST, {}, prefixCls)], [children, items, _internalComponents]);\n  const [mounted, setMounted] = React.useState(false);\n  const containerRef = React.useRef();\n  const uuid = useId(id ? `rc-menu-uuid-${id}` : 'rc-menu-uuid');\n  const isRtl = direction === 'rtl';\n\n  // ========================= Warn =========================\n  if (process.env.NODE_ENV !== 'production') {\n    warning(!openAnimation && !openTransitionName, '`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.');\n  }\n\n  // ========================= Open =========================\n  const [innerOpenKeys, setMergedOpenKeys] = useControlledState(defaultOpenKeys, openKeys);\n  const mergedOpenKeys = innerOpenKeys || EMPTY_LIST;\n\n  // React 18 will merge mouse event which means we open key will not sync\n  // ref: https://github.com/ant-design/ant-design/issues/38818\n  const triggerOpenKeys = (keys, forceFlush = false) => {\n    function doUpdate() {\n      setMergedOpenKeys(keys);\n      onOpenChange?.(keys);\n    }\n    if (forceFlush) {\n      flushSync(doUpdate);\n    } else {\n      doUpdate();\n    }\n  };\n\n  // >>>>> Cache & Reset open keys when inlineCollapsed changed\n  const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = React.useState(mergedOpenKeys);\n  const mountRef = React.useRef(false);\n\n  // ========================= Mode =========================\n  const [mergedMode, mergedInlineCollapsed] = React.useMemo(() => {\n    if ((mode === 'inline' || mode === 'vertical') && inlineCollapsed) {\n      return ['vertical', inlineCollapsed];\n    }\n    return [mode, false];\n  }, [mode, inlineCollapsed]);\n  const isInlineMode = mergedMode === 'inline';\n  const [internalMode, setInternalMode] = React.useState(mergedMode);\n  const [internalInlineCollapsed, setInternalInlineCollapsed] = React.useState(mergedInlineCollapsed);\n  React.useEffect(() => {\n    setInternalMode(mergedMode);\n    setInternalInlineCollapsed(mergedInlineCollapsed);\n    if (!mountRef.current) {\n      return;\n    }\n    // Synchronously update MergedOpenKeys\n    if (isInlineMode) {\n      setMergedOpenKeys(inlineCacheOpenKeys);\n    } else {\n      // Trigger open event in case its in control\n      triggerOpenKeys(EMPTY_LIST);\n    }\n  }, [mergedMode, mergedInlineCollapsed]);\n\n  // ====================== Responsive ======================\n  const [lastVisibleIndex, setLastVisibleIndex] = React.useState(0);\n  const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== 'horizontal' || disabledOverflow;\n\n  // Cache\n  React.useEffect(() => {\n    if (isInlineMode) {\n      setInlineCacheOpenKeys(mergedOpenKeys);\n    }\n  }, [mergedOpenKeys]);\n  React.useEffect(() => {\n    mountRef.current = true;\n    return () => {\n      mountRef.current = false;\n    };\n  }, []);\n\n  // ========================= Path =========================\n  const {\n    registerPath,\n    unregisterPath,\n    refreshOverflowKeys,\n    isSubPathKey,\n    getKeyPath,\n    getKeys,\n    getSubPathKeys\n  } = useKeyRecords();\n  const registerPathContext = React.useMemo(() => ({\n    registerPath,\n    unregisterPath\n  }), [registerPath, unregisterPath]);\n  const pathUserContext = React.useMemo(() => ({\n    isSubPathKey\n  }), [isSubPathKey]);\n  React.useEffect(() => {\n    refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map(child => child.key));\n  }, [lastVisibleIndex, allVisible]);\n\n  // ======================== Active ========================\n  const [mergedActiveKey, setMergedActiveKey] = useControlledState(activeKey || defaultActiveFirst && childList[0]?.key, activeKey);\n  const onActive = useMemoCallback(key => {\n    setMergedActiveKey(key);\n  });\n  const onInactive = useMemoCallback(() => {\n    setMergedActiveKey(undefined);\n  });\n  useImperativeHandle(ref, () => {\n    return {\n      list: containerRef.current,\n      focus: options => {\n        const keys = getKeys();\n        const {\n          elements,\n          key2element,\n          element2key\n        } = refreshElements(keys, uuid);\n        const focusableElements = getFocusableElements(containerRef.current, elements);\n        let shouldFocusKey;\n        if (mergedActiveKey && keys.includes(mergedActiveKey)) {\n          shouldFocusKey = mergedActiveKey;\n        } else {\n          shouldFocusKey = focusableElements[0] ? element2key.get(focusableElements[0]) : childList.find(node => !node.props.disabled)?.key;\n        }\n        const elementToFocus = key2element.get(shouldFocusKey);\n        if (shouldFocusKey && elementToFocus) {\n          elementToFocus?.focus?.(options);\n        }\n      },\n      findItem: ({\n        key: itemKey\n      }) => {\n        const keys = getKeys();\n        const {\n          key2element\n        } = refreshElements(keys, uuid);\n        return key2element.get(itemKey) || null;\n      }\n    };\n  });\n\n  // ======================== Select ========================\n  // >>>>> Select keys\n  const [internalSelectKeys, setMergedSelectKeys] = useControlledState(defaultSelectedKeys || [], selectedKeys);\n  const mergedSelectKeys = React.useMemo(() => {\n    if (Array.isArray(internalSelectKeys)) {\n      return internalSelectKeys;\n    }\n    if (internalSelectKeys === null || internalSelectKeys === undefined) {\n      return EMPTY_LIST;\n    }\n    return [internalSelectKeys];\n  }, [internalSelectKeys]);\n\n  // >>>>> Trigger select\n  const triggerSelection = info => {\n    if (selectable) {\n      // Insert or Remove\n      const {\n        key: targetKey\n      } = info;\n      const exist = mergedSelectKeys.includes(targetKey);\n      let newSelectKeys;\n      if (multiple) {\n        if (exist) {\n          newSelectKeys = mergedSelectKeys.filter(key => key !== targetKey);\n        } else {\n          newSelectKeys = [...mergedSelectKeys, targetKey];\n        }\n      } else {\n        newSelectKeys = [targetKey];\n      }\n      setMergedSelectKeys(newSelectKeys);\n\n      // Trigger event\n      const selectInfo = {\n        ...info,\n        selectedKeys: newSelectKeys\n      };\n      if (exist) {\n        onDeselect?.(selectInfo);\n      } else {\n        onSelect?.(selectInfo);\n      }\n    }\n\n    // Whatever selectable, always close it\n    if (!multiple && mergedOpenKeys.length && internalMode !== 'inline') {\n      triggerOpenKeys(EMPTY_LIST);\n    }\n  };\n\n  // ========================= Open =========================\n  /**\n   * Click for item. SubMenu do not have selection status\n   */\n  const onInternalClick = useMemoCallback(info => {\n    onClick?.(warnItemProp(info));\n    triggerSelection(info);\n  });\n  const onInternalOpenChange = useMemoCallback((key, open) => {\n    let newOpenKeys = mergedOpenKeys.filter(k => k !== key);\n    if (open) {\n      newOpenKeys.push(key);\n    } else if (internalMode !== 'inline') {\n      // We need find all related popup to close\n      const subPathKeys = getSubPathKeys(key);\n      newOpenKeys = newOpenKeys.filter(k => !subPathKeys.has(k));\n    }\n    if (!isEqual(mergedOpenKeys, newOpenKeys, true)) {\n      triggerOpenKeys(newOpenKeys, true);\n    }\n  });\n\n  // ==================== Accessibility =====================\n  const triggerAccessibilityOpen = (key, open) => {\n    const nextOpen = open ?? !mergedOpenKeys.includes(key);\n    onInternalOpenChange(key, nextOpen);\n  };\n  const onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);\n\n  // ======================== Effect ========================\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  // ======================= Context ========================\n  const privateContext = React.useMemo(() => ({\n    _internalRenderMenuItem,\n    _internalRenderSubMenuItem\n  }), [_internalRenderMenuItem, _internalRenderSubMenuItem]);\n\n  // ======================== Render ========================\n\n  // >>>>> Children\n  const wrappedChildList = internalMode !== 'horizontal' || disabledOverflow ? childList :\n  // Need wrap for overflow dropdown that do not response for open\n  childList.map((child, index) =>\n  /*#__PURE__*/\n  // Always wrap provider to avoid sub node re-mount\n  React.createElement(MenuContextProvider, {\n    key: child.key,\n    overflowDisabled: index > lastVisibleIndex,\n    classNames: menuClassNames,\n    styles: styles\n  }, child));\n\n  // >>>>> Container\n  const container = /*#__PURE__*/React.createElement(Overflow, _extends({\n    id: id,\n    ref: containerRef,\n    prefixCls: `${prefixCls}-overflow`,\n    component: \"ul\",\n    itemComponent: MenuItem,\n    className: clsx(prefixCls, `${prefixCls}-root`, `${prefixCls}-${internalMode}`, className, {\n      [`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,\n      [`${prefixCls}-rtl`]: isRtl\n    }, rootClassName),\n    dir: direction,\n    style: style,\n    role: \"menu\",\n    tabIndex: tabIndex,\n    data: wrappedChildList,\n    renderRawItem: node => node,\n    renderRawRest: omitItems => {\n      // We use origin list since wrapped list use context to prevent open\n      const len = omitItems.length;\n      const originOmitItems = len ? childList.slice(-len) : null;\n      return /*#__PURE__*/React.createElement(SubMenu, {\n        eventKey: OVERFLOW_KEY,\n        title: overflowedIndicator,\n        disabled: allVisible,\n        internalPopupClose: len === 0,\n        popupClassName: overflowedIndicatorPopupClassName\n      }, originOmitItems);\n    },\n    maxCount: internalMode !== 'horizontal' || disabledOverflow ? Overflow.INVALIDATE : Overflow.RESPONSIVE,\n    ssr: \"full\",\n    \"data-menu-list\": true,\n    onVisibleChange: newLastIndex => {\n      setLastVisibleIndex(newLastIndex);\n    },\n    onKeyDown: onInternalKeyDown\n  }, restProps));\n\n  // >>>>> Render\n  return /*#__PURE__*/React.createElement(PrivateContext.Provider, {\n    value: privateContext\n  }, /*#__PURE__*/React.createElement(IdContext.Provider, {\n    value: uuid\n  }, /*#__PURE__*/React.createElement(MenuContextProvider, {\n    prefixCls: prefixCls,\n    rootClassName: rootClassName,\n    classNames: menuClassNames,\n    styles: styles,\n    mode: internalMode,\n    openKeys: mergedOpenKeys,\n    rtl: isRtl\n    // Disabled\n    ,\n    disabled: disabled\n    // Motion\n    ,\n    motion: mounted ? motion : null,\n    defaultMotions: mounted ? defaultMotions : null\n    // Active\n    ,\n    activeKey: mergedActiveKey,\n    onActive: onActive,\n    onInactive: onInactive\n    // Selection\n    ,\n    selectedKeys: mergedSelectKeys\n    // Level\n    ,\n    inlineIndent: inlineIndent\n    // Popup\n    ,\n    subMenuOpenDelay: subMenuOpenDelay,\n    subMenuCloseDelay: subMenuCloseDelay,\n    forceSubMenuRender: forceSubMenuRender,\n    builtinPlacements: builtinPlacements,\n    triggerSubMenuAction: triggerSubMenuAction,\n    getPopupContainer: getPopupContainer\n    // Icon\n    ,\n    itemIcon: itemIcon,\n    expandIcon: expandIcon\n    // Events\n    ,\n    onItemClick: onInternalClick,\n    onOpenChange: onInternalOpenChange,\n    popupRender: popupRender\n  }, /*#__PURE__*/React.createElement(PathUserContext.Provider, {\n    value: pathUserContext\n  }, container), /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none'\n    },\n    \"aria-hidden\": true\n  }, /*#__PURE__*/React.createElement(PathRegisterContext.Provider, {\n    value: registerPathContext\n  }, measureChildList)))));\n});\nexport default Menu;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}