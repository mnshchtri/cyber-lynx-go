{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { clsx } from 'clsx';\nimport ResizeObserver from '@rc-component/resize-observer';\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport { useComposeRef } from \"@rc-component/util/es/ref\";\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport TabContext from \"../TabContext\";\nimport useIndicator from \"../hooks/useIndicator\";\nimport useOffsets from \"../hooks/useOffsets\";\nimport useSyncState from \"../hooks/useSyncState\";\nimport useTouchMove from \"../hooks/useTouchMove\";\nimport useUpdate, { useUpdateState } from \"../hooks/useUpdate\";\nimport useVisibleRange from \"../hooks/useVisibleRange\";\nimport { genDataNodeKey, getRemovable, stringify } from \"../util\";\nimport AddButton from \"./AddButton\";\nimport ExtraContent from \"./ExtraContent\";\nimport OperationNode from \"./OperationNode\";\nimport TabNode from \"./TabNode\";\nconst getTabSize = (tab, containerRect) => {\n  // tabListRef\n  const {\n    offsetWidth,\n    offsetHeight,\n    offsetTop,\n    offsetLeft\n  } = tab;\n  const {\n    width,\n    height,\n    left,\n    top\n  } = tab.getBoundingClientRect();\n\n  // Use getBoundingClientRect to avoid decimal inaccuracy\n  if (Math.abs(width - offsetWidth) < 1) {\n    return [width, height, left - containerRect.left, top - containerRect.top];\n  }\n  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];\n};\nconst getSize = refObj => {\n  const {\n    offsetWidth = 0,\n    offsetHeight = 0\n  } = refObj.current || {};\n\n  // Use getBoundingClientRect to avoid decimal inaccuracy\n  if (refObj.current) {\n    const {\n      width,\n      height\n    } = refObj.current.getBoundingClientRect();\n    if (Math.abs(width - offsetWidth) < 1) {\n      return [width, height];\n    }\n  }\n  return [offsetWidth, offsetHeight];\n};\n\n/**\n * Convert `SizeInfo` to unit value. Such as [123, 456] with `top` position get `123`\n */\nconst getUnitValue = (size, tabPositionTopOrBottom) => {\n  return size[tabPositionTopOrBottom ? 0 : 1];\n};\nconst TabNavList = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    className,\n    style,\n    id,\n    animated,\n    activeKey,\n    rtl,\n    extra,\n    editable,\n    locale,\n    tabPosition,\n    tabBarGutter,\n    children,\n    onTabClick,\n    onTabScroll,\n    indicator,\n    classNames: tabsClassNames,\n    styles\n  } = props;\n  const {\n    prefixCls,\n    tabs\n  } = React.useContext(TabContext);\n  const containerRef = useRef(null);\n  const extraLeftRef = useRef(null);\n  const extraRightRef = useRef(null);\n  const tabsWrapperRef = useRef(null);\n  const tabListRef = useRef(null);\n  const operationsRef = useRef(null);\n  const innerAddButtonRef = useRef(null);\n  const tabPositionTopOrBottom = tabPosition === 'top' || tabPosition === 'bottom';\n  const [transformLeft, setTransformLeft] = useSyncState(0, (next, prev) => {\n    if (tabPositionTopOrBottom && onTabScroll) {\n      onTabScroll({\n        direction: next > prev ? 'left' : 'right'\n      });\n    }\n  });\n  const [transformTop, setTransformTop] = useSyncState(0, (next, prev) => {\n    if (!tabPositionTopOrBottom && onTabScroll) {\n      onTabScroll({\n        direction: next > prev ? 'top' : 'bottom'\n      });\n    }\n  });\n  const [containerExcludeExtraSize, setContainerExcludeExtraSize] = useState([0, 0]);\n  const [tabContentSize, setTabContentSize] = useState([0, 0]);\n  const [addSize, setAddSize] = useState([0, 0]);\n  const [operationSize, setOperationSize] = useState([0, 0]);\n  const [tabSizes, setTabSizes] = useUpdateState(new Map());\n  const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);\n\n  // ========================== Unit =========================\n  const containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);\n  const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);\n  const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);\n  const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);\n  const needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);\n  const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;\n\n  // ========================== Util =========================\n  const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;\n  let transformMin = 0;\n  let transformMax = 0;\n  if (!tabPositionTopOrBottom) {\n    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);\n    transformMax = 0;\n  } else if (rtl) {\n    transformMin = 0;\n    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);\n  } else {\n    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);\n    transformMax = 0;\n  }\n  function alignInRange(value) {\n    if (value < transformMin) {\n      return transformMin;\n    }\n    if (value > transformMax) {\n      return transformMax;\n    }\n    return value;\n  }\n\n  // ========================= Mobile ========================\n  const touchMovingRef = useRef(null);\n  const [lockAnimation, setLockAnimation] = useState();\n  function doLockAnimation() {\n    setLockAnimation(Date.now());\n  }\n  function clearTouchMoving() {\n    if (touchMovingRef.current) {\n      clearTimeout(touchMovingRef.current);\n    }\n  }\n  useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {\n    function doMove(setState, offset) {\n      setState(value => {\n        const newValue = alignInRange(value + offset);\n        return newValue;\n      });\n    }\n\n    // Skip scroll if place is enough\n    if (!needScroll) {\n      return false;\n    }\n    if (tabPositionTopOrBottom) {\n      doMove(setTransformLeft, offsetX);\n    } else {\n      doMove(setTransformTop, offsetY);\n    }\n    clearTouchMoving();\n    doLockAnimation();\n    return true;\n  });\n  useEffect(() => {\n    clearTouchMoving();\n    if (lockAnimation) {\n      touchMovingRef.current = setTimeout(() => {\n        setLockAnimation(0);\n      }, 100);\n    }\n    return clearTouchMoving;\n  }, [lockAnimation]);\n\n  // ===================== Visible Range =====================\n  // Render tab node & collect tab offset\n  const [visibleStart, visibleEnd] = useVisibleRange(tabOffsets,\n  // Container\n  visibleTabContentValue,\n  // Transform\n  tabPositionTopOrBottom ? transformLeft : transformTop,\n  // Tabs\n  tabContentSizeValue,\n  // Add\n  addSizeValue,\n  // Operation\n  operationSizeValue, {\n    ...props,\n    tabs\n  });\n\n  // ========================= Scroll ========================\n  const scrollToTab = useEvent((key = activeKey) => {\n    const tabOffset = tabOffsets.get(key) || {\n      width: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0\n    };\n    if (tabPositionTopOrBottom) {\n      // ============ Align with top & bottom ============\n      let newTransform = transformLeft;\n\n      // RTL\n      if (rtl) {\n        if (tabOffset.right < transformLeft) {\n          newTransform = tabOffset.right;\n        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {\n          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;\n        }\n      }\n      // LTR\n      else if (tabOffset.left < -transformLeft) {\n        newTransform = -tabOffset.left;\n      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {\n        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);\n      }\n      setTransformTop(0);\n      setTransformLeft(alignInRange(newTransform));\n    } else {\n      // ============ Align with left & right ============\n      let newTransform = transformTop;\n      if (tabOffset.top < -transformTop) {\n        newTransform = -tabOffset.top;\n      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {\n        newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);\n      }\n      setTransformLeft(0);\n      setTransformTop(alignInRange(newTransform));\n    }\n  });\n\n  // ========================= Focus =========================\n  const [focusKey, setFocusKey] = useState();\n  const [isMouse, setIsMouse] = useState(false);\n  const enabledTabs = tabs.filter(tab => !tab.disabled).map(tab => tab.key);\n  const onOffset = offset => {\n    const currentIndex = enabledTabs.indexOf(focusKey || activeKey);\n    const len = enabledTabs.length;\n    const nextIndex = (currentIndex + offset + len) % len;\n    const newKey = enabledTabs[nextIndex];\n    setFocusKey(newKey);\n  };\n  const handleRemoveTab = (removalTabKey, e) => {\n    const removeIndex = enabledTabs.indexOf(removalTabKey);\n    const removeTab = tabs.find(tab => tab.key === removalTabKey);\n    const removable = getRemovable(removeTab?.closable, removeTab?.closeIcon, editable, removeTab?.disabled);\n    if (removable) {\n      e.preventDefault();\n      e.stopPropagation();\n      editable.onEdit('remove', {\n        key: removalTabKey,\n        event: e\n      });\n\n      // when remove last tab, focus previous tab\n      if (removeIndex === enabledTabs.length - 1) {\n        onOffset(-1);\n      } else {\n        onOffset(1);\n      }\n    }\n  };\n  const handleMouseDown = (key, e) => {\n    setIsMouse(true);\n    // Middle mouse button\n    if (e.button === 1) {\n      handleRemoveTab(key, e);\n    }\n  };\n  const handleKeyDown = e => {\n    const {\n      code\n    } = e;\n    const isRTL = rtl && tabPositionTopOrBottom;\n    const firstEnabledTab = enabledTabs[0];\n    const lastEnabledTab = enabledTabs[enabledTabs.length - 1];\n    switch (code) {\n      // LEFT\n      case 'ArrowLeft':\n        {\n          if (tabPositionTopOrBottom) {\n            onOffset(isRTL ? 1 : -1);\n          }\n          break;\n        }\n\n      // RIGHT\n      case 'ArrowRight':\n        {\n          if (tabPositionTopOrBottom) {\n            onOffset(isRTL ? -1 : 1);\n          }\n          break;\n        }\n\n      // UP\n      case 'ArrowUp':\n        {\n          e.preventDefault();\n          if (!tabPositionTopOrBottom) {\n            onOffset(-1);\n          }\n          break;\n        }\n\n      // DOWN\n      case 'ArrowDown':\n        {\n          e.preventDefault();\n          if (!tabPositionTopOrBottom) {\n            onOffset(1);\n          }\n          break;\n        }\n\n      // HOME\n      case 'Home':\n        {\n          e.preventDefault();\n          setFocusKey(firstEnabledTab);\n          break;\n        }\n\n      // END\n      case 'End':\n        {\n          e.preventDefault();\n          setFocusKey(lastEnabledTab);\n          break;\n        }\n\n      // Enter & Space\n      case 'Enter':\n      case 'Space':\n        {\n          e.preventDefault();\n          onTabClick(focusKey ?? activeKey, e);\n          break;\n        }\n      // Backspace\n      case 'Backspace':\n      case 'Delete':\n        {\n          handleRemoveTab(focusKey, e);\n          break;\n        }\n    }\n  };\n\n  // ========================== Tab ==========================\n  const tabNodeStyle = {};\n  if (tabPositionTopOrBottom) {\n    tabNodeStyle.marginInlineStart = tabBarGutter;\n  } else {\n    tabNodeStyle.marginTop = tabBarGutter;\n  }\n  const tabNodes = tabs.map((tab, i) => {\n    const {\n      key\n    } = tab;\n    return /*#__PURE__*/React.createElement(TabNode, {\n      id: id,\n      prefixCls: prefixCls,\n      key: key,\n      tab: tab,\n      className: tabsClassNames?.item\n      /* first node should not have margin left */,\n      style: i === 0 ? styles?.item : {\n        ...tabNodeStyle,\n        ...styles?.item\n      },\n      closable: tab.closable,\n      editable: editable,\n      active: key === activeKey,\n      focus: key === focusKey,\n      renderWrapper: children,\n      removeAriaLabel: locale?.removeAriaLabel,\n      tabCount: enabledTabs.length,\n      currentPosition: i + 1,\n      onClick: e => {\n        onTabClick(key, e);\n      },\n      onKeyDown: handleKeyDown,\n      onFocus: () => {\n        if (!isMouse) {\n          setFocusKey(key);\n        }\n        scrollToTab(key);\n        doLockAnimation();\n        if (!tabsWrapperRef.current) {\n          return;\n        }\n        // Focus element will make scrollLeft change which we should reset back\n        if (!rtl) {\n          tabsWrapperRef.current.scrollLeft = 0;\n        }\n        tabsWrapperRef.current.scrollTop = 0;\n      },\n      onBlur: () => {\n        setFocusKey(undefined);\n      },\n      onMouseDown: e => handleMouseDown(key, e),\n      onMouseUp: () => {\n        setIsMouse(false);\n      }\n    });\n  });\n\n  // Update buttons records\n  const updateTabSizes = () => setTabSizes(() => {\n    const newSizes = new Map();\n    const listRect = tabListRef.current?.getBoundingClientRect();\n    tabs.forEach(({\n      key\n    }) => {\n      const btnNode = tabListRef.current?.querySelector(`[data-node-key=\"${genDataNodeKey(key)}\"]`);\n      if (btnNode) {\n        const [width, height, left, top] = getTabSize(btnNode, listRect);\n        newSizes.set(key, {\n          width,\n          height,\n          left,\n          top\n        });\n      }\n    });\n    return newSizes;\n  });\n  useEffect(() => {\n    updateTabSizes();\n  }, [tabs.map(tab => tab.key).join('_')]);\n  const onListHolderResize = useUpdate(() => {\n    // Update wrapper records\n    const containerSize = getSize(containerRef);\n    const extraLeftSize = getSize(extraLeftRef);\n    const extraRightSize = getSize(extraRightRef);\n    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);\n    const newAddSize = getSize(innerAddButtonRef);\n    setAddSize(newAddSize);\n    const newOperationSize = getSize(operationsRef);\n    setOperationSize(newOperationSize);\n\n    // Which includes add button size\n    const tabContentFullSize = getSize(tabListRef);\n    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);\n\n    // Update buttons records\n    updateTabSizes();\n  });\n\n  // ======================== Dropdown =======================\n  const startHiddenTabs = tabs.slice(0, visibleStart);\n  const endHiddenTabs = tabs.slice(visibleEnd + 1);\n  const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];\n\n  // =================== Link & Operations ===================\n  const activeTabOffset = tabOffsets.get(activeKey);\n  const {\n    style: indicatorStyle\n  } = useIndicator({\n    activeTabOffset,\n    horizontal: tabPositionTopOrBottom,\n    indicator,\n    rtl\n  });\n\n  // ========================= Effect ========================\n  useEffect(() => {\n    scrollToTab();\n  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);\n\n  // Should recalculate when rtl changed\n  useEffect(() => {\n    onListHolderResize();\n    // eslint-disable-next-line\n  }, [rtl]);\n\n  // ========================= Render ========================\n  const hasDropdown = !!hiddenTabs.length;\n  const wrapPrefix = `${prefixCls}-nav-wrap`;\n  let pingLeft;\n  let pingRight;\n  let pingTop;\n  let pingBottom;\n  if (tabPositionTopOrBottom) {\n    if (rtl) {\n      pingRight = transformLeft > 0;\n      pingLeft = transformLeft !== transformMax;\n    } else {\n      pingLeft = transformLeft < 0;\n      pingRight = transformLeft !== transformMin;\n    }\n  } else {\n    pingTop = transformTop < 0;\n    pingBottom = transformTop !== transformMin;\n  }\n  return /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: onListHolderResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: useComposeRef(ref, containerRef),\n    role: \"tablist\",\n    \"aria-orientation\": tabPositionTopOrBottom ? 'horizontal' : 'vertical',\n    className: clsx(`${prefixCls}-nav`, className, tabsClassNames?.header),\n    style: {\n      ...styles?.header,\n      ...style\n    },\n    onKeyDown: () => {\n      // No need animation when use keyboard\n      doLockAnimation();\n    }\n  }, /*#__PURE__*/React.createElement(ExtraContent, {\n    ref: extraLeftRef,\n    position: \"left\",\n    extra: extra,\n    prefixCls: prefixCls\n  }), /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: onListHolderResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(wrapPrefix, {\n      [`${wrapPrefix}-ping-left`]: pingLeft,\n      [`${wrapPrefix}-ping-right`]: pingRight,\n      [`${wrapPrefix}-ping-top`]: pingTop,\n      [`${wrapPrefix}-ping-bottom`]: pingBottom\n    }),\n    ref: tabsWrapperRef\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: onListHolderResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: tabListRef,\n    className: `${prefixCls}-nav-list`,\n    style: {\n      transform: `translate(${transformLeft}px, ${transformTop}px)`,\n      transition: lockAnimation ? 'none' : undefined\n    }\n  }, tabNodes, /*#__PURE__*/React.createElement(AddButton, {\n    ref: innerAddButtonRef,\n    prefixCls: prefixCls,\n    locale: locale,\n    editable: editable,\n    style: {\n      ...(tabNodes.length === 0 ? undefined : tabNodeStyle),\n      visibility: hasDropdown ? 'hidden' : null\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(`${prefixCls}-ink-bar`, tabsClassNames?.indicator, {\n      [`${prefixCls}-ink-bar-animated`]: animated.inkBar\n    }),\n    style: {\n      ...indicatorStyle,\n      ...styles?.indicator\n    }\n  }))))), /*#__PURE__*/React.createElement(OperationNode, _extends({}, props, {\n    removeAriaLabel: locale?.removeAriaLabel,\n    ref: operationsRef,\n    prefixCls: prefixCls,\n    tabs: hiddenTabs,\n    className: !hasDropdown && operationsHiddenClassName,\n    popupStyle: styles?.popup,\n    tabMoving: !!lockAnimation\n  })), /*#__PURE__*/React.createElement(ExtraContent, {\n    ref: extraRightRef,\n    position: \"right\",\n    extra: extra,\n    prefixCls: prefixCls\n  })));\n  /* eslint-enable */\n});\nexport default TabNavList;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","ResizeObserver","useEvent","useComposeRef","React","useEffect","useRef","useState","TabContext","useIndicator","useOffsets","useSyncState","useTouchMove","useUpdate","useUpdateState","useVisibleRange","genDataNodeKey","getRemovable","stringify","AddButton","ExtraContent","OperationNode","TabNode","getTabSize","tab","containerRect","offsetWidth","offsetHeight","offsetTop","offsetLeft","width","height","left","top","getBoundingClientRect","Math","abs","getSize","refObj","current","getUnitValue","size","tabPositionTopOrBottom","TabNavList","forwardRef","props","ref","className","style","id","animated","activeKey","rtl","extra","editable","locale","tabPosition","tabBarGutter","children","onTabClick","onTabScroll","indicator","classNames","tabsClassNames","styles","prefixCls","tabs","useContext","containerRef","extraLeftRef","extraRightRef","tabsWrapperRef","tabListRef","operationsRef","innerAddButtonRef","transformLeft","setTransformLeft","next","prev","direction","transformTop","setTransformTop","containerExcludeExtraSize","setContainerExcludeExtraSize","tabContentSize","setTabContentSize","addSize","setAddSize","operationSize","setOperationSize","tabSizes","setTabSizes","Map","tabOffsets","containerExcludeExtraSizeValue","tabContentSizeValue","addSizeValue","operationSizeValue","needScroll","floor","visibleTabContentValue","operationsHiddenClassName","transformMin","transformMax","min","max","alignInRange","value","touchMovingRef","lockAnimation","setLockAnimation","doLockAnimation","Date","now","clearTouchMoving","clearTimeout","offsetX","offsetY","doMove","setState","offset","newValue","setTimeout","visibleStart","visibleEnd","scrollToTab","tabOffset","get","right","newTransform","focusKey","setFocusKey","isMouse","setIsMouse","enabledTabs","filter","disabled","map","onOffset","currentIndex","indexOf","len","nextIndex","newKey","handleRemoveTab","removalTabKey","e","removeIndex","removeTab","find","removable","closable","closeIcon","preventDefault","stopPropagation","onEdit","event","handleMouseDown","button","handleKeyDown","code","isRTL","firstEnabledTab","lastEnabledTab","tabNodeStyle","marginInlineStart","marginTop","tabNodes","createElement","item","active","focus","renderWrapper","removeAriaLabel","tabCount","currentPosition","onClick","onKeyDown","onFocus","scrollLeft","scrollTop","onBlur","undefined","onMouseDown","onMouseUp","updateTabSizes","newSizes","listRect","forEach","btnNode","querySelector","set","join","onListHolderResize","containerSize","extraLeftSize","extraRightSize","newAddSize","newOperationSize","tabContentFullSize","startHiddenTabs","slice","endHiddenTabs","hiddenTabs","activeTabOffset","indicatorStyle","horizontal","hasDropdown","wrapPrefix","pingLeft","pingRight","pingTop","pingBottom","onResize","role","header","position","transform","transition","visibility","inkBar","popupStyle","popup","tabMoving"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/tabs/es/TabNavList/index.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport { clsx } from 'clsx';\nimport ResizeObserver from '@rc-component/resize-observer';\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport { useComposeRef } from \"@rc-component/util/es/ref\";\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport TabContext from \"../TabContext\";\nimport useIndicator from \"../hooks/useIndicator\";\nimport useOffsets from \"../hooks/useOffsets\";\nimport useSyncState from \"../hooks/useSyncState\";\nimport useTouchMove from \"../hooks/useTouchMove\";\nimport useUpdate, { useUpdateState } from \"../hooks/useUpdate\";\nimport useVisibleRange from \"../hooks/useVisibleRange\";\nimport { genDataNodeKey, getRemovable, stringify } from \"../util\";\nimport AddButton from \"./AddButton\";\nimport ExtraContent from \"./ExtraContent\";\nimport OperationNode from \"./OperationNode\";\nimport TabNode from \"./TabNode\";\nconst getTabSize = (tab, containerRect) => {\n  // tabListRef\n  const {\n    offsetWidth,\n    offsetHeight,\n    offsetTop,\n    offsetLeft\n  } = tab;\n  const {\n    width,\n    height,\n    left,\n    top\n  } = tab.getBoundingClientRect();\n\n  // Use getBoundingClientRect to avoid decimal inaccuracy\n  if (Math.abs(width - offsetWidth) < 1) {\n    return [width, height, left - containerRect.left, top - containerRect.top];\n  }\n  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];\n};\nconst getSize = refObj => {\n  const {\n    offsetWidth = 0,\n    offsetHeight = 0\n  } = refObj.current || {};\n\n  // Use getBoundingClientRect to avoid decimal inaccuracy\n  if (refObj.current) {\n    const {\n      width,\n      height\n    } = refObj.current.getBoundingClientRect();\n    if (Math.abs(width - offsetWidth) < 1) {\n      return [width, height];\n    }\n  }\n  return [offsetWidth, offsetHeight];\n};\n\n/**\n * Convert `SizeInfo` to unit value. Such as [123, 456] with `top` position get `123`\n */\nconst getUnitValue = (size, tabPositionTopOrBottom) => {\n  return size[tabPositionTopOrBottom ? 0 : 1];\n};\nconst TabNavList = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    className,\n    style,\n    id,\n    animated,\n    activeKey,\n    rtl,\n    extra,\n    editable,\n    locale,\n    tabPosition,\n    tabBarGutter,\n    children,\n    onTabClick,\n    onTabScroll,\n    indicator,\n    classNames: tabsClassNames,\n    styles\n  } = props;\n  const {\n    prefixCls,\n    tabs\n  } = React.useContext(TabContext);\n  const containerRef = useRef(null);\n  const extraLeftRef = useRef(null);\n  const extraRightRef = useRef(null);\n  const tabsWrapperRef = useRef(null);\n  const tabListRef = useRef(null);\n  const operationsRef = useRef(null);\n  const innerAddButtonRef = useRef(null);\n  const tabPositionTopOrBottom = tabPosition === 'top' || tabPosition === 'bottom';\n  const [transformLeft, setTransformLeft] = useSyncState(0, (next, prev) => {\n    if (tabPositionTopOrBottom && onTabScroll) {\n      onTabScroll({\n        direction: next > prev ? 'left' : 'right'\n      });\n    }\n  });\n  const [transformTop, setTransformTop] = useSyncState(0, (next, prev) => {\n    if (!tabPositionTopOrBottom && onTabScroll) {\n      onTabScroll({\n        direction: next > prev ? 'top' : 'bottom'\n      });\n    }\n  });\n  const [containerExcludeExtraSize, setContainerExcludeExtraSize] = useState([0, 0]);\n  const [tabContentSize, setTabContentSize] = useState([0, 0]);\n  const [addSize, setAddSize] = useState([0, 0]);\n  const [operationSize, setOperationSize] = useState([0, 0]);\n  const [tabSizes, setTabSizes] = useUpdateState(new Map());\n  const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);\n\n  // ========================== Unit =========================\n  const containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);\n  const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);\n  const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);\n  const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);\n  const needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);\n  const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;\n\n  // ========================== Util =========================\n  const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;\n  let transformMin = 0;\n  let transformMax = 0;\n  if (!tabPositionTopOrBottom) {\n    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);\n    transformMax = 0;\n  } else if (rtl) {\n    transformMin = 0;\n    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);\n  } else {\n    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);\n    transformMax = 0;\n  }\n  function alignInRange(value) {\n    if (value < transformMin) {\n      return transformMin;\n    }\n    if (value > transformMax) {\n      return transformMax;\n    }\n    return value;\n  }\n\n  // ========================= Mobile ========================\n  const touchMovingRef = useRef(null);\n  const [lockAnimation, setLockAnimation] = useState();\n  function doLockAnimation() {\n    setLockAnimation(Date.now());\n  }\n  function clearTouchMoving() {\n    if (touchMovingRef.current) {\n      clearTimeout(touchMovingRef.current);\n    }\n  }\n  useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {\n    function doMove(setState, offset) {\n      setState(value => {\n        const newValue = alignInRange(value + offset);\n        return newValue;\n      });\n    }\n\n    // Skip scroll if place is enough\n    if (!needScroll) {\n      return false;\n    }\n    if (tabPositionTopOrBottom) {\n      doMove(setTransformLeft, offsetX);\n    } else {\n      doMove(setTransformTop, offsetY);\n    }\n    clearTouchMoving();\n    doLockAnimation();\n    return true;\n  });\n  useEffect(() => {\n    clearTouchMoving();\n    if (lockAnimation) {\n      touchMovingRef.current = setTimeout(() => {\n        setLockAnimation(0);\n      }, 100);\n    }\n    return clearTouchMoving;\n  }, [lockAnimation]);\n\n  // ===================== Visible Range =====================\n  // Render tab node & collect tab offset\n  const [visibleStart, visibleEnd] = useVisibleRange(tabOffsets,\n  // Container\n  visibleTabContentValue,\n  // Transform\n  tabPositionTopOrBottom ? transformLeft : transformTop,\n  // Tabs\n  tabContentSizeValue,\n  // Add\n  addSizeValue,\n  // Operation\n  operationSizeValue, {\n    ...props,\n    tabs\n  });\n\n  // ========================= Scroll ========================\n  const scrollToTab = useEvent((key = activeKey) => {\n    const tabOffset = tabOffsets.get(key) || {\n      width: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0\n    };\n    if (tabPositionTopOrBottom) {\n      // ============ Align with top & bottom ============\n      let newTransform = transformLeft;\n\n      // RTL\n      if (rtl) {\n        if (tabOffset.right < transformLeft) {\n          newTransform = tabOffset.right;\n        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {\n          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;\n        }\n      }\n      // LTR\n      else if (tabOffset.left < -transformLeft) {\n        newTransform = -tabOffset.left;\n      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {\n        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);\n      }\n      setTransformTop(0);\n      setTransformLeft(alignInRange(newTransform));\n    } else {\n      // ============ Align with left & right ============\n      let newTransform = transformTop;\n      if (tabOffset.top < -transformTop) {\n        newTransform = -tabOffset.top;\n      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {\n        newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);\n      }\n      setTransformLeft(0);\n      setTransformTop(alignInRange(newTransform));\n    }\n  });\n\n  // ========================= Focus =========================\n  const [focusKey, setFocusKey] = useState();\n  const [isMouse, setIsMouse] = useState(false);\n  const enabledTabs = tabs.filter(tab => !tab.disabled).map(tab => tab.key);\n  const onOffset = offset => {\n    const currentIndex = enabledTabs.indexOf(focusKey || activeKey);\n    const len = enabledTabs.length;\n    const nextIndex = (currentIndex + offset + len) % len;\n    const newKey = enabledTabs[nextIndex];\n    setFocusKey(newKey);\n  };\n  const handleRemoveTab = (removalTabKey, e) => {\n    const removeIndex = enabledTabs.indexOf(removalTabKey);\n    const removeTab = tabs.find(tab => tab.key === removalTabKey);\n    const removable = getRemovable(removeTab?.closable, removeTab?.closeIcon, editable, removeTab?.disabled);\n    if (removable) {\n      e.preventDefault();\n      e.stopPropagation();\n      editable.onEdit('remove', {\n        key: removalTabKey,\n        event: e\n      });\n\n      // when remove last tab, focus previous tab\n      if (removeIndex === enabledTabs.length - 1) {\n        onOffset(-1);\n      } else {\n        onOffset(1);\n      }\n    }\n  };\n  const handleMouseDown = (key, e) => {\n    setIsMouse(true);\n    // Middle mouse button\n    if (e.button === 1) {\n      handleRemoveTab(key, e);\n    }\n  };\n  const handleKeyDown = e => {\n    const {\n      code\n    } = e;\n    const isRTL = rtl && tabPositionTopOrBottom;\n    const firstEnabledTab = enabledTabs[0];\n    const lastEnabledTab = enabledTabs[enabledTabs.length - 1];\n    switch (code) {\n      // LEFT\n      case 'ArrowLeft':\n        {\n          if (tabPositionTopOrBottom) {\n            onOffset(isRTL ? 1 : -1);\n          }\n          break;\n        }\n\n      // RIGHT\n      case 'ArrowRight':\n        {\n          if (tabPositionTopOrBottom) {\n            onOffset(isRTL ? -1 : 1);\n          }\n          break;\n        }\n\n      // UP\n      case 'ArrowUp':\n        {\n          e.preventDefault();\n          if (!tabPositionTopOrBottom) {\n            onOffset(-1);\n          }\n          break;\n        }\n\n      // DOWN\n      case 'ArrowDown':\n        {\n          e.preventDefault();\n          if (!tabPositionTopOrBottom) {\n            onOffset(1);\n          }\n          break;\n        }\n\n      // HOME\n      case 'Home':\n        {\n          e.preventDefault();\n          setFocusKey(firstEnabledTab);\n          break;\n        }\n\n      // END\n      case 'End':\n        {\n          e.preventDefault();\n          setFocusKey(lastEnabledTab);\n          break;\n        }\n\n      // Enter & Space\n      case 'Enter':\n      case 'Space':\n        {\n          e.preventDefault();\n          onTabClick(focusKey ?? activeKey, e);\n          break;\n        }\n      // Backspace\n      case 'Backspace':\n      case 'Delete':\n        {\n          handleRemoveTab(focusKey, e);\n          break;\n        }\n    }\n  };\n\n  // ========================== Tab ==========================\n  const tabNodeStyle = {};\n  if (tabPositionTopOrBottom) {\n    tabNodeStyle.marginInlineStart = tabBarGutter;\n  } else {\n    tabNodeStyle.marginTop = tabBarGutter;\n  }\n  const tabNodes = tabs.map((tab, i) => {\n    const {\n      key\n    } = tab;\n    return /*#__PURE__*/React.createElement(TabNode, {\n      id: id,\n      prefixCls: prefixCls,\n      key: key,\n      tab: tab,\n      className: tabsClassNames?.item\n      /* first node should not have margin left */,\n      style: i === 0 ? styles?.item : {\n        ...tabNodeStyle,\n        ...styles?.item\n      },\n      closable: tab.closable,\n      editable: editable,\n      active: key === activeKey,\n      focus: key === focusKey,\n      renderWrapper: children,\n      removeAriaLabel: locale?.removeAriaLabel,\n      tabCount: enabledTabs.length,\n      currentPosition: i + 1,\n      onClick: e => {\n        onTabClick(key, e);\n      },\n      onKeyDown: handleKeyDown,\n      onFocus: () => {\n        if (!isMouse) {\n          setFocusKey(key);\n        }\n        scrollToTab(key);\n        doLockAnimation();\n        if (!tabsWrapperRef.current) {\n          return;\n        }\n        // Focus element will make scrollLeft change which we should reset back\n        if (!rtl) {\n          tabsWrapperRef.current.scrollLeft = 0;\n        }\n        tabsWrapperRef.current.scrollTop = 0;\n      },\n      onBlur: () => {\n        setFocusKey(undefined);\n      },\n      onMouseDown: e => handleMouseDown(key, e),\n      onMouseUp: () => {\n        setIsMouse(false);\n      }\n    });\n  });\n\n  // Update buttons records\n  const updateTabSizes = () => setTabSizes(() => {\n    const newSizes = new Map();\n    const listRect = tabListRef.current?.getBoundingClientRect();\n    tabs.forEach(({\n      key\n    }) => {\n      const btnNode = tabListRef.current?.querySelector(`[data-node-key=\"${genDataNodeKey(key)}\"]`);\n      if (btnNode) {\n        const [width, height, left, top] = getTabSize(btnNode, listRect);\n        newSizes.set(key, {\n          width,\n          height,\n          left,\n          top\n        });\n      }\n    });\n    return newSizes;\n  });\n  useEffect(() => {\n    updateTabSizes();\n  }, [tabs.map(tab => tab.key).join('_')]);\n  const onListHolderResize = useUpdate(() => {\n    // Update wrapper records\n    const containerSize = getSize(containerRef);\n    const extraLeftSize = getSize(extraLeftRef);\n    const extraRightSize = getSize(extraRightRef);\n    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);\n    const newAddSize = getSize(innerAddButtonRef);\n    setAddSize(newAddSize);\n    const newOperationSize = getSize(operationsRef);\n    setOperationSize(newOperationSize);\n\n    // Which includes add button size\n    const tabContentFullSize = getSize(tabListRef);\n    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);\n\n    // Update buttons records\n    updateTabSizes();\n  });\n\n  // ======================== Dropdown =======================\n  const startHiddenTabs = tabs.slice(0, visibleStart);\n  const endHiddenTabs = tabs.slice(visibleEnd + 1);\n  const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];\n\n  // =================== Link & Operations ===================\n  const activeTabOffset = tabOffsets.get(activeKey);\n  const {\n    style: indicatorStyle\n  } = useIndicator({\n    activeTabOffset,\n    horizontal: tabPositionTopOrBottom,\n    indicator,\n    rtl\n  });\n\n  // ========================= Effect ========================\n  useEffect(() => {\n    scrollToTab();\n  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);\n\n  // Should recalculate when rtl changed\n  useEffect(() => {\n    onListHolderResize();\n    // eslint-disable-next-line\n  }, [rtl]);\n\n  // ========================= Render ========================\n  const hasDropdown = !!hiddenTabs.length;\n  const wrapPrefix = `${prefixCls}-nav-wrap`;\n  let pingLeft;\n  let pingRight;\n  let pingTop;\n  let pingBottom;\n  if (tabPositionTopOrBottom) {\n    if (rtl) {\n      pingRight = transformLeft > 0;\n      pingLeft = transformLeft !== transformMax;\n    } else {\n      pingLeft = transformLeft < 0;\n      pingRight = transformLeft !== transformMin;\n    }\n  } else {\n    pingTop = transformTop < 0;\n    pingBottom = transformTop !== transformMin;\n  }\n  return /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: onListHolderResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: useComposeRef(ref, containerRef),\n    role: \"tablist\",\n    \"aria-orientation\": tabPositionTopOrBottom ? 'horizontal' : 'vertical',\n    className: clsx(`${prefixCls}-nav`, className, tabsClassNames?.header),\n    style: {\n      ...styles?.header,\n      ...style\n    },\n    onKeyDown: () => {\n      // No need animation when use keyboard\n      doLockAnimation();\n    }\n  }, /*#__PURE__*/React.createElement(ExtraContent, {\n    ref: extraLeftRef,\n    position: \"left\",\n    extra: extra,\n    prefixCls: prefixCls\n  }), /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: onListHolderResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(wrapPrefix, {\n      [`${wrapPrefix}-ping-left`]: pingLeft,\n      [`${wrapPrefix}-ping-right`]: pingRight,\n      [`${wrapPrefix}-ping-top`]: pingTop,\n      [`${wrapPrefix}-ping-bottom`]: pingBottom\n    }),\n    ref: tabsWrapperRef\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: onListHolderResize\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: tabListRef,\n    className: `${prefixCls}-nav-list`,\n    style: {\n      transform: `translate(${transformLeft}px, ${transformTop}px)`,\n      transition: lockAnimation ? 'none' : undefined\n    }\n  }, tabNodes, /*#__PURE__*/React.createElement(AddButton, {\n    ref: innerAddButtonRef,\n    prefixCls: prefixCls,\n    locale: locale,\n    editable: editable,\n    style: {\n      ...(tabNodes.length === 0 ? undefined : tabNodeStyle),\n      visibility: hasDropdown ? 'hidden' : null\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(`${prefixCls}-ink-bar`, tabsClassNames?.indicator, {\n      [`${prefixCls}-ink-bar-animated`]: animated.inkBar\n    }),\n    style: {\n      ...indicatorStyle,\n      ...styles?.indicator\n    }\n  }))))), /*#__PURE__*/React.createElement(OperationNode, _extends({}, props, {\n    removeAriaLabel: locale?.removeAriaLabel,\n    ref: operationsRef,\n    prefixCls: prefixCls,\n    tabs: hiddenTabs,\n    className: !hasDropdown && operationsHiddenClassName,\n    popupStyle: styles?.popup,\n    tabMoving: !!lockAnimation\n  })), /*#__PURE__*/React.createElement(ExtraContent, {\n    ref: extraRightRef,\n    position: \"right\",\n    extra: extra,\n    prefixCls: prefixCls\n  })));\n  /* eslint-enable */\n});\nexport default TabNavList;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}