{"ast":null,"code":"import useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { useMemo, useState } from 'react';\nimport { isInViewPort } from \"../util\";\nfunction isValidNumber(val) {\n  return typeof val === 'number' && !Number.isNaN(val);\n}\nexport default function useTarget(target, open, gap, scrollIntoViewOptions, inlineMode, placeholderRef) {\n  // ========================= Target =========================\n  // We trade `undefined` as not get target by function yet.\n  // `null` as empty target.\n  const [targetElement, setTargetElement] = useState(undefined);\n  useLayoutEffect(() => {\n    const nextElement = typeof target === 'function' ? target() : target;\n    setTargetElement(nextElement || null);\n  });\n\n  // ========================= Align ==========================\n  const [posInfo, setPosInfo] = useState(null);\n  const updatePos = useEvent(() => {\n    if (targetElement) {\n      // Exist target element. We should scroll and get target position\n      if (!inlineMode && !isInViewPort(targetElement) && open) {\n        targetElement.scrollIntoView(scrollIntoViewOptions);\n      }\n      const {\n        left,\n        top,\n        width,\n        height\n      } = targetElement.getBoundingClientRect();\n      const nextPosInfo = {\n        left,\n        top,\n        width,\n        height,\n        radius: 0\n      };\n\n      // If `inlineMode` we need cut off parent offset\n      if (inlineMode) {\n        const parentRect = placeholderRef.current?.parentElement?.getBoundingClientRect();\n        if (parentRect) {\n          nextPosInfo.left -= parentRect.left;\n          nextPosInfo.top -= parentRect.top;\n        }\n      }\n      setPosInfo(origin => {\n        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {\n          return nextPosInfo;\n        }\n        return origin;\n      });\n    } else {\n      // Not exist target which means we just show in center\n      setPosInfo(null);\n    }\n  });\n  const getGapOffset = index => (Array.isArray(gap?.offset) ? gap?.offset[index] : gap?.offset) ?? 6;\n  useLayoutEffect(() => {\n    updatePos();\n    // update when window resize\n    window.addEventListener('resize', updatePos);\n    // update when `document.body.style.overflow` is set to visible\n    // by default, it will be set to hidden\n    window.addEventListener('scroll', updatePos);\n    return () => {\n      window.removeEventListener('resize', updatePos);\n      window.removeEventListener('scroll', updatePos);\n    };\n  }, [targetElement, open, updatePos]);\n\n  // ======================== PosInfo =========================\n  const mergedPosInfo = useMemo(() => {\n    if (!posInfo) {\n      return posInfo;\n    }\n    const gapOffsetX = getGapOffset(0);\n    const gapOffsetY = getGapOffset(1);\n    const gapRadius = isValidNumber(gap?.radius) ? gap?.radius : 2;\n    return {\n      left: posInfo.left - gapOffsetX,\n      top: posInfo.top - gapOffsetY,\n      width: posInfo.width + gapOffsetX * 2,\n      height: posInfo.height + gapOffsetY * 2,\n      radius: gapRadius\n    };\n  }, [posInfo, gap]);\n  return [mergedPosInfo, targetElement];\n}","map":{"version":3,"names":["useEvent","useLayoutEffect","useMemo","useState","isInViewPort","isValidNumber","val","Number","isNaN","useTarget","target","open","gap","scrollIntoViewOptions","inlineMode","placeholderRef","targetElement","setTargetElement","undefined","nextElement","posInfo","setPosInfo","updatePos","scrollIntoView","left","top","width","height","getBoundingClientRect","nextPosInfo","radius","parentRect","current","parentElement","origin","JSON","stringify","getGapOffset","index","Array","isArray","offset","window","addEventListener","removeEventListener","mergedPosInfo","gapOffsetX","gapOffsetY","gapRadius"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/tour/es/hooks/useTarget.js"],"sourcesContent":["import useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { useMemo, useState } from 'react';\nimport { isInViewPort } from \"../util\";\nfunction isValidNumber(val) {\n  return typeof val === 'number' && !Number.isNaN(val);\n}\nexport default function useTarget(target, open, gap, scrollIntoViewOptions, inlineMode, placeholderRef) {\n  // ========================= Target =========================\n  // We trade `undefined` as not get target by function yet.\n  // `null` as empty target.\n  const [targetElement, setTargetElement] = useState(undefined);\n  useLayoutEffect(() => {\n    const nextElement = typeof target === 'function' ? target() : target;\n    setTargetElement(nextElement || null);\n  });\n\n  // ========================= Align ==========================\n  const [posInfo, setPosInfo] = useState(null);\n  const updatePos = useEvent(() => {\n    if (targetElement) {\n      // Exist target element. We should scroll and get target position\n      if (!inlineMode && !isInViewPort(targetElement) && open) {\n        targetElement.scrollIntoView(scrollIntoViewOptions);\n      }\n      const {\n        left,\n        top,\n        width,\n        height\n      } = targetElement.getBoundingClientRect();\n      const nextPosInfo = {\n        left,\n        top,\n        width,\n        height,\n        radius: 0\n      };\n\n      // If `inlineMode` we need cut off parent offset\n      if (inlineMode) {\n        const parentRect = placeholderRef.current?.parentElement?.getBoundingClientRect();\n        if (parentRect) {\n          nextPosInfo.left -= parentRect.left;\n          nextPosInfo.top -= parentRect.top;\n        }\n      }\n      setPosInfo(origin => {\n        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {\n          return nextPosInfo;\n        }\n        return origin;\n      });\n    } else {\n      // Not exist target which means we just show in center\n      setPosInfo(null);\n    }\n  });\n  const getGapOffset = index => (Array.isArray(gap?.offset) ? gap?.offset[index] : gap?.offset) ?? 6;\n  useLayoutEffect(() => {\n    updatePos();\n    // update when window resize\n    window.addEventListener('resize', updatePos);\n    // update when `document.body.style.overflow` is set to visible\n    // by default, it will be set to hidden\n    window.addEventListener('scroll', updatePos);\n    return () => {\n      window.removeEventListener('resize', updatePos);\n      window.removeEventListener('scroll', updatePos);\n    };\n  }, [targetElement, open, updatePos]);\n\n  // ======================== PosInfo =========================\n  const mergedPosInfo = useMemo(() => {\n    if (!posInfo) {\n      return posInfo;\n    }\n    const gapOffsetX = getGapOffset(0);\n    const gapOffsetY = getGapOffset(1);\n    const gapRadius = isValidNumber(gap?.radius) ? gap?.radius : 2;\n    return {\n      left: posInfo.left - gapOffsetX,\n      top: posInfo.top - gapOffsetY,\n      width: posInfo.width + gapOffsetX * 2,\n      height: posInfo.height + gapOffsetY * 2,\n      radius: gapRadius\n    };\n  }, [posInfo, gap]);\n  return [mergedPosInfo, targetElement];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}