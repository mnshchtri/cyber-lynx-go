{"ast":null,"code":"function isPointsEq(a1 = [], a2 = [], isAlignPoint) {\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  const {\n    points\n  } = align;\n  const placements = Object.keys(builtinPlacements);\n  for (let i = 0; i < placements.length; i += 1) {\n    const placement = placements[i];\n    if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {\n      return `${prefixCls}-placement-${placement}`;\n    }\n  }\n  return '';\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\nexport function collectScroller(ele) {\n  const scrollerList = [];\n  let current = ele?.parentElement;\n  const scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];\n  while (current) {\n    const {\n      overflowX,\n      overflowY,\n      overflow\n    } = getWin(current).getComputedStyle(current);\n    if ([overflowX, overflowY, overflow].some(o => scrollStyle.includes(o))) {\n      scrollerList.push(current);\n    }\n    current = current.parentElement;\n  }\n  return scrollerList;\n}\nexport function toNum(num, defaultValue = 1) {\n  return Number.isNaN(num) ? defaultValue : num;\n}\nfunction getPxValue(val) {\n  return toNum(parseFloat(val), 0);\n}\n/**\n *\n *\n *  **************************************\n *  *              Border                *\n *  *     **************************     *\n *  *     *                  *     *     *\n *  *  B  *                  *  S  *  B  *\n *  *  o  *                  *  c  *  o  *\n *  *  r  *      Content     *  r  *  r  *\n *  *  d  *                  *  o  *  d  *\n *  *  e  *                  *  l  *  e  *\n *  *  r  ********************  l  *  r  *\n *  *     *        Scroll          *     *\n *  *     **************************     *\n *  *              Border                *\n *  **************************************\n *\n */\n/**\n * Get visible area of element\n */\nexport function getVisibleArea(initArea, scrollerList) {\n  const visibleArea = {\n    ...initArea\n  };\n  (scrollerList || []).forEach(ele => {\n    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {\n      return;\n    }\n\n    // Skip if static position which will not affect visible area\n    const {\n      overflow,\n      overflowClipMargin,\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth\n    } = getWin(ele).getComputedStyle(ele);\n    const eleRect = ele.getBoundingClientRect();\n    const {\n      offsetHeight: eleOutHeight,\n      clientHeight: eleInnerHeight,\n      offsetWidth: eleOutWidth,\n      clientWidth: eleInnerWidth\n    } = ele;\n    const borderTopNum = getPxValue(borderTopWidth);\n    const borderBottomNum = getPxValue(borderBottomWidth);\n    const borderLeftNum = getPxValue(borderLeftWidth);\n    const borderRightNum = getPxValue(borderRightWidth);\n    const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n\n    // Original visible area\n    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;\n    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;\n\n    // Cut border size\n    const scaledBorderTopWidth = borderTopNum * scaleY;\n    const scaledBorderBottomWidth = borderBottomNum * scaleY;\n    const scaledBorderLeftWidth = borderLeftNum * scaleX;\n    const scaledBorderRightWidth = borderRightNum * scaleX;\n\n    // Clip margin\n    let clipMarginWidth = 0;\n    let clipMarginHeight = 0;\n    if (overflow === 'clip') {\n      const clipNum = getPxValue(overflowClipMargin);\n      clipMarginWidth = clipNum * scaleX;\n      clipMarginHeight = clipNum * scaleY;\n    }\n\n    // Region\n    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;\n    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;\n    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;\n    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleLeft);\n    visibleArea.top = Math.max(visibleArea.top, eleTop);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}","map":{"version":3,"names":["isPointsEq","a1","a2","isAlignPoint","getAlignPopupClassName","builtinPlacements","prefixCls","align","points","placements","Object","keys","i","length","placement","getWin","ele","ownerDocument","defaultView","collectScroller","scrollerList","current","parentElement","scrollStyle","overflowX","overflowY","overflow","getComputedStyle","some","o","includes","push","toNum","num","defaultValue","Number","isNaN","getPxValue","val","parseFloat","getVisibleArea","initArea","visibleArea","forEach","HTMLBodyElement","HTMLHtmlElement","overflowClipMargin","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","eleRect","getBoundingClientRect","offsetHeight","eleOutHeight","clientHeight","eleInnerHeight","offsetWidth","eleOutWidth","clientWidth","eleInnerWidth","borderTopNum","borderBottomNum","borderLeftNum","borderRightNum","scaleX","Math","round","width","scaleY","height","eleScrollWidth","eleScrollHeight","scaledBorderTopWidth","scaledBorderBottomWidth","scaledBorderLeftWidth","scaledBorderRightWidth","clipMarginWidth","clipMarginHeight","clipNum","eleLeft","x","eleTop","y","eleRight","eleBottom","left","max","top","right","min","bottom"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/trigger/es/util.js"],"sourcesContent":["function isPointsEq(a1 = [], a2 = [], isAlignPoint) {\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  const {\n    points\n  } = align;\n  const placements = Object.keys(builtinPlacements);\n  for (let i = 0; i < placements.length; i += 1) {\n    const placement = placements[i];\n    if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {\n      return `${prefixCls}-placement-${placement}`;\n    }\n  }\n  return '';\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\nexport function collectScroller(ele) {\n  const scrollerList = [];\n  let current = ele?.parentElement;\n  const scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];\n  while (current) {\n    const {\n      overflowX,\n      overflowY,\n      overflow\n    } = getWin(current).getComputedStyle(current);\n    if ([overflowX, overflowY, overflow].some(o => scrollStyle.includes(o))) {\n      scrollerList.push(current);\n    }\n    current = current.parentElement;\n  }\n  return scrollerList;\n}\nexport function toNum(num, defaultValue = 1) {\n  return Number.isNaN(num) ? defaultValue : num;\n}\nfunction getPxValue(val) {\n  return toNum(parseFloat(val), 0);\n}\n/**\n *\n *\n *  **************************************\n *  *              Border                *\n *  *     **************************     *\n *  *     *                  *     *     *\n *  *  B  *                  *  S  *  B  *\n *  *  o  *                  *  c  *  o  *\n *  *  r  *      Content     *  r  *  r  *\n *  *  d  *                  *  o  *  d  *\n *  *  e  *                  *  l  *  e  *\n *  *  r  ********************  l  *  r  *\n *  *     *        Scroll          *     *\n *  *     **************************     *\n *  *              Border                *\n *  **************************************\n *\n */\n/**\n * Get visible area of element\n */\nexport function getVisibleArea(initArea, scrollerList) {\n  const visibleArea = {\n    ...initArea\n  };\n  (scrollerList || []).forEach(ele => {\n    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {\n      return;\n    }\n\n    // Skip if static position which will not affect visible area\n    const {\n      overflow,\n      overflowClipMargin,\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth\n    } = getWin(ele).getComputedStyle(ele);\n    const eleRect = ele.getBoundingClientRect();\n    const {\n      offsetHeight: eleOutHeight,\n      clientHeight: eleInnerHeight,\n      offsetWidth: eleOutWidth,\n      clientWidth: eleInnerWidth\n    } = ele;\n    const borderTopNum = getPxValue(borderTopWidth);\n    const borderBottomNum = getPxValue(borderBottomWidth);\n    const borderLeftNum = getPxValue(borderLeftWidth);\n    const borderRightNum = getPxValue(borderRightWidth);\n    const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n\n    // Original visible area\n    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;\n    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;\n\n    // Cut border size\n    const scaledBorderTopWidth = borderTopNum * scaleY;\n    const scaledBorderBottomWidth = borderBottomNum * scaleY;\n    const scaledBorderLeftWidth = borderLeftNum * scaleX;\n    const scaledBorderRightWidth = borderRightNum * scaleX;\n\n    // Clip margin\n    let clipMarginWidth = 0;\n    let clipMarginHeight = 0;\n    if (overflow === 'clip') {\n      const clipNum = getPxValue(overflowClipMargin);\n      clipMarginWidth = clipNum * scaleX;\n      clipMarginHeight = clipNum * scaleY;\n    }\n\n    // Region\n    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;\n    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;\n    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;\n    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleLeft);\n    visibleArea.top = Math.max(visibleArea.top, eleTop);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}"],"mappings":"AAAA,SAASA,UAAUA,CAACC,EAAE,GAAG,EAAE,EAAEC,EAAE,GAAG,EAAE,EAAEC,YAAY,EAAE;EAClD,IAAIA,YAAY,EAAE;IAChB,OAAOF,EAAE,CAAC,CAAC,CAAC,KAAKC,EAAE,CAAC,CAAC,CAAC;EACxB;EACA,OAAOD,EAAE,CAAC,CAAC,CAAC,KAAKC,EAAE,CAAC,CAAC,CAAC,IAAID,EAAE,CAAC,CAAC,CAAC,KAAKC,EAAE,CAAC,CAAC,CAAC;AAC3C;AACA,OAAO,SAASE,sBAAsBA,CAACC,iBAAiB,EAAEC,SAAS,EAAEC,KAAK,EAAEJ,YAAY,EAAE;EACxF,MAAM;IACJK;EACF,CAAC,GAAGD,KAAK;EACT,MAAME,UAAU,GAAGC,MAAM,CAACC,IAAI,CAACN,iBAAiB,CAAC;EACjD,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,UAAU,CAACI,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAC7C,MAAME,SAAS,GAAGL,UAAU,CAACG,CAAC,CAAC;IAC/B,IAAIZ,UAAU,CAACK,iBAAiB,CAACS,SAAS,CAAC,EAAEN,MAAM,EAAEA,MAAM,EAAEL,YAAY,CAAC,EAAE;MAC1E,OAAO,GAAGG,SAAS,cAAcQ,SAAS,EAAE;IAC9C;EACF;EACA,OAAO,EAAE;AACX;AACA,OAAO,SAASC,MAAMA,CAACC,GAAG,EAAE;EAC1B,OAAOA,GAAG,CAACC,aAAa,CAACC,WAAW;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACH,GAAG,EAAE;EACnC,MAAMI,YAAY,GAAG,EAAE;EACvB,IAAIC,OAAO,GAAGL,GAAG,EAAEM,aAAa;EAChC,MAAMC,WAAW,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC;EACxD,OAAOF,OAAO,EAAE;IACd,MAAM;MACJG,SAAS;MACTC,SAAS;MACTC;IACF,CAAC,GAAGX,MAAM,CAACM,OAAO,CAAC,CAACM,gBAAgB,CAACN,OAAO,CAAC;IAC7C,IAAI,CAACG,SAAS,EAAEC,SAAS,EAAEC,QAAQ,CAAC,CAACE,IAAI,CAACC,CAAC,IAAIN,WAAW,CAACO,QAAQ,CAACD,CAAC,CAAC,CAAC,EAAE;MACvET,YAAY,CAACW,IAAI,CAACV,OAAO,CAAC;IAC5B;IACAA,OAAO,GAAGA,OAAO,CAACC,aAAa;EACjC;EACA,OAAOF,YAAY;AACrB;AACA,OAAO,SAASY,KAAKA,CAACC,GAAG,EAAEC,YAAY,GAAG,CAAC,EAAE;EAC3C,OAAOC,MAAM,CAACC,KAAK,CAACH,GAAG,CAAC,GAAGC,YAAY,GAAGD,GAAG;AAC/C;AACA,SAASI,UAAUA,CAACC,GAAG,EAAE;EACvB,OAAON,KAAK,CAACO,UAAU,CAACD,GAAG,CAAC,EAAE,CAAC,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,cAAcA,CAACC,QAAQ,EAAErB,YAAY,EAAE;EACrD,MAAMsB,WAAW,GAAG;IAClB,GAAGD;EACL,CAAC;EACD,CAACrB,YAAY,IAAI,EAAE,EAAEuB,OAAO,CAAC3B,GAAG,IAAI;IAClC,IAAIA,GAAG,YAAY4B,eAAe,IAAI5B,GAAG,YAAY6B,eAAe,EAAE;MACpE;IACF;;IAEA;IACA,MAAM;MACJnB,QAAQ;MACRoB,kBAAkB;MAClBC,cAAc;MACdC,iBAAiB;MACjBC,eAAe;MACfC;IACF,CAAC,GAAGnC,MAAM,CAACC,GAAG,CAAC,CAACW,gBAAgB,CAACX,GAAG,CAAC;IACrC,MAAMmC,OAAO,GAAGnC,GAAG,CAACoC,qBAAqB,CAAC,CAAC;IAC3C,MAAM;MACJC,YAAY,EAAEC,YAAY;MAC1BC,YAAY,EAAEC,cAAc;MAC5BC,WAAW,EAAEC,WAAW;MACxBC,WAAW,EAAEC;IACf,CAAC,GAAG5C,GAAG;IACP,MAAM6C,YAAY,GAAGxB,UAAU,CAACU,cAAc,CAAC;IAC/C,MAAMe,eAAe,GAAGzB,UAAU,CAACW,iBAAiB,CAAC;IACrD,MAAMe,aAAa,GAAG1B,UAAU,CAACY,eAAe,CAAC;IACjD,MAAMe,cAAc,GAAG3B,UAAU,CAACa,gBAAgB,CAAC;IACnD,MAAMe,MAAM,GAAGjC,KAAK,CAACkC,IAAI,CAACC,KAAK,CAAChB,OAAO,CAACiB,KAAK,GAAGV,WAAW,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC;IAC3E,MAAMW,MAAM,GAAGrC,KAAK,CAACkC,IAAI,CAACC,KAAK,CAAChB,OAAO,CAACmB,MAAM,GAAGhB,YAAY,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC;;IAE7E;IACA,MAAMiB,cAAc,GAAG,CAACb,WAAW,GAAGE,aAAa,GAAGG,aAAa,GAAGC,cAAc,IAAIC,MAAM;IAC9F,MAAMO,eAAe,GAAG,CAAClB,YAAY,GAAGE,cAAc,GAAGK,YAAY,GAAGC,eAAe,IAAIO,MAAM;;IAEjG;IACA,MAAMI,oBAAoB,GAAGZ,YAAY,GAAGQ,MAAM;IAClD,MAAMK,uBAAuB,GAAGZ,eAAe,GAAGO,MAAM;IACxD,MAAMM,qBAAqB,GAAGZ,aAAa,GAAGE,MAAM;IACpD,MAAMW,sBAAsB,GAAGZ,cAAc,GAAGC,MAAM;;IAEtD;IACA,IAAIY,eAAe,GAAG,CAAC;IACvB,IAAIC,gBAAgB,GAAG,CAAC;IACxB,IAAIpD,QAAQ,KAAK,MAAM,EAAE;MACvB,MAAMqD,OAAO,GAAG1C,UAAU,CAACS,kBAAkB,CAAC;MAC9C+B,eAAe,GAAGE,OAAO,GAAGd,MAAM;MAClCa,gBAAgB,GAAGC,OAAO,GAAGV,MAAM;IACrC;;IAEA;IACA,MAAMW,OAAO,GAAG7B,OAAO,CAAC8B,CAAC,GAAGN,qBAAqB,GAAGE,eAAe;IACnE,MAAMK,MAAM,GAAG/B,OAAO,CAACgC,CAAC,GAAGV,oBAAoB,GAAGK,gBAAgB;IAClE,MAAMM,QAAQ,GAAGJ,OAAO,GAAG7B,OAAO,CAACiB,KAAK,GAAG,CAAC,GAAGS,eAAe,GAAGF,qBAAqB,GAAGC,sBAAsB,GAAGL,cAAc;IAChI,MAAMc,SAAS,GAAGH,MAAM,GAAG/B,OAAO,CAACmB,MAAM,GAAG,CAAC,GAAGQ,gBAAgB,GAAGL,oBAAoB,GAAGC,uBAAuB,GAAGF,eAAe;IACnI9B,WAAW,CAAC4C,IAAI,GAAGpB,IAAI,CAACqB,GAAG,CAAC7C,WAAW,CAAC4C,IAAI,EAAEN,OAAO,CAAC;IACtDtC,WAAW,CAAC8C,GAAG,GAAGtB,IAAI,CAACqB,GAAG,CAAC7C,WAAW,CAAC8C,GAAG,EAAEN,MAAM,CAAC;IACnDxC,WAAW,CAAC+C,KAAK,GAAGvB,IAAI,CAACwB,GAAG,CAAChD,WAAW,CAAC+C,KAAK,EAAEL,QAAQ,CAAC;IACzD1C,WAAW,CAACiD,MAAM,GAAGzB,IAAI,CAACwB,GAAG,CAAChD,WAAW,CAACiD,MAAM,EAAEN,SAAS,CAAC;EAC9D,CAAC,CAAC;EACF,OAAO3C,WAAW;AACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}