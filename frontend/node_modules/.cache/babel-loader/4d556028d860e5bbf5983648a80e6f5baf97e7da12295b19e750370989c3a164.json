{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { clsx } from 'clsx';\nimport { BaseInput } from '@rc-component/input';\nimport TextArea from '@rc-component/textarea';\nimport toArray from \"@rc-component/util/es/Children/toArray\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport React, { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport useEffectState from \"./hooks/useEffectState\";\nimport KeywordTrigger from \"./KeywordTrigger\";\nimport MentionsContext from \"./MentionsContext\";\nimport Option from \"./Option\";\nimport { filterOption as defaultFilterOption, validateSearch as defaultValidateSearch, getBeforeSelectionText, getLastMeasureIndex, replaceWithMeasure, setInputSelection } from \"./util\";\nimport { UnstableContext } from \"./context\";\nconst InternalMentions = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    // Style\n    prefixCls,\n    className,\n    style,\n    classNames: mentionClassNames,\n    styles,\n    // Misc\n    prefix = '@',\n    split = ' ',\n    notFoundContent = 'Not Found',\n    value,\n    defaultValue,\n    children,\n    options,\n    allowClear,\n    hasWrapper,\n    silent,\n    // Events\n    validateSearch = defaultValidateSearch,\n    filterOption = defaultFilterOption,\n    onChange,\n    onKeyDown,\n    onKeyUp,\n    onPressEnter,\n    onSearch,\n    onSelect,\n    onFocus,\n    onBlur,\n    // Dropdown\n    transitionName,\n    placement,\n    direction,\n    getPopupContainer,\n    popupClassName,\n    rows = 1,\n    // Fix Warning: Received `false` for a non-boolean attribute `visible`.\n    // https://github.com/ant-design/ant-design/blob/df933e94efc8f376003bbdc658d64b64a0e53495/components/mentions/demo/render-panel.tsx\n    // @ts-expect-error\n    visible,\n    onPopupScroll,\n    // Rest\n    ...restProps\n  } = props;\n  const mergedPrefix = useMemo(() => Array.isArray(prefix) ? prefix : [prefix], [prefix]);\n\n  // =============================== Refs ===============================\n  const containerRef = useRef(null);\n  const textareaRef = useRef(null);\n  const measureRef = useRef(null);\n  const getTextArea = () => textareaRef.current?.resizableTextArea?.textArea;\n  React.useImperativeHandle(ref, () => ({\n    focus: () => textareaRef.current?.focus(),\n    blur: () => textareaRef.current?.blur(),\n    textarea: textareaRef.current?.resizableTextArea?.textArea,\n    nativeElement: containerRef.current\n  }));\n\n  // ============================== State ===============================\n  const [measuring, setMeasuring] = useState(false);\n  const [measureText, setMeasureText] = useState('');\n  const [measurePrefix, setMeasurePrefix] = useState('');\n  const [measureLocation, setMeasureLocation] = useState(0);\n  const [activeIndex, setActiveIndex] = useState(0);\n  const [isFocus, setIsFocus] = useState(false);\n\n  // ================================ Id ================================\n  const uniqueKey = useId(props.id);\n\n  // ============================== Value ===============================\n  const [mergedValue, setMergedValue] = useControlledState(defaultValue || '', value);\n\n  // =============================== Open ===============================\n  const {\n    open\n  } = useContext(UnstableContext);\n  useEffect(() => {\n    // Sync measure div top with textarea for rc-trigger usage\n    if (measuring && measureRef.current) {\n      measureRef.current.scrollTop = getTextArea().scrollTop;\n    }\n  }, [measuring]);\n  const [mergedMeasuring, mergedMeasureText, mergedMeasurePrefix, mergedMeasureLocation] = React.useMemo(() => {\n    if (open) {\n      for (let i = 0; i < mergedPrefix.length; i += 1) {\n        const curPrefix = mergedPrefix[i];\n        const index = mergedValue.lastIndexOf(curPrefix);\n        if (index >= 0) {\n          return [true, '', curPrefix, index];\n        }\n      }\n    }\n    return [measuring, measureText, measurePrefix, measureLocation];\n  }, [open, measuring, mergedPrefix, mergedValue, measureText, measurePrefix, measureLocation]);\n\n  // ============================== Option ==============================\n  const getOptions = React.useCallback(targetMeasureText => {\n    let list;\n    if (options && options.length > 0) {\n      list = options.map(item => ({\n        ...item,\n        key: `${item?.key ?? item.value}-${uniqueKey}`\n      }));\n    } else {\n      list = toArray(children).map(({\n        props: optionProps,\n        key\n      }) => ({\n        ...optionProps,\n        label: optionProps.children,\n        key: `${key || optionProps.value}-${uniqueKey}`\n      }));\n    }\n    return list.filter(option => {\n      /** Return all result if `filterOption` is false. */\n      if (filterOption === false) {\n        return true;\n      }\n      return filterOption(targetMeasureText, option);\n    });\n  }, [options, uniqueKey, children, filterOption]);\n  const mergedOptions = React.useMemo(() => getOptions(mergedMeasureText), [getOptions, mergedMeasureText]);\n\n  // ============================= Measure ==============================\n  // Mark that we will reset input selection to target position when user select option\n  const onSelectionEffect = useEffectState();\n  const startMeasure = (nextMeasureText, nextMeasurePrefix, nextMeasureLocation) => {\n    setMeasuring(true);\n    setMeasureText(nextMeasureText);\n    setMeasurePrefix(nextMeasurePrefix);\n    setMeasureLocation(nextMeasureLocation);\n    setActiveIndex(0);\n  };\n  const stopMeasure = callback => {\n    setMeasuring(false);\n    setMeasureLocation(0);\n    setMeasureText('');\n    onSelectionEffect(callback);\n  };\n\n  // ============================== Change ==============================\n  const triggerChange = nextValue => {\n    setMergedValue(nextValue);\n    onChange?.(nextValue);\n  };\n  const onInternalChange = ({\n    target: {\n      value: nextValue\n    }\n  }) => {\n    triggerChange(nextValue);\n  };\n  const selectOption = option => {\n    const {\n      value: mentionValue = ''\n    } = option;\n    const {\n      text,\n      selectionLocation\n    } = replaceWithMeasure(mergedValue, {\n      measureLocation: mergedMeasureLocation,\n      targetText: mentionValue,\n      prefix: mergedMeasurePrefix,\n      selectionStart: getTextArea()?.selectionStart,\n      split\n    });\n    triggerChange(text);\n    stopMeasure(() => {\n      // We need restore the selection position\n      setInputSelection(getTextArea(), selectionLocation);\n    });\n    onSelect?.(option, mergedMeasurePrefix);\n  };\n\n  // ============================= KeyEvent =============================\n  // Check if hit the measure keyword\n  const onInternalKeyDown = event => {\n    const {\n      which\n    } = event;\n    onKeyDown?.(event);\n\n    // Skip if not measuring\n    if (!mergedMeasuring) {\n      return;\n    }\n    if (which === KeyCode.UP || which === KeyCode.DOWN) {\n      // Control arrow function\n      const optionLen = mergedOptions.length;\n      const offset = which === KeyCode.UP ? -1 : 1;\n      const newActiveIndex = (activeIndex + offset + optionLen) % optionLen;\n      setActiveIndex(newActiveIndex);\n      event.preventDefault();\n    } else if (which === KeyCode.ESC) {\n      stopMeasure();\n    } else if (which === KeyCode.ENTER) {\n      // Measure hit\n      event.preventDefault();\n      // loading skip\n      if (silent) {\n        return;\n      }\n      if (!mergedOptions.length) {\n        stopMeasure();\n        return;\n      }\n      const option = mergedOptions[activeIndex];\n      selectOption(option);\n    }\n  };\n\n  /**\n   * When to start measure:\n   * 1. When user press `prefix`\n   * 2. When measureText !== prevMeasureText\n   *  - If measure hit\n   *  - If measuring\n   *\n   * When to stop measure:\n   * 1. Selection is out of range\n   * 2. Contains `space`\n   * 3. ESC or select one\n   */\n  const onInternalKeyUp = event => {\n    const {\n      key,\n      which\n    } = event;\n    const target = event.target;\n    const selectionStartText = getBeforeSelectionText(target);\n    const {\n      location: measureIndex,\n      prefix: nextMeasurePrefix\n    } = getLastMeasureIndex(selectionStartText, mergedPrefix);\n\n    // If the client implements an onKeyUp handler, call it\n    onKeyUp?.(event);\n\n    // Skip if match the white key list\n    if ([KeyCode.ESC, KeyCode.UP, KeyCode.DOWN, KeyCode.ENTER].indexOf(which) !== -1) {\n      return;\n    }\n    if (measureIndex !== -1) {\n      const nextMeasureText = selectionStartText.slice(measureIndex + nextMeasurePrefix.length);\n      const validateMeasure = validateSearch(nextMeasureText, split);\n      const matchOption = !!getOptions(nextMeasureText).length;\n      if (validateMeasure) {\n        // adding AltGraph also fort azert keyboard\n        if (key === nextMeasurePrefix || key === 'Shift' || which === KeyCode.ALT || key === 'AltGraph' || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) {\n          startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);\n        }\n      } else if (mergedMeasuring) {\n        // Stop if measureText is invalidate\n        stopMeasure();\n      }\n\n      /**\n       * We will trigger `onSearch` to developer since they may use for async update.\n       * If met `space` means user finished searching.\n       */\n      if (onSearch && validateMeasure) {\n        onSearch(nextMeasureText, nextMeasurePrefix);\n      }\n    } else if (mergedMeasuring) {\n      stopMeasure();\n    }\n  };\n  const onInternalPressEnter = event => {\n    if (!mergedMeasuring && onPressEnter) {\n      onPressEnter(event);\n    }\n  };\n\n  // ============================ Focus Blur ============================\n  const focusRef = useRef();\n  const onInternalFocus = event => {\n    window.clearTimeout(focusRef.current);\n    if (!isFocus && event && onFocus) {\n      onFocus(event);\n    }\n    setIsFocus(true);\n  };\n  const onInternalBlur = event => {\n    focusRef.current = window.setTimeout(() => {\n      setIsFocus(false);\n      stopMeasure();\n      onBlur?.(event);\n    }, 0);\n  };\n  const onDropdownFocus = () => {\n    onInternalFocus();\n  };\n  const onDropdownBlur = () => {\n    onInternalBlur();\n  };\n\n  // ============================== Scroll ===============================\n  const onInternalPopupScroll = event => {\n    onPopupScroll?.(event);\n  };\n\n  // ============================== Styles ==============================\n  const mergedStyles = React.useMemo(() => {\n    const resizeStyle = styles?.textarea?.resize ?? style?.resize;\n    const mergedTextareaStyle = {\n      ...styles?.textarea\n    };\n\n    // Only add resize if it has a valid value, avoid setting undefined\n    if (resizeStyle !== undefined) {\n      mergedTextareaStyle.resize = resizeStyle;\n    }\n    return {\n      ...styles,\n      textarea: mergedTextareaStyle\n    };\n  }, [style, styles]);\n\n  // ============================== Render ==============================\n\n  const mentionNode = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextArea, _extends({\n    classNames: {\n      textarea: mentionClassNames?.textarea\n    }\n    /**\n     * Example:<Mentions style={{ resize: 'none' }} />.\n     * If written this way, resizing here will become invalid.\n     * The TextArea component code and found that the resize parameter in the style of the ResizeTextArea component is obtained from prop.style.\n     * Just pass the resize attribute and leave everything else unchanged.\n     */,\n    styles: mergedStyles,\n    ref: textareaRef,\n    value: mergedValue\n  }, restProps, {\n    rows: rows,\n    onChange: onInternalChange,\n    onKeyDown: onInternalKeyDown,\n    onKeyUp: onInternalKeyUp,\n    onPressEnter: onInternalPressEnter,\n    onFocus: onInternalFocus,\n    onBlur: onInternalBlur\n  })), mergedMeasuring && /*#__PURE__*/React.createElement(\"div\", {\n    ref: measureRef,\n    className: `${prefixCls}-measure`\n  }, mergedValue.slice(0, mergedMeasureLocation), /*#__PURE__*/React.createElement(MentionsContext.Provider, {\n    value: {\n      notFoundContent,\n      activeIndex,\n      setActiveIndex,\n      selectOption,\n      onFocus: onDropdownFocus,\n      onBlur: onDropdownBlur,\n      onScroll: onInternalPopupScroll\n    }\n  }, /*#__PURE__*/React.createElement(KeywordTrigger, {\n    prefixCls: prefixCls,\n    transitionName: transitionName,\n    placement: placement,\n    direction: direction,\n    options: mergedOptions,\n    visible: true,\n    getPopupContainer: getPopupContainer,\n    popupClassName: clsx(popupClassName, mentionClassNames?.popup),\n    popupStyle: styles?.popup\n  }, /*#__PURE__*/React.createElement(\"span\", null, mergedMeasurePrefix))), mergedValue.slice(mergedMeasureLocation + mergedMeasurePrefix.length)));\n  if (!hasWrapper) {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className),\n      style: style,\n      ref: containerRef\n    }, mentionNode);\n  }\n  return mentionNode;\n});\nconst Mentions = /*#__PURE__*/forwardRef(({\n  suffix,\n  prefixCls = 'rc-mentions',\n  defaultValue,\n  value: customValue,\n  id,\n  allowClear,\n  onChange,\n  classNames: mentionsClassNames,\n  styles,\n  className,\n  disabled,\n  onClear,\n  ...rest\n}, ref) => {\n  const hasSuffix = !!(suffix || allowClear);\n\n  // =============================== Ref ================================\n  const holderRef = useRef(null);\n  const mentionRef = useRef(null);\n  useImperativeHandle(ref, () => ({\n    ...mentionRef.current,\n    nativeElement: holderRef.current?.nativeElement || mentionRef.current?.nativeElement\n  }));\n\n  // ============================== Value ===============================\n  const [mergedValue, setMergedValue] = useControlledState(defaultValue || '', customValue);\n\n  // ============================== Change ==============================\n  const triggerChange = currentValue => {\n    setMergedValue(currentValue);\n    onChange?.(currentValue);\n  };\n\n  // ============================== Reset ===============================\n  const handleReset = () => {\n    triggerChange('');\n  };\n  return /*#__PURE__*/React.createElement(BaseInput, {\n    suffix: suffix,\n    prefixCls: prefixCls,\n    value: mergedValue,\n    allowClear: allowClear,\n    handleReset: handleReset,\n    className: clsx(prefixCls, className, {\n      // hasSuffix\n      [`${prefixCls}-has-suffix`]: hasSuffix\n    }),\n    classNames: mentionsClassNames,\n    disabled: disabled,\n    ref: holderRef,\n    onClear: onClear\n  }, /*#__PURE__*/React.createElement(InternalMentions, _extends({\n    className: mentionsClassNames?.mentions,\n    styles: styles,\n    classNames: mentionsClassNames,\n    prefixCls: prefixCls,\n    id: id,\n    ref: mentionRef,\n    onChange: triggerChange,\n    disabled: disabled,\n    hasWrapper: hasSuffix\n  }, rest)));\n});\nMentions.Option = Option;\nexport default Mentions;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","BaseInput","TextArea","toArray","useControlledState","KeyCode","useId","React","forwardRef","useContext","useEffect","useImperativeHandle","useMemo","useRef","useState","useEffectState","KeywordTrigger","MentionsContext","Option","filterOption","defaultFilterOption","validateSearch","defaultValidateSearch","getBeforeSelectionText","getLastMeasureIndex","replaceWithMeasure","setInputSelection","UnstableContext","InternalMentions","props","ref","prefixCls","className","style","classNames","mentionClassNames","styles","prefix","split","notFoundContent","value","defaultValue","children","options","allowClear","hasWrapper","silent","onChange","onKeyDown","onKeyUp","onPressEnter","onSearch","onSelect","onFocus","onBlur","transitionName","placement","direction","getPopupContainer","popupClassName","rows","visible","onPopupScroll","restProps","mergedPrefix","Array","isArray","containerRef","textareaRef","measureRef","getTextArea","current","resizableTextArea","textArea","focus","blur","textarea","nativeElement","measuring","setMeasuring","measureText","setMeasureText","measurePrefix","setMeasurePrefix","measureLocation","setMeasureLocation","activeIndex","setActiveIndex","isFocus","setIsFocus","uniqueKey","id","mergedValue","setMergedValue","open","scrollTop","mergedMeasuring","mergedMeasureText","mergedMeasurePrefix","mergedMeasureLocation","curPrefix","index","lastIndexOf","getOptions","useCallback","targetMeasureText","list","map","item","optionProps","label","filter","option","mergedOptions","onSelectionEffect","startMeasure","nextMeasureText","nextMeasurePrefix","nextMeasureLocation","stopMeasure","callback","triggerChange","nextValue","onInternalChange","selectOption","mentionValue","text","selectionLocation","targetText","selectionStart","onInternalKeyDown","event","which","UP","DOWN","optionLen","offset","newActiveIndex","preventDefault","ESC","ENTER","onInternalKeyUp","selectionStartText","location","measureIndex","indexOf","slice","validateMeasure","matchOption","ALT","onInternalPressEnter","focusRef","onInternalFocus","window","clearTimeout","onInternalBlur","setTimeout","onDropdownFocus","onDropdownBlur","onInternalPopupScroll","mergedStyles","resizeStyle","resize","mergedTextareaStyle","undefined","mentionNode","createElement","Fragment","Provider","onScroll","popup","popupStyle","Mentions","suffix","customValue","mentionsClassNames","disabled","onClear","rest","hasSuffix","holderRef","mentionRef","currentValue","handleReset","mentions"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/mentions/es/Mentions.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport { clsx } from 'clsx';\nimport { BaseInput } from '@rc-component/input';\nimport TextArea from '@rc-component/textarea';\nimport toArray from \"@rc-component/util/es/Children/toArray\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport React, { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport useEffectState from \"./hooks/useEffectState\";\nimport KeywordTrigger from \"./KeywordTrigger\";\nimport MentionsContext from \"./MentionsContext\";\nimport Option from \"./Option\";\nimport { filterOption as defaultFilterOption, validateSearch as defaultValidateSearch, getBeforeSelectionText, getLastMeasureIndex, replaceWithMeasure, setInputSelection } from \"./util\";\nimport { UnstableContext } from \"./context\";\nconst InternalMentions = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    // Style\n    prefixCls,\n    className,\n    style,\n    classNames: mentionClassNames,\n    styles,\n    // Misc\n    prefix = '@',\n    split = ' ',\n    notFoundContent = 'Not Found',\n    value,\n    defaultValue,\n    children,\n    options,\n    allowClear,\n    hasWrapper,\n    silent,\n    // Events\n    validateSearch = defaultValidateSearch,\n    filterOption = defaultFilterOption,\n    onChange,\n    onKeyDown,\n    onKeyUp,\n    onPressEnter,\n    onSearch,\n    onSelect,\n    onFocus,\n    onBlur,\n    // Dropdown\n    transitionName,\n    placement,\n    direction,\n    getPopupContainer,\n    popupClassName,\n    rows = 1,\n    // Fix Warning: Received `false` for a non-boolean attribute `visible`.\n    // https://github.com/ant-design/ant-design/blob/df933e94efc8f376003bbdc658d64b64a0e53495/components/mentions/demo/render-panel.tsx\n    // @ts-expect-error\n    visible,\n    onPopupScroll,\n    // Rest\n    ...restProps\n  } = props;\n  const mergedPrefix = useMemo(() => Array.isArray(prefix) ? prefix : [prefix], [prefix]);\n\n  // =============================== Refs ===============================\n  const containerRef = useRef(null);\n  const textareaRef = useRef(null);\n  const measureRef = useRef(null);\n  const getTextArea = () => textareaRef.current?.resizableTextArea?.textArea;\n  React.useImperativeHandle(ref, () => ({\n    focus: () => textareaRef.current?.focus(),\n    blur: () => textareaRef.current?.blur(),\n    textarea: textareaRef.current?.resizableTextArea?.textArea,\n    nativeElement: containerRef.current\n  }));\n\n  // ============================== State ===============================\n  const [measuring, setMeasuring] = useState(false);\n  const [measureText, setMeasureText] = useState('');\n  const [measurePrefix, setMeasurePrefix] = useState('');\n  const [measureLocation, setMeasureLocation] = useState(0);\n  const [activeIndex, setActiveIndex] = useState(0);\n  const [isFocus, setIsFocus] = useState(false);\n\n  // ================================ Id ================================\n  const uniqueKey = useId(props.id);\n\n  // ============================== Value ===============================\n  const [mergedValue, setMergedValue] = useControlledState(defaultValue || '', value);\n\n  // =============================== Open ===============================\n  const {\n    open\n  } = useContext(UnstableContext);\n  useEffect(() => {\n    // Sync measure div top with textarea for rc-trigger usage\n    if (measuring && measureRef.current) {\n      measureRef.current.scrollTop = getTextArea().scrollTop;\n    }\n  }, [measuring]);\n  const [mergedMeasuring, mergedMeasureText, mergedMeasurePrefix, mergedMeasureLocation] = React.useMemo(() => {\n    if (open) {\n      for (let i = 0; i < mergedPrefix.length; i += 1) {\n        const curPrefix = mergedPrefix[i];\n        const index = mergedValue.lastIndexOf(curPrefix);\n        if (index >= 0) {\n          return [true, '', curPrefix, index];\n        }\n      }\n    }\n    return [measuring, measureText, measurePrefix, measureLocation];\n  }, [open, measuring, mergedPrefix, mergedValue, measureText, measurePrefix, measureLocation]);\n\n  // ============================== Option ==============================\n  const getOptions = React.useCallback(targetMeasureText => {\n    let list;\n    if (options && options.length > 0) {\n      list = options.map(item => ({\n        ...item,\n        key: `${item?.key ?? item.value}-${uniqueKey}`\n      }));\n    } else {\n      list = toArray(children).map(({\n        props: optionProps,\n        key\n      }) => ({\n        ...optionProps,\n        label: optionProps.children,\n        key: `${key || optionProps.value}-${uniqueKey}`\n      }));\n    }\n    return list.filter(option => {\n      /** Return all result if `filterOption` is false. */\n      if (filterOption === false) {\n        return true;\n      }\n      return filterOption(targetMeasureText, option);\n    });\n  }, [options, uniqueKey, children, filterOption]);\n  const mergedOptions = React.useMemo(() => getOptions(mergedMeasureText), [getOptions, mergedMeasureText]);\n\n  // ============================= Measure ==============================\n  // Mark that we will reset input selection to target position when user select option\n  const onSelectionEffect = useEffectState();\n  const startMeasure = (nextMeasureText, nextMeasurePrefix, nextMeasureLocation) => {\n    setMeasuring(true);\n    setMeasureText(nextMeasureText);\n    setMeasurePrefix(nextMeasurePrefix);\n    setMeasureLocation(nextMeasureLocation);\n    setActiveIndex(0);\n  };\n  const stopMeasure = callback => {\n    setMeasuring(false);\n    setMeasureLocation(0);\n    setMeasureText('');\n    onSelectionEffect(callback);\n  };\n\n  // ============================== Change ==============================\n  const triggerChange = nextValue => {\n    setMergedValue(nextValue);\n    onChange?.(nextValue);\n  };\n  const onInternalChange = ({\n    target: {\n      value: nextValue\n    }\n  }) => {\n    triggerChange(nextValue);\n  };\n  const selectOption = option => {\n    const {\n      value: mentionValue = ''\n    } = option;\n    const {\n      text,\n      selectionLocation\n    } = replaceWithMeasure(mergedValue, {\n      measureLocation: mergedMeasureLocation,\n      targetText: mentionValue,\n      prefix: mergedMeasurePrefix,\n      selectionStart: getTextArea()?.selectionStart,\n      split\n    });\n    triggerChange(text);\n    stopMeasure(() => {\n      // We need restore the selection position\n      setInputSelection(getTextArea(), selectionLocation);\n    });\n    onSelect?.(option, mergedMeasurePrefix);\n  };\n\n  // ============================= KeyEvent =============================\n  // Check if hit the measure keyword\n  const onInternalKeyDown = event => {\n    const {\n      which\n    } = event;\n    onKeyDown?.(event);\n\n    // Skip if not measuring\n    if (!mergedMeasuring) {\n      return;\n    }\n    if (which === KeyCode.UP || which === KeyCode.DOWN) {\n      // Control arrow function\n      const optionLen = mergedOptions.length;\n      const offset = which === KeyCode.UP ? -1 : 1;\n      const newActiveIndex = (activeIndex + offset + optionLen) % optionLen;\n      setActiveIndex(newActiveIndex);\n      event.preventDefault();\n    } else if (which === KeyCode.ESC) {\n      stopMeasure();\n    } else if (which === KeyCode.ENTER) {\n      // Measure hit\n      event.preventDefault();\n      // loading skip\n      if (silent) {\n        return;\n      }\n      if (!mergedOptions.length) {\n        stopMeasure();\n        return;\n      }\n      const option = mergedOptions[activeIndex];\n      selectOption(option);\n    }\n  };\n\n  /**\n   * When to start measure:\n   * 1. When user press `prefix`\n   * 2. When measureText !== prevMeasureText\n   *  - If measure hit\n   *  - If measuring\n   *\n   * When to stop measure:\n   * 1. Selection is out of range\n   * 2. Contains `space`\n   * 3. ESC or select one\n   */\n  const onInternalKeyUp = event => {\n    const {\n      key,\n      which\n    } = event;\n    const target = event.target;\n    const selectionStartText = getBeforeSelectionText(target);\n    const {\n      location: measureIndex,\n      prefix: nextMeasurePrefix\n    } = getLastMeasureIndex(selectionStartText, mergedPrefix);\n\n    // If the client implements an onKeyUp handler, call it\n    onKeyUp?.(event);\n\n    // Skip if match the white key list\n    if ([KeyCode.ESC, KeyCode.UP, KeyCode.DOWN, KeyCode.ENTER].indexOf(which) !== -1) {\n      return;\n    }\n    if (measureIndex !== -1) {\n      const nextMeasureText = selectionStartText.slice(measureIndex + nextMeasurePrefix.length);\n      const validateMeasure = validateSearch(nextMeasureText, split);\n      const matchOption = !!getOptions(nextMeasureText).length;\n      if (validateMeasure) {\n        // adding AltGraph also fort azert keyboard\n        if (key === nextMeasurePrefix || key === 'Shift' || which === KeyCode.ALT || key === 'AltGraph' || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) {\n          startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);\n        }\n      } else if (mergedMeasuring) {\n        // Stop if measureText is invalidate\n        stopMeasure();\n      }\n\n      /**\n       * We will trigger `onSearch` to developer since they may use for async update.\n       * If met `space` means user finished searching.\n       */\n      if (onSearch && validateMeasure) {\n        onSearch(nextMeasureText, nextMeasurePrefix);\n      }\n    } else if (mergedMeasuring) {\n      stopMeasure();\n    }\n  };\n  const onInternalPressEnter = event => {\n    if (!mergedMeasuring && onPressEnter) {\n      onPressEnter(event);\n    }\n  };\n\n  // ============================ Focus Blur ============================\n  const focusRef = useRef();\n  const onInternalFocus = event => {\n    window.clearTimeout(focusRef.current);\n    if (!isFocus && event && onFocus) {\n      onFocus(event);\n    }\n    setIsFocus(true);\n  };\n  const onInternalBlur = event => {\n    focusRef.current = window.setTimeout(() => {\n      setIsFocus(false);\n      stopMeasure();\n      onBlur?.(event);\n    }, 0);\n  };\n  const onDropdownFocus = () => {\n    onInternalFocus();\n  };\n  const onDropdownBlur = () => {\n    onInternalBlur();\n  };\n\n  // ============================== Scroll ===============================\n  const onInternalPopupScroll = event => {\n    onPopupScroll?.(event);\n  };\n\n  // ============================== Styles ==============================\n  const mergedStyles = React.useMemo(() => {\n    const resizeStyle = styles?.textarea?.resize ?? style?.resize;\n    const mergedTextareaStyle = {\n      ...styles?.textarea\n    };\n\n    // Only add resize if it has a valid value, avoid setting undefined\n    if (resizeStyle !== undefined) {\n      mergedTextareaStyle.resize = resizeStyle;\n    }\n    return {\n      ...styles,\n      textarea: mergedTextareaStyle\n    };\n  }, [style, styles]);\n\n  // ============================== Render ==============================\n\n  const mentionNode = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextArea, _extends({\n    classNames: {\n      textarea: mentionClassNames?.textarea\n    }\n    /**\n     * Example:<Mentions style={{ resize: 'none' }} />.\n     * If written this way, resizing here will become invalid.\n     * The TextArea component code and found that the resize parameter in the style of the ResizeTextArea component is obtained from prop.style.\n     * Just pass the resize attribute and leave everything else unchanged.\n     */,\n    styles: mergedStyles,\n    ref: textareaRef,\n    value: mergedValue\n  }, restProps, {\n    rows: rows,\n    onChange: onInternalChange,\n    onKeyDown: onInternalKeyDown,\n    onKeyUp: onInternalKeyUp,\n    onPressEnter: onInternalPressEnter,\n    onFocus: onInternalFocus,\n    onBlur: onInternalBlur\n  })), mergedMeasuring && /*#__PURE__*/React.createElement(\"div\", {\n    ref: measureRef,\n    className: `${prefixCls}-measure`\n  }, mergedValue.slice(0, mergedMeasureLocation), /*#__PURE__*/React.createElement(MentionsContext.Provider, {\n    value: {\n      notFoundContent,\n      activeIndex,\n      setActiveIndex,\n      selectOption,\n      onFocus: onDropdownFocus,\n      onBlur: onDropdownBlur,\n      onScroll: onInternalPopupScroll\n    }\n  }, /*#__PURE__*/React.createElement(KeywordTrigger, {\n    prefixCls: prefixCls,\n    transitionName: transitionName,\n    placement: placement,\n    direction: direction,\n    options: mergedOptions,\n    visible: true,\n    getPopupContainer: getPopupContainer,\n    popupClassName: clsx(popupClassName, mentionClassNames?.popup),\n    popupStyle: styles?.popup\n  }, /*#__PURE__*/React.createElement(\"span\", null, mergedMeasurePrefix))), mergedValue.slice(mergedMeasureLocation + mergedMeasurePrefix.length)));\n  if (!hasWrapper) {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className),\n      style: style,\n      ref: containerRef\n    }, mentionNode);\n  }\n  return mentionNode;\n});\nconst Mentions = /*#__PURE__*/forwardRef(({\n  suffix,\n  prefixCls = 'rc-mentions',\n  defaultValue,\n  value: customValue,\n  id,\n  allowClear,\n  onChange,\n  classNames: mentionsClassNames,\n  styles,\n  className,\n  disabled,\n  onClear,\n  ...rest\n}, ref) => {\n  const hasSuffix = !!(suffix || allowClear);\n\n  // =============================== Ref ================================\n  const holderRef = useRef(null);\n  const mentionRef = useRef(null);\n  useImperativeHandle(ref, () => ({\n    ...mentionRef.current,\n    nativeElement: holderRef.current?.nativeElement || mentionRef.current?.nativeElement\n  }));\n\n  // ============================== Value ===============================\n  const [mergedValue, setMergedValue] = useControlledState(defaultValue || '', customValue);\n\n  // ============================== Change ==============================\n  const triggerChange = currentValue => {\n    setMergedValue(currentValue);\n    onChange?.(currentValue);\n  };\n\n  // ============================== Reset ===============================\n  const handleReset = () => {\n    triggerChange('');\n  };\n  return /*#__PURE__*/React.createElement(BaseInput, {\n    suffix: suffix,\n    prefixCls: prefixCls,\n    value: mergedValue,\n    allowClear: allowClear,\n    handleReset: handleReset,\n    className: clsx(prefixCls, className, {\n      // hasSuffix\n      [`${prefixCls}-has-suffix`]: hasSuffix\n    }),\n    classNames: mentionsClassNames,\n    disabled: disabled,\n    ref: holderRef,\n    onClear: onClear\n  }, /*#__PURE__*/React.createElement(InternalMentions, _extends({\n    className: mentionsClassNames?.mentions,\n    styles: styles,\n    classNames: mentionsClassNames,\n    prefixCls: prefixCls,\n    id: id,\n    ref: mentionRef,\n    onChange: triggerChange,\n    disabled: disabled,\n    hasWrapper: hasSuffix\n  }, rest)));\n});\nMentions.Option = Option;\nexport default Mentions;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}