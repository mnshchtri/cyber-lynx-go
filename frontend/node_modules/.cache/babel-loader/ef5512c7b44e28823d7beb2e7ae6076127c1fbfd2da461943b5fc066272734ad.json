{"ast":null,"code":"import { merge } from \"@rc-component/util/es/utils/set\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch,\n        setBatchUpdate: this.setBatchUpdate\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  watchList = [];\n  registerWatch = callback => {\n    this.watchList.push(callback);\n    return () => {\n      this.watchList = this.watchList.filter(fn => fn !== callback);\n    };\n  };\n  notifyWatch = (namePath = []) => {\n    // No need to cost perf when nothing need to watch\n    if (this.watchList.length) {\n      const values = this.getFieldsValue();\n      const allValues = this.getFieldsValue(true);\n      this.watchList.forEach(callback => {\n        callback(values, allValues, namePath);\n      });\n    }\n  };\n  notifyWatchNamePathList = [];\n  batchNotifyWatch = namePath => {\n    this.notifyWatchNamePathList.push(namePath);\n    this.batch('notifyWatch', () => {\n      this.notifyWatch(this.notifyWatchNamePathList);\n      this.notifyWatchNamePathList = [];\n    });\n  };\n\n  // ============================= Batch ============================\n  batchUpdate;\n  setBatchUpdate = batchUpdate => {\n    this.batchUpdate = batchUpdate;\n  };\n\n  // Batch call the task, only last will be called\n  batch = (key, callback) => {\n    this.batchUpdate(key, callback);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  getFieldEntitiesForNamePathList = nameList => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    return nameList.map(name => {\n      const namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.batchNotifyWatch(namePath);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.batchNotifyWatch(namePath);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = merge(allValues, changedValues);\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;","map":{"version":3,"names":["merge","warning","React","HOOK_MARK","allPromiseFinish","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","FormStore","formHooked","forceRootUpdate","subscribable","store","fieldEntities","initialValues","callbacks","validateMessages","preserve","lastValidatePromise","constructor","getForm","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","setBatchUpdate","prevWithoutPreserves","init","nextStore","map","namePath","updateStore","clearOnDestroy","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","watchList","callback","push","filter","fn","notifyWatch","values","allValues","notifyWatchNamePathList","batchNotifyWatch","batch","batchUpdate","timeoutId","warningUnhooked","process","env","NODE_ENV","window","setTimeout","pure","field","getFieldsMap","cache","getFieldEntitiesForNamePathList","nameList","name","get","INVALIDATE_NAME_PATH","filterFunc","mergedNameList","mergedFilterFunc","Array","isArray","filteredNameList","listNamePaths","isList","meta","getMeta","mergedValues","index","errors","getErrors","warnings","getWarnings","fieldError","args","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","isNamePathListTouched","entities","namePathListEntities","value","testField","resetWithFieldInitialValue","info","initialValue","props","undefined","records","Set","add","resetWithFields","formInitialValue","join","size","originValue","isListField","skipExist","requiredFieldEntities","r","prevStore","notifyObservers","type","fields","fieldData","data","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","source","subNamePath","item","defaultValue","triggerDependenciesUpdate","action","updateValue","triggerName","mergedInfo","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","changedValues","mergedAllValues","triggerOnFieldsChange","touched","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","changedFields","fieldName","arg2","options","provideNameList","finalValueNamePathList","promiseList","TMP_SPLIT","String","Date","now","validateNamePathList","recursive","dirty","rules","promise","validateRules","then","catch","ruleErrors","mergedErrors","mergedWarnings","rule","warningOnly","Promise","reject","summaryPromise","results","resultNamePathList","returnPromise","resolve","errorList","result","errorMessage","message","errorFields","outOfDate","e","triggerNamePathList","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","forceUpdate","useState","current","forceReRender","formStore"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/form/es/useForm.js"],"sourcesContent":["import { merge } from \"@rc-component/util/es/utils/set\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch,\n        setBatchUpdate: this.setBatchUpdate\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  watchList = [];\n  registerWatch = callback => {\n    this.watchList.push(callback);\n    return () => {\n      this.watchList = this.watchList.filter(fn => fn !== callback);\n    };\n  };\n  notifyWatch = (namePath = []) => {\n    // No need to cost perf when nothing need to watch\n    if (this.watchList.length) {\n      const values = this.getFieldsValue();\n      const allValues = this.getFieldsValue(true);\n      this.watchList.forEach(callback => {\n        callback(values, allValues, namePath);\n      });\n    }\n  };\n  notifyWatchNamePathList = [];\n  batchNotifyWatch = namePath => {\n    this.notifyWatchNamePathList.push(namePath);\n    this.batch('notifyWatch', () => {\n      this.notifyWatch(this.notifyWatchNamePathList);\n      this.notifyWatchNamePathList = [];\n    });\n  };\n\n  // ============================= Batch ============================\n  batchUpdate;\n  setBatchUpdate = batchUpdate => {\n    this.batchUpdate = batchUpdate;\n  };\n\n  // Batch call the task, only last will be called\n  batch = (key, callback) => {\n    this.batchUpdate(key, callback);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  getFieldEntitiesForNamePathList = nameList => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    return nameList.map(name => {\n      const namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.batchNotifyWatch(namePath);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.batchNotifyWatch(namePath);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = merge(allValues, changedValues);\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"mappings":"AAAA,SAASA,KAAK,QAAQ,iCAAiC;AACvD,OAAOC,OAAO,MAAM,+BAA+B;AACnD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,gBAAgB,QAAQ,mBAAmB;AACpD,SAASC,uBAAuB,QAAQ,kBAAkB;AAC1D,OAAOC,OAAO,MAAM,iBAAiB;AACrC,SAASC,mBAAmB,EAAEC,gBAAgB,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,QAAQ,QAAQ,mBAAmB;AACzH,OAAO,MAAMC,SAAS,CAAC;EACrBC,UAAU,GAAG,KAAK;EAClBC,eAAe;EACfC,YAAY,GAAG,IAAI;EACnBC,KAAK,GAAG,CAAC,CAAC;EACVC,aAAa,GAAG,EAAE;EAClBC,aAAa,GAAG,CAAC,CAAC;EAClBC,SAAS,GAAG,CAAC,CAAC;EACdC,gBAAgB,GAAG,IAAI;EACvBC,QAAQ,GAAG,IAAI;EACfC,mBAAmB,GAAG,IAAI;EAC1BC,WAAWA,CAACT,eAAe,EAAE;IAC3B,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;EACAU,OAAO,GAAGA,CAAA,MAAO;IACfC,aAAa,EAAE,IAAI,CAACA,aAAa;IACjCC,cAAc,EAAE,IAAI,CAACA,cAAc;IACnCC,aAAa,EAAE,IAAI,CAACA,aAAa;IACjCC,eAAe,EAAE,IAAI,CAACA,eAAe;IACrCC,cAAc,EAAE,IAAI,CAACA,cAAc;IACnCC,eAAe,EAAE,IAAI,CAACA,eAAe;IACrCC,cAAc,EAAE,IAAI,CAACA,cAAc;IACnCC,iBAAiB,EAAE,IAAI,CAACA,iBAAiB;IACzCC,kBAAkB,EAAE,IAAI,CAACA,kBAAkB;IAC3CC,WAAW,EAAE,IAAI,CAACA,WAAW;IAC7BC,SAAS,EAAE,IAAI,CAACA,SAAS;IACzBC,aAAa,EAAE,IAAI,CAACA,aAAa;IACjCC,cAAc,EAAE,IAAI,CAACA,cAAc;IACnCC,cAAc,EAAE,IAAI,CAACA,cAAc;IACnCC,MAAM,EAAE,IAAI,CAACA,MAAM;IACnBC,KAAK,EAAE,IAAI;IACXC,gBAAgB,EAAE,IAAI,CAACA;EACzB,CAAC,CAAC;;EAEF;EACAA,gBAAgB,GAAGC,GAAG,IAAI;IACxB,IAAIA,GAAG,KAAKxC,SAAS,EAAE;MACrB,IAAI,CAACW,UAAU,GAAG,IAAI;MACtB,OAAO;QACL8B,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvBC,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCC,aAAa,EAAE,IAAI,CAACA,aAAa;QACjCC,YAAY,EAAE,IAAI,CAACA,YAAY;QAC/BC,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;QACvCC,WAAW,EAAE,IAAI,CAACA,WAAW;QAC7BC,YAAY,EAAE,IAAI,CAACA,YAAY;QAC/BC,mBAAmB,EAAE,IAAI,CAACA,mBAAmB;QAC7CC,SAAS,EAAE,IAAI,CAACA,SAAS;QACzBC,WAAW,EAAE,IAAI,CAACA,WAAW;QAC7BC,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCC,aAAa,EAAE,IAAI,CAACA,aAAa;QACjCC,cAAc,EAAE,IAAI,CAACA;MACvB,CAAC;IACH;IACAvD,OAAO,CAAC,KAAK,EAAE,iEAAiE,CAAC;IACjF,OAAO,IAAI;EACb,CAAC;EACD8C,YAAY,GAAG/B,YAAY,IAAI;IAC7B,IAAI,CAACA,YAAY,GAAGA,YAAY;EAClC,CAAC;;EAED;AACF;AACA;AACA;EACEyC,oBAAoB,GAAG,IAAI;;EAE3B;AACF;AACA;EACET,gBAAgB,GAAGA,CAAC7B,aAAa,EAAEuC,IAAI,KAAK;IAC1C,IAAI,CAACvC,aAAa,GAAGA,aAAa,IAAI,CAAC,CAAC;IACxC,IAAIuC,IAAI,EAAE;MACR,IAAIC,SAAS,GAAG3D,KAAK,CAACmB,aAAa,EAAE,IAAI,CAACF,KAAK,CAAC;;MAEhD;MACA;MACA;MACA,IAAI,CAACwC,oBAAoB,EAAEG,GAAG,CAAC,CAAC;QAC9BjB,GAAG,EAAEkB;MACP,CAAC,KAAK;QACJF,SAAS,GAAG/C,QAAQ,CAAC+C,SAAS,EAAEE,QAAQ,EAAEnD,QAAQ,CAACS,aAAa,EAAE0C,QAAQ,CAAC,CAAC;MAC9E,CAAC,CAAC;MACF,IAAI,CAACJ,oBAAoB,GAAG,IAAI;MAChC,IAAI,CAACK,WAAW,CAACH,SAAS,CAAC;IAC7B;EACF,CAAC;EACDV,WAAW,GAAGc,cAAc,IAAI;IAC9B,IAAIA,cAAc,EAAE;MAClB;MACA,IAAI,CAACD,WAAW,CAAC,CAAC,CAAC,CAAC;IACtB,CAAC,MAAM;MACL;MACA,MAAML,oBAAoB,GAAG,IAAInD,OAAO,CAAC,CAAC;MAC1C,IAAI,CAAC0D,gBAAgB,CAAC,IAAI,CAAC,CAACC,OAAO,CAACC,MAAM,IAAI;QAC5C,IAAI,CAAC,IAAI,CAACC,gBAAgB,CAACD,MAAM,CAACE,UAAU,CAAC,CAAC,CAAC,EAAE;UAC/CX,oBAAoB,CAACY,GAAG,CAACH,MAAM,CAACzD,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC;QACtD;MACF,CAAC,CAAC;MACF,IAAI,CAACgD,oBAAoB,GAAGA,oBAAoB;IAClD;EACF,CAAC;EACDH,eAAe,GAAGO,QAAQ,IAAI;IAC5B,MAAMS,SAAS,GAAG5D,QAAQ,CAAC,IAAI,CAACS,aAAa,EAAE0C,QAAQ,CAAC;;IAExD;IACA,OAAOA,QAAQ,CAACU,MAAM,GAAGvE,KAAK,CAACsE,SAAS,CAAC,GAAGA,SAAS;EACvD,CAAC;EACDpB,YAAY,GAAG9B,SAAS,IAAI;IAC1B,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC5B,CAAC;EACD+B,mBAAmB,GAAG9B,gBAAgB,IAAI;IACxC,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;EAC1C,CAAC;EACDgC,WAAW,GAAG/B,QAAQ,IAAI;IACxB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B,CAAC;;EAED;EACAkD,SAAS,GAAG,EAAE;EACdjB,aAAa,GAAGkB,QAAQ,IAAI;IAC1B,IAAI,CAACD,SAAS,CAACE,IAAI,CAACD,QAAQ,CAAC;IAC7B,OAAO,MAAM;MACX,IAAI,CAACD,SAAS,GAAG,IAAI,CAACA,SAAS,CAACG,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKH,QAAQ,CAAC;IAC/D,CAAC;EACH,CAAC;EACDI,WAAW,GAAGA,CAAChB,QAAQ,GAAG,EAAE,KAAK;IAC/B;IACA,IAAI,IAAI,CAACW,SAAS,CAACD,MAAM,EAAE;MACzB,MAAMO,MAAM,GAAG,IAAI,CAACnD,cAAc,CAAC,CAAC;MACpC,MAAMoD,SAAS,GAAG,IAAI,CAACpD,cAAc,CAAC,IAAI,CAAC;MAC3C,IAAI,CAAC6C,SAAS,CAACP,OAAO,CAACQ,QAAQ,IAAI;QACjCA,QAAQ,CAACK,MAAM,EAAEC,SAAS,EAAElB,QAAQ,CAAC;MACvC,CAAC,CAAC;IACJ;EACF,CAAC;EACDmB,uBAAuB,GAAG,EAAE;EAC5BC,gBAAgB,GAAGpB,QAAQ,IAAI;IAC7B,IAAI,CAACmB,uBAAuB,CAACN,IAAI,CAACb,QAAQ,CAAC;IAC3C,IAAI,CAACqB,KAAK,CAAC,aAAa,EAAE,MAAM;MAC9B,IAAI,CAACL,WAAW,CAAC,IAAI,CAACG,uBAAuB,CAAC;MAC9C,IAAI,CAACA,uBAAuB,GAAG,EAAE;IACnC,CAAC,CAAC;EACJ,CAAC;;EAED;EACAG,WAAW;EACX3B,cAAc,GAAG2B,WAAW,IAAI;IAC9B,IAAI,CAACA,WAAW,GAAGA,WAAW;EAChC,CAAC;;EAED;EACAD,KAAK,GAAGA,CAACvC,GAAG,EAAE8B,QAAQ,KAAK;IACzB,IAAI,CAACU,WAAW,CAACxC,GAAG,EAAE8B,QAAQ,CAAC;EACjC,CAAC;;EAED;EACAW,SAAS,GAAG,IAAI;EAChBC,eAAe,GAAGA,CAAA,KAAM;IACtB,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAI,CAAC,IAAI,CAACJ,SAAS,IAAI,OAAOK,MAAM,KAAK,WAAW,EAAE;MAC7F,IAAI,CAACL,SAAS,GAAGM,UAAU,CAAC,MAAM;QAChC,IAAI,CAACN,SAAS,GAAG,IAAI;QACrB,IAAI,CAAC,IAAI,CAACtE,UAAU,EAAE;UACpBb,OAAO,CAAC,KAAK,EAAE,iGAAiG,CAAC;QACnH;MACF,CAAC,CAAC;IACJ;EACF,CAAC;;EAED;EACA6D,WAAW,GAAGH,SAAS,IAAI;IACzB,IAAI,CAAC1C,KAAK,GAAG0C,SAAS;EACxB,CAAC;;EAED;EACA;AACF;AACA;AACA;EACEK,gBAAgB,GAAGA,CAAC2B,IAAI,GAAG,KAAK,KAAK;IACnC,IAAI,CAACA,IAAI,EAAE;MACT,OAAO,IAAI,CAACzE,aAAa;IAC3B;IACA,OAAO,IAAI,CAACA,aAAa,CAACyD,MAAM,CAACiB,KAAK,IAAIA,KAAK,CAACnF,WAAW,CAAC,CAAC,CAAC8D,MAAM,CAAC;EACvE,CAAC;EACDsB,YAAY,GAAGA,CAACF,IAAI,GAAG,KAAK,KAAK;IAC/B,MAAMG,KAAK,GAAG,IAAIxF,OAAO,CAAC,CAAC;IAC3B,IAAI,CAAC0D,gBAAgB,CAAC2B,IAAI,CAAC,CAAC1B,OAAO,CAAC2B,KAAK,IAAI;MAC3C,MAAM/B,QAAQ,GAAG+B,KAAK,CAACnF,WAAW,CAAC,CAAC;MACpCqF,KAAK,CAACzB,GAAG,CAACR,QAAQ,EAAE+B,KAAK,CAAC;IAC5B,CAAC,CAAC;IACF,OAAOE,KAAK;EACd,CAAC;EACDC,+BAA+B,GAAGC,QAAQ,IAAI;IAC5C,IAAI,CAACA,QAAQ,EAAE;MACb,OAAO,IAAI,CAAChC,gBAAgB,CAAC,IAAI,CAAC;IACpC;IACA,MAAM8B,KAAK,GAAG,IAAI,CAACD,YAAY,CAAC,IAAI,CAAC;IACrC,OAAOG,QAAQ,CAACpC,GAAG,CAACqC,IAAI,IAAI;MAC1B,MAAMpC,QAAQ,GAAGpD,WAAW,CAACwF,IAAI,CAAC;MAClC,OAAOH,KAAK,CAACI,GAAG,CAACrC,QAAQ,CAAC,IAAI;QAC5BsC,oBAAoB,EAAE1F,WAAW,CAACwF,IAAI;MACxC,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;EACDtE,cAAc,GAAGA,CAACqE,QAAQ,EAAEI,UAAU,KAAK;IACzC,IAAI,CAACf,eAAe,CAAC,CAAC;;IAEtB;IACA,IAAIgB,cAAc;IAClB,IAAIC,gBAAgB;IACpB,IAAIN,QAAQ,KAAK,IAAI,IAAIO,KAAK,CAACC,OAAO,CAACR,QAAQ,CAAC,EAAE;MAChDK,cAAc,GAAGL,QAAQ;MACzBM,gBAAgB,GAAGF,UAAU;IAC/B,CAAC,MAAM,IAAIJ,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;MACnDM,gBAAgB,GAAGN,QAAQ,CAACrB,MAAM;IACpC;IACA,IAAI0B,cAAc,KAAK,IAAI,IAAI,CAACC,gBAAgB,EAAE;MAChD,OAAO,IAAI,CAACrF,KAAK;IACnB;IACA,MAAMC,aAAa,GAAG,IAAI,CAAC6E,+BAA+B,CAACQ,KAAK,CAACC,OAAO,CAACH,cAAc,CAAC,GAAGA,cAAc,GAAG,IAAI,CAAC;IACjH,MAAMI,gBAAgB,GAAG,EAAE;IAC3B,MAAMC,aAAa,GAAG,EAAE;IACxBxF,aAAa,CAAC+C,OAAO,CAACC,MAAM,IAAI;MAC9B,MAAML,QAAQ,GAAGK,MAAM,CAACiC,oBAAoB,IAAIjC,MAAM,CAACzD,WAAW,CAAC,CAAC;;MAEpE;MACA;MACA,IAAIyD,MAAM,CAACyC,MAAM,GAAG,CAAC,EAAE;QACrBD,aAAa,CAAChC,IAAI,CAACb,QAAQ,CAAC;QAC5B;MACF;MACA,IAAI,CAACyC,gBAAgB,EAAE;QACrBG,gBAAgB,CAAC/B,IAAI,CAACb,QAAQ,CAAC;MACjC,CAAC,MAAM;QACL,MAAM+C,IAAI,GAAG,SAAS,IAAI1C,MAAM,GAAGA,MAAM,CAAC2C,OAAO,CAAC,CAAC,GAAG,IAAI;QAC1D,IAAIP,gBAAgB,CAACM,IAAI,CAAC,EAAE;UAC1BH,gBAAgB,CAAC/B,IAAI,CAACb,QAAQ,CAAC;QACjC;MACF;IACF,CAAC,CAAC;IACF,IAAIiD,YAAY,GAAGvG,mBAAmB,CAAC,IAAI,CAACU,KAAK,EAAEwF,gBAAgB,CAAC7C,GAAG,CAACnD,WAAW,CAAC,CAAC;;IAErF;IACAiG,aAAa,CAACzC,OAAO,CAACJ,QAAQ,IAAI;MAChC,IAAI,CAACnD,QAAQ,CAACoG,YAAY,EAAEjD,QAAQ,CAAC,EAAE;QACrCiD,YAAY,GAAGlG,QAAQ,CAACkG,YAAY,EAAEjD,QAAQ,EAAE,EAAE,CAAC;MACrD;IACF,CAAC,CAAC;IACF,OAAOiD,YAAY;EACrB,CAAC;EACDpF,aAAa,GAAGuE,IAAI,IAAI;IACtB,IAAI,CAACZ,eAAe,CAAC,CAAC;IACtB,MAAMxB,QAAQ,GAAGpD,WAAW,CAACwF,IAAI,CAAC;IAClC,OAAOvF,QAAQ,CAAC,IAAI,CAACO,KAAK,EAAE4C,QAAQ,CAAC;EACvC,CAAC;EACD/B,cAAc,GAAGkE,QAAQ,IAAI;IAC3B,IAAI,CAACX,eAAe,CAAC,CAAC;IACtB,MAAMnE,aAAa,GAAG,IAAI,CAAC6E,+BAA+B,CAACC,QAAQ,CAAC;IACpE,OAAO9E,aAAa,CAAC0C,GAAG,CAAC,CAACM,MAAM,EAAE6C,KAAK,KAAK;MAC1C,IAAI7C,MAAM,IAAI,CAACA,MAAM,CAACiC,oBAAoB,EAAE;QAC1C,OAAO;UACLF,IAAI,EAAE/B,MAAM,CAACzD,WAAW,CAAC,CAAC;UAC1BuG,MAAM,EAAE9C,MAAM,CAAC+C,SAAS,CAAC,CAAC;UAC1BC,QAAQ,EAAEhD,MAAM,CAACiD,WAAW,CAAC;QAC/B,CAAC;MACH;MACA,OAAO;QACLlB,IAAI,EAAExF,WAAW,CAACuF,QAAQ,CAACe,KAAK,CAAC,CAAC;QAClCC,MAAM,EAAE,EAAE;QACVE,QAAQ,EAAE;MACZ,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;EACDtF,aAAa,GAAGqE,IAAI,IAAI;IACtB,IAAI,CAACZ,eAAe,CAAC,CAAC;IACtB,MAAMxB,QAAQ,GAAGpD,WAAW,CAACwF,IAAI,CAAC;IAClC,MAAMmB,UAAU,GAAG,IAAI,CAACtF,cAAc,CAAC,CAAC+B,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IACrD,OAAOuD,UAAU,CAACJ,MAAM;EAC1B,CAAC;EACDnF,eAAe,GAAGoE,IAAI,IAAI;IACxB,IAAI,CAACZ,eAAe,CAAC,CAAC;IACtB,MAAMxB,QAAQ,GAAGpD,WAAW,CAACwF,IAAI,CAAC;IAClC,MAAMmB,UAAU,GAAG,IAAI,CAACtF,cAAc,CAAC,CAAC+B,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IACrD,OAAOuD,UAAU,CAACF,QAAQ;EAC5B,CAAC;EACDnF,eAAe,GAAGA,CAAC,GAAGsF,IAAI,KAAK;IAC7B,IAAI,CAAChC,eAAe,CAAC,CAAC;IACtB,MAAM,CAACiC,IAAI,EAAEC,IAAI,CAAC,GAAGF,IAAI;IACzB,IAAIG,YAAY;IAChB,IAAIC,kBAAkB,GAAG,KAAK;IAC9B,IAAIJ,IAAI,CAAC9C,MAAM,KAAK,CAAC,EAAE;MACrBiD,YAAY,GAAG,IAAI;IACrB,CAAC,MAAM,IAAIH,IAAI,CAAC9C,MAAM,KAAK,CAAC,EAAE;MAC5B,IAAIgC,KAAK,CAACC,OAAO,CAACc,IAAI,CAAC,EAAE;QACvBE,YAAY,GAAGF,IAAI,CAAC1D,GAAG,CAACnD,WAAW,CAAC;QACpCgH,kBAAkB,GAAG,KAAK;MAC5B,CAAC,MAAM;QACLD,YAAY,GAAG,IAAI;QACnBC,kBAAkB,GAAGH,IAAI;MAC3B;IACF,CAAC,MAAM;MACLE,YAAY,GAAGF,IAAI,CAAC1D,GAAG,CAACnD,WAAW,CAAC;MACpCgH,kBAAkB,GAAGF,IAAI;IAC3B;IACA,MAAMrG,aAAa,GAAG,IAAI,CAAC8C,gBAAgB,CAAC,IAAI,CAAC;IACjD,MAAMhC,cAAc,GAAG4D,KAAK,IAAIA,KAAK,CAAC5D,cAAc,CAAC,CAAC;;IAEtD;IACA,IAAI,CAACwF,YAAY,EAAE;MACjB,OAAOC,kBAAkB,GAAGvG,aAAa,CAACwG,KAAK,CAACxD,MAAM,IAAIlC,cAAc,CAACkC,MAAM,CAAC,IAAIA,MAAM,CAACyC,MAAM,CAAC,CAAC,CAAC,GAAGzF,aAAa,CAACyG,IAAI,CAAC3F,cAAc,CAAC;IAC3I;;IAEA;IACA,MAAM4B,GAAG,GAAG,IAAItD,OAAO,CAAC,CAAC;IACzBkH,YAAY,CAACvD,OAAO,CAAC2D,aAAa,IAAI;MACpChE,GAAG,CAACS,GAAG,CAACuD,aAAa,EAAE,EAAE,CAAC;IAC5B,CAAC,CAAC;IACF1G,aAAa,CAAC+C,OAAO,CAAC2B,KAAK,IAAI;MAC7B,MAAMiC,aAAa,GAAGjC,KAAK,CAACnF,WAAW,CAAC,CAAC;;MAEzC;MACA+G,YAAY,CAACvD,OAAO,CAAC2D,aAAa,IAAI;QACpC,IAAIA,aAAa,CAACF,KAAK,CAAC,CAACI,QAAQ,EAAEC,CAAC,KAAKF,aAAa,CAACE,CAAC,CAAC,KAAKD,QAAQ,CAAC,EAAE;UACvElE,GAAG,CAACoE,MAAM,CAACJ,aAAa,EAAEK,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAErC,KAAK,CAAC,CAAC;QACrD;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACA,MAAMsC,qBAAqB,GAAGC,QAAQ,IAAIA,QAAQ,CAACR,IAAI,CAAC3F,cAAc,CAAC;IACvE,MAAMoG,oBAAoB,GAAGxE,GAAG,CAACA,GAAG,CAAC,CAAC;MACpCyE;IACF,CAAC,KAAKA,KAAK,CAAC;IACZ,OAAOZ,kBAAkB,GAAGW,oBAAoB,CAACV,KAAK,CAACQ,qBAAqB,CAAC,GAAGE,oBAAoB,CAACT,IAAI,CAACO,qBAAqB,CAAC;EAClI,CAAC;EACDlG,cAAc,GAAGiE,IAAI,IAAI;IACvB,IAAI,CAACZ,eAAe,CAAC,CAAC;IACtB,OAAO,IAAI,CAACtD,eAAe,CAAC,CAACkE,IAAI,CAAC,CAAC;EACrC,CAAC;EACD/D,kBAAkB,GAAG8D,QAAQ,IAAI;IAC/B,IAAI,CAACX,eAAe,CAAC,CAAC;IACtB,MAAMnE,aAAa,GAAG,IAAI,CAAC8C,gBAAgB,CAAC,CAAC;IAC7C,IAAI,CAACgC,QAAQ,EAAE;MACb,OAAO9E,aAAa,CAACyG,IAAI,CAACW,SAAS,IAAIA,SAAS,CAACrG,iBAAiB,CAAC,CAAC,CAAC;IACvE;IACA,MAAMuF,YAAY,GAAGxB,QAAQ,CAACpC,GAAG,CAACnD,WAAW,CAAC;IAC9C,OAAOS,aAAa,CAACyG,IAAI,CAACW,SAAS,IAAI;MACrC,MAAMT,aAAa,GAAGS,SAAS,CAAC7H,WAAW,CAAC,CAAC;MAC7C,OAAOD,gBAAgB,CAACgH,YAAY,EAAEK,aAAa,CAAC,IAAIS,SAAS,CAACrG,iBAAiB,CAAC,CAAC;IACvF,CAAC,CAAC;EACJ,CAAC;EACDA,iBAAiB,GAAGgE,IAAI,IAAI;IAC1B,IAAI,CAACZ,eAAe,CAAC,CAAC;IACtB,OAAO,IAAI,CAACnD,kBAAkB,CAAC,CAAC+D,IAAI,CAAC,CAAC;EACxC,CAAC;;EAED;AACF;AACA;AACA;EACEsC,0BAA0B,GAAGA,CAACC,IAAI,GAAG,CAAC,CAAC,KAAK;IAC1C;IACA,MAAM1C,KAAK,GAAG,IAAIxF,OAAO,CAAC,CAAC;IAC3B,MAAMY,aAAa,GAAG,IAAI,CAAC8C,gBAAgB,CAAC,IAAI,CAAC;IACjD9C,aAAa,CAAC+C,OAAO,CAAC2B,KAAK,IAAI;MAC7B,MAAM;QACJ6C;MACF,CAAC,GAAG7C,KAAK,CAAC8C,KAAK;MACf,MAAM7E,QAAQ,GAAG+B,KAAK,CAACnF,WAAW,CAAC,CAAC;;MAEpC;MACA,IAAIgI,YAAY,KAAKE,SAAS,EAAE;QAC9B,MAAMC,OAAO,GAAG9C,KAAK,CAACI,GAAG,CAACrC,QAAQ,CAAC,IAAI,IAAIgF,GAAG,CAAC,CAAC;QAChDD,OAAO,CAACE,GAAG,CAAC;UACV5E,MAAM,EAAE0B,KAAK;UACbyC,KAAK,EAAEI;QACT,CAAC,CAAC;QACF3C,KAAK,CAACzB,GAAG,CAACR,QAAQ,EAAE+E,OAAO,CAAC;MAC9B;IACF,CAAC,CAAC;;IAEF;IACA,MAAMG,eAAe,GAAGZ,QAAQ,IAAI;MAClCA,QAAQ,CAAClE,OAAO,CAAC2B,KAAK,IAAI;QACxB,MAAM;UACJ6C;QACF,CAAC,GAAG7C,KAAK,CAAC8C,KAAK;QACf,IAAID,YAAY,KAAKE,SAAS,EAAE;UAC9B,MAAM9E,QAAQ,GAAG+B,KAAK,CAACnF,WAAW,CAAC,CAAC;UACpC,MAAMuI,gBAAgB,GAAG,IAAI,CAAC1F,eAAe,CAACO,QAAQ,CAAC;UACvD,IAAImF,gBAAgB,KAAKL,SAAS,EAAE;YAClC;YACA1I,OAAO,CAAC,KAAK,EAAE,+CAA+C4D,QAAQ,CAACoF,IAAI,CAAC,GAAG,CAAC,gCAAgC,CAAC;UACnH,CAAC,MAAM;YACL,MAAML,OAAO,GAAG9C,KAAK,CAACI,GAAG,CAACrC,QAAQ,CAAC;YACnC,IAAI+E,OAAO,IAAIA,OAAO,CAACM,IAAI,GAAG,CAAC,EAAE;cAC/B;cACAjJ,OAAO,CAAC,KAAK,EAAE,6BAA6B4D,QAAQ,CAACoF,IAAI,CAAC,GAAG,CAAC,yDAAyD,CAAC;YAC1H,CAAC,MAAM,IAAIL,OAAO,EAAE;cAClB,MAAMO,WAAW,GAAG,IAAI,CAACzH,aAAa,CAACmC,QAAQ,CAAC;cAChD,MAAMuF,WAAW,GAAGxD,KAAK,CAACwD,WAAW,CAAC,CAAC;;cAEvC;cACA,IAAI,CAACA,WAAW,KAAK,CAACZ,IAAI,CAACa,SAAS,IAAIF,WAAW,KAAKR,SAAS,CAAC,EAAE;gBAClE,IAAI,CAAC7E,WAAW,CAAClD,QAAQ,CAAC,IAAI,CAACK,KAAK,EAAE4C,QAAQ,EAAE,CAAC,GAAG+E,OAAO,CAAC,CAAC,CAAC,CAAC,CAACP,KAAK,CAAC,CAAC;cACzE;YACF;UACF;QACF;MACF,CAAC,CAAC;IACJ,CAAC;IACD,IAAIiB,qBAAqB;IACzB,IAAId,IAAI,CAACL,QAAQ,EAAE;MACjBmB,qBAAqB,GAAGd,IAAI,CAACL,QAAQ;IACvC,CAAC,MAAM,IAAIK,IAAI,CAAChB,YAAY,EAAE;MAC5B8B,qBAAqB,GAAG,EAAE;MAC1Bd,IAAI,CAAChB,YAAY,CAACvD,OAAO,CAACJ,QAAQ,IAAI;QACpC,MAAM+E,OAAO,GAAG9C,KAAK,CAACI,GAAG,CAACrC,QAAQ,CAAC;QACnC,IAAI+E,OAAO,EAAE;UACXU,qBAAqB,CAAC5E,IAAI,CAAC,GAAG,CAAC,GAAGkE,OAAO,CAAC,CAAChF,GAAG,CAAC2F,CAAC,IAAIA,CAAC,CAACrF,MAAM,CAAC,CAAC;QAChE;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACLoF,qBAAqB,GAAGpI,aAAa;IACvC;IACA6H,eAAe,CAACO,qBAAqB,CAAC;EACxC,CAAC;EACDnH,WAAW,GAAG6D,QAAQ,IAAI;IACxB,IAAI,CAACX,eAAe,CAAC,CAAC;IACtB,MAAMmE,SAAS,GAAG,IAAI,CAACvI,KAAK;IAC5B,IAAI,CAAC+E,QAAQ,EAAE;MACb,IAAI,CAAClC,WAAW,CAAC9D,KAAK,CAAC,IAAI,CAACmB,aAAa,CAAC,CAAC;MAC3C,IAAI,CAACoH,0BAA0B,CAAC,CAAC;MACjC,IAAI,CAACkB,eAAe,CAACD,SAAS,EAAE,IAAI,EAAE;QACpCE,IAAI,EAAE;MACR,CAAC,CAAC;MACF,IAAI,CAAC7E,WAAW,CAAC,CAAC;MAClB;IACF;;IAEA;IACA,MAAM2C,YAAY,GAAGxB,QAAQ,CAACpC,GAAG,CAACnD,WAAW,CAAC;IAC9C+G,YAAY,CAACvD,OAAO,CAACJ,QAAQ,IAAI;MAC/B,MAAM4E,YAAY,GAAG,IAAI,CAACnF,eAAe,CAACO,QAAQ,CAAC;MACnD,IAAI,CAACC,WAAW,CAAClD,QAAQ,CAAC,IAAI,CAACK,KAAK,EAAE4C,QAAQ,EAAE4E,YAAY,CAAC,CAAC;IAChE,CAAC,CAAC;IACF,IAAI,CAACF,0BAA0B,CAAC;MAC9Bf;IACF,CAAC,CAAC;IACF,IAAI,CAACiC,eAAe,CAACD,SAAS,EAAEhC,YAAY,EAAE;MAC5CkC,IAAI,EAAE;IACR,CAAC,CAAC;IACF,IAAI,CAAC7E,WAAW,CAAC2C,YAAY,CAAC;EAChC,CAAC;EACDpF,SAAS,GAAGuH,MAAM,IAAI;IACpB,IAAI,CAACtE,eAAe,CAAC,CAAC;IACtB,MAAMmE,SAAS,GAAG,IAAI,CAACvI,KAAK;IAC5B,MAAMuG,YAAY,GAAG,EAAE;IACvBmC,MAAM,CAAC1F,OAAO,CAAC2F,SAAS,IAAI;MAC1B,MAAM;QACJ3D,IAAI;QACJ,GAAG4D;MACL,CAAC,GAAGD,SAAS;MACb,MAAM/F,QAAQ,GAAGpD,WAAW,CAACwF,IAAI,CAAC;MAClCuB,YAAY,CAAC9C,IAAI,CAACb,QAAQ,CAAC;;MAE3B;MACA,IAAI,OAAO,IAAIgG,IAAI,EAAE;QACnB,IAAI,CAAC/F,WAAW,CAAClD,QAAQ,CAAC,IAAI,CAACK,KAAK,EAAE4C,QAAQ,EAAEgG,IAAI,CAACxB,KAAK,CAAC,CAAC;MAC9D;MACA,IAAI,CAACoB,eAAe,CAACD,SAAS,EAAE,CAAC3F,QAAQ,CAAC,EAAE;QAC1C6F,IAAI,EAAE,UAAU;QAChBG,IAAI,EAAED;MACR,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,IAAI,CAAC/E,WAAW,CAAC2C,YAAY,CAAC;EAChC,CAAC;EACDpE,SAAS,GAAGA,CAAA,KAAM;IAChB,MAAM+E,QAAQ,GAAG,IAAI,CAACnE,gBAAgB,CAAC,IAAI,CAAC;IAC5C,MAAM2F,MAAM,GAAGxB,QAAQ,CAACvE,GAAG,CAACgC,KAAK,IAAI;MACnC,MAAM/B,QAAQ,GAAG+B,KAAK,CAACnF,WAAW,CAAC,CAAC;MACpC,MAAMmG,IAAI,GAAGhB,KAAK,CAACiB,OAAO,CAAC,CAAC;MAC5B,MAAM+C,SAAS,GAAG;QAChB,GAAGhD,IAAI;QACPX,IAAI,EAAEpC,QAAQ;QACdwE,KAAK,EAAE,IAAI,CAAC3G,aAAa,CAACmC,QAAQ;MACpC,CAAC;MACDiG,MAAM,CAACC,cAAc,CAACH,SAAS,EAAE,eAAe,EAAE;QAChDvB,KAAK,EAAE;MACT,CAAC,CAAC;MACF,OAAOuB,SAAS;IAClB,CAAC,CAAC;IACF,OAAOD,MAAM;EACf,CAAC;;EAED;EACA;AACF;AACA;EACE9G,eAAe,GAAGqB,MAAM,IAAI;IAC1B,MAAM;MACJuE;IACF,CAAC,GAAGvE,MAAM,CAACwE,KAAK;IAChB,IAAID,YAAY,KAAKE,SAAS,EAAE;MAC9B,MAAM9E,QAAQ,GAAGK,MAAM,CAACzD,WAAW,CAAC,CAAC;MACrC,MAAMuJ,SAAS,GAAGtJ,QAAQ,CAAC,IAAI,CAACO,KAAK,EAAE4C,QAAQ,CAAC;MAChD,IAAImG,SAAS,KAAKrB,SAAS,EAAE;QAC3B,IAAI,CAAC7E,WAAW,CAAClD,QAAQ,CAAC,IAAI,CAACK,KAAK,EAAE4C,QAAQ,EAAE4E,YAAY,CAAC,CAAC;MAChE;IACF;EACF,CAAC;EACDtE,gBAAgB,GAAG8F,aAAa,IAAI;IAClC,MAAMC,cAAc,GAAGD,aAAa,KAAKtB,SAAS,GAAGsB,aAAa,GAAG,IAAI,CAAC3I,QAAQ;IAClF,OAAO4I,cAAc,IAAI,IAAI;EAC/B,CAAC;EACDpH,aAAa,GAAGoB,MAAM,IAAI;IACxB,IAAI,CAAChD,aAAa,CAACwD,IAAI,CAACR,MAAM,CAAC;IAC/B,MAAML,QAAQ,GAAGK,MAAM,CAACzD,WAAW,CAAC,CAAC;IACrC,IAAI,CAACwE,gBAAgB,CAACpB,QAAQ,CAAC;;IAE/B;IACA,IAAIK,MAAM,CAACwE,KAAK,CAACD,YAAY,KAAKE,SAAS,EAAE;MAC3C,MAAMa,SAAS,GAAG,IAAI,CAACvI,KAAK;MAC5B,IAAI,CAACsH,0BAA0B,CAAC;QAC9BJ,QAAQ,EAAE,CAACjE,MAAM,CAAC;QAClBmF,SAAS,EAAE;MACb,CAAC,CAAC;MACF,IAAI,CAACI,eAAe,CAACD,SAAS,EAAE,CAACtF,MAAM,CAACzD,WAAW,CAAC,CAAC,CAAC,EAAE;QACtDiJ,IAAI,EAAE,aAAa;QACnBS,MAAM,EAAE;MACV,CAAC,CAAC;IACJ;;IAEA;IACA,OAAO,CAACf,WAAW,EAAE9H,QAAQ,EAAE8I,WAAW,GAAG,EAAE,KAAK;MAClD,IAAI,CAAClJ,aAAa,GAAG,IAAI,CAACA,aAAa,CAACyD,MAAM,CAAC0F,IAAI,IAAIA,IAAI,KAAKnG,MAAM,CAAC;;MAEvE;MACA,IAAI,CAAC,IAAI,CAACC,gBAAgB,CAAC7C,QAAQ,CAAC,KAAK,CAAC8H,WAAW,IAAIgB,WAAW,CAAC7F,MAAM,GAAG,CAAC,CAAC,EAAE;QAChF,MAAM+F,YAAY,GAAGlB,WAAW,GAAGT,SAAS,GAAG,IAAI,CAACrF,eAAe,CAACO,QAAQ,CAAC;QAC7E,IAAIA,QAAQ,CAACU,MAAM,IAAI,IAAI,CAAC7C,aAAa,CAACmC,QAAQ,CAAC,KAAKyG,YAAY,IAAI,IAAI,CAACpJ,aAAa,CAACwG,KAAK,CAAC9B,KAAK;QACtG;QACA,CAACjF,aAAa,CAACiF,KAAK,CAACnF,WAAW,CAAC,CAAC,EAAEoD,QAAQ,CAAC,CAAC,EAAE;UAC9C,MAAM2F,SAAS,GAAG,IAAI,CAACvI,KAAK;UAC5B,IAAI,CAAC6C,WAAW,CAAClD,QAAQ,CAAC4I,SAAS,EAAE3F,QAAQ,EAAEyG,YAAY,EAAE,IAAI,CAAC,CAAC;;UAEnE;UACA,IAAI,CAACb,eAAe,CAACD,SAAS,EAAE,CAAC3F,QAAQ,CAAC,EAAE;YAC1C6F,IAAI,EAAE;UACR,CAAC,CAAC;;UAEF;UACA,IAAI,CAACa,yBAAyB,CAACf,SAAS,EAAE3F,QAAQ,CAAC;QACrD;MACF;MACA,IAAI,CAACoB,gBAAgB,CAACpB,QAAQ,CAAC;IACjC,CAAC;EACH,CAAC;EACDjB,QAAQ,GAAG4H,MAAM,IAAI;IACnB,QAAQA,MAAM,CAACd,IAAI;MACjB,KAAK,aAAa;QAChB;UACE,MAAM;YACJ7F,QAAQ;YACRwE;UACF,CAAC,GAAGmC,MAAM;UACV,IAAI,CAACC,WAAW,CAAC5G,QAAQ,EAAEwE,KAAK,CAAC;UACjC;QACF;MACF,KAAK,eAAe;QAClB;UACE,MAAM;YACJxE,QAAQ;YACR6G;UACF,CAAC,GAAGF,MAAM;UACV,IAAI,CAACjI,cAAc,CAAC,CAACsB,QAAQ,CAAC,EAAE;YAC9B6G;UACF,CAAC,CAAC;UACF;QACF;MACF;MACA;IACF;EACF,CAAC;EACDjB,eAAe,GAAGA,CAACD,SAAS,EAAEhC,YAAY,EAAEgB,IAAI,KAAK;IACnD,IAAI,IAAI,CAACxH,YAAY,EAAE;MACrB,MAAM2J,UAAU,GAAG;QACjB,GAAGnC,IAAI;QACPvH,KAAK,EAAE,IAAI,CAACU,cAAc,CAAC,IAAI;MACjC,CAAC;MACD,IAAI,CAACqC,gBAAgB,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;QAC/B2G;MACF,CAAC,KAAK;QACJA,aAAa,CAACpB,SAAS,EAAEhC,YAAY,EAAEmD,UAAU,CAAC;MACpD,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,IAAI,CAAC5J,eAAe,CAAC,CAAC;IACxB;EACF,CAAC;;EAED;AACF;AACA;AACA;EACEwJ,yBAAyB,GAAGA,CAACf,SAAS,EAAE3F,QAAQ,KAAK;IACnD,MAAMgH,cAAc,GAAG,IAAI,CAACC,2BAA2B,CAACjH,QAAQ,CAAC;IACjE,IAAIgH,cAAc,CAACtG,MAAM,EAAE;MACzB,IAAI,CAAChC,cAAc,CAACsI,cAAc,CAAC;IACrC;IACA,IAAI,CAACpB,eAAe,CAACD,SAAS,EAAEqB,cAAc,EAAE;MAC9CnB,IAAI,EAAE,oBAAoB;MAC1BqB,aAAa,EAAE,CAAClH,QAAQ,EAAE,GAAGgH,cAAc;IAC7C,CAAC,CAAC;IACF,OAAOA,cAAc;EACvB,CAAC;EACDJ,WAAW,GAAGA,CAACxE,IAAI,EAAEoC,KAAK,KAAK;IAC7B,MAAMxE,QAAQ,GAAGpD,WAAW,CAACwF,IAAI,CAAC;IAClC,MAAMuD,SAAS,GAAG,IAAI,CAACvI,KAAK;IAC5B,IAAI,CAAC6C,WAAW,CAAClD,QAAQ,CAAC,IAAI,CAACK,KAAK,EAAE4C,QAAQ,EAAEwE,KAAK,CAAC,CAAC;IACvD,IAAI,CAACoB,eAAe,CAACD,SAAS,EAAE,CAAC3F,QAAQ,CAAC,EAAE;MAC1C6F,IAAI,EAAE,aAAa;MACnBS,MAAM,EAAE;IACV,CAAC,CAAC;IACF,IAAI,CAACtF,WAAW,CAAC,CAAChB,QAAQ,CAAC,CAAC;;IAE5B;IACA,MAAMgH,cAAc,GAAG,IAAI,CAACN,yBAAyB,CAACf,SAAS,EAAE3F,QAAQ,CAAC;;IAE1E;IACA,MAAM;MACJmH;IACF,CAAC,GAAG,IAAI,CAAC5J,SAAS;IAClB,IAAI4J,cAAc,EAAE;MAClB,MAAMC,aAAa,GAAG1K,mBAAmB,CAAC,IAAI,CAACU,KAAK,EAAE,CAAC4C,QAAQ,CAAC,CAAC;MACjE,MAAMkB,SAAS,GAAG,IAAI,CAACpD,cAAc,CAAC,CAAC;MACvC;MACA,MAAMuJ,eAAe,GAAGlL,KAAK,CAAC+E,SAAS,EAAEkG,aAAa,CAAC;MACvDD,cAAc,CAACC,aAAa,EAAEC,eAAe,CAAC;IAChD;IACA,IAAI,CAACC,qBAAqB,CAAC,CAACtH,QAAQ,EAAE,GAAGgH,cAAc,CAAC,CAAC;EAC3D,CAAC;;EAED;EACAvI,cAAc,GAAGrB,KAAK,IAAI;IACxB,IAAI,CAACoE,eAAe,CAAC,CAAC;IACtB,MAAMmE,SAAS,GAAG,IAAI,CAACvI,KAAK;IAC5B,IAAIA,KAAK,EAAE;MACT,MAAM0C,SAAS,GAAG3D,KAAK,CAAC,IAAI,CAACiB,KAAK,EAAEA,KAAK,CAAC;MAC1C,IAAI,CAAC6C,WAAW,CAACH,SAAS,CAAC;IAC7B;IACA,IAAI,CAAC8F,eAAe,CAACD,SAAS,EAAE,IAAI,EAAE;MACpCE,IAAI,EAAE,aAAa;MACnBS,MAAM,EAAE;IACV,CAAC,CAAC;IACF,IAAI,CAACtF,WAAW,CAAC,CAAC;EACpB,CAAC;EACDxC,aAAa,GAAGA,CAAC4D,IAAI,EAAEoC,KAAK,KAAK;IAC/B,IAAI,CAACjG,SAAS,CAAC,CAAC;MACd6D,IAAI;MACJoC,KAAK;MACLrB,MAAM,EAAE,EAAE;MACVE,QAAQ,EAAE,EAAE;MACZkE,OAAO,EAAE;IACX,CAAC,CAAC,CAAC;EACL,CAAC;EACDN,2BAA2B,GAAGO,YAAY,IAAI;IAC5C,MAAMC,QAAQ,GAAG,IAAIzC,GAAG,CAAC,CAAC;IAC1B,MAAMgC,cAAc,GAAG,EAAE;IACzB,MAAMU,mBAAmB,GAAG,IAAIjL,OAAO,CAAC,CAAC;;IAEzC;AACJ;AACA;AACA;IACI,IAAI,CAAC0D,gBAAgB,CAAC,CAAC,CAACC,OAAO,CAAC2B,KAAK,IAAI;MACvC,MAAM;QACJ4F;MACF,CAAC,GAAG5F,KAAK,CAAC8C,KAAK;MACf,CAAC8C,YAAY,IAAI,EAAE,EAAEvH,OAAO,CAACwH,UAAU,IAAI;QACzC,MAAMC,kBAAkB,GAAGjL,WAAW,CAACgL,UAAU,CAAC;QAClDF,mBAAmB,CAACvD,MAAM,CAAC0D,kBAAkB,EAAE,CAAC/B,MAAM,GAAG,IAAId,GAAG,CAAC,CAAC,KAAK;UACrEc,MAAM,CAACb,GAAG,CAAClD,KAAK,CAAC;UACjB,OAAO+D,MAAM;QACf,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,MAAMgC,YAAY,GAAG9H,QAAQ,IAAI;MAC/B,MAAM8F,MAAM,GAAG4B,mBAAmB,CAACrF,GAAG,CAACrC,QAAQ,CAAC,IAAI,IAAIgF,GAAG,CAAC,CAAC;MAC7Dc,MAAM,CAAC1F,OAAO,CAAC2B,KAAK,IAAI;QACtB,IAAI,CAAC0F,QAAQ,CAACM,GAAG,CAAChG,KAAK,CAAC,EAAE;UACxB0F,QAAQ,CAACxC,GAAG,CAAClD,KAAK,CAAC;UACnB,MAAMiC,aAAa,GAAGjC,KAAK,CAACnF,WAAW,CAAC,CAAC;UACzC,IAAImF,KAAK,CAACiG,YAAY,CAAC,CAAC,IAAIhE,aAAa,CAACtD,MAAM,EAAE;YAChDsG,cAAc,CAACnG,IAAI,CAACmD,aAAa,CAAC;YAClC8D,YAAY,CAAC9D,aAAa,CAAC;UAC7B;QACF;MACF,CAAC,CAAC;IACJ,CAAC;IACD8D,YAAY,CAACN,YAAY,CAAC;IAC1B,OAAOR,cAAc;EACvB,CAAC;EACDM,qBAAqB,GAAGA,CAAC3D,YAAY,EAAEsE,WAAW,KAAK;IACrD,MAAM;MACJC;IACF,CAAC,GAAG,IAAI,CAAC3K,SAAS;IAClB,IAAI2K,cAAc,EAAE;MAClB,MAAMpC,MAAM,GAAG,IAAI,CAACvG,SAAS,CAAC,CAAC;;MAE/B;AACN;AACA;MACM,IAAI0I,WAAW,EAAE;QACf,MAAMhG,KAAK,GAAG,IAAIxF,OAAO,CAAC,CAAC;QAC3BwL,WAAW,CAAC7H,OAAO,CAAC,CAAC;UACnBgC,IAAI;UACJe;QACF,CAAC,KAAK;UACJlB,KAAK,CAACzB,GAAG,CAAC4B,IAAI,EAAEe,MAAM,CAAC;QACzB,CAAC,CAAC;QACF2C,MAAM,CAAC1F,OAAO,CAAC2B,KAAK,IAAI;UACtB;UACAA,KAAK,CAACoB,MAAM,GAAGlB,KAAK,CAACI,GAAG,CAACN,KAAK,CAACK,IAAI,CAAC,IAAIL,KAAK,CAACoB,MAAM;QACtD,CAAC,CAAC;MACJ;MACA,MAAMgF,aAAa,GAAGrC,MAAM,CAAChF,MAAM,CAAC,CAAC;QACnCsB,IAAI,EAAEgG;MACR,CAAC,KAAKzL,gBAAgB,CAACgH,YAAY,EAAEyE,SAAS,CAAC,CAAC;MAChD,IAAID,aAAa,CAACzH,MAAM,EAAE;QACxBwH,cAAc,CAACC,aAAa,EAAErC,MAAM,CAAC;MACvC;IACF;EACF,CAAC;;EAED;EACApH,cAAc,GAAGA,CAACgF,IAAI,EAAE2E,IAAI,KAAK;IAC/B,IAAI,CAAC7G,eAAe,CAAC,CAAC;IACtB,IAAIW,QAAQ;IACZ,IAAImG,OAAO;IACX,IAAI5F,KAAK,CAACC,OAAO,CAACe,IAAI,CAAC,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,OAAO2E,IAAI,KAAK,QAAQ,EAAE;MAC/ElG,QAAQ,GAAGuB,IAAI;MACf4E,OAAO,GAAGD,IAAI;IAChB,CAAC,MAAM;MACLC,OAAO,GAAG5E,IAAI;IAChB;IACA,MAAM6E,eAAe,GAAG,CAAC,CAACpG,QAAQ;IAClC,MAAMwB,YAAY,GAAG4E,eAAe,GAAGpG,QAAQ,CAACpC,GAAG,CAACnD,WAAW,CAAC,GAAG,EAAE;IACrE;IACA,MAAM4L,sBAAsB,GAAG,CAAC,GAAG7E,YAAY,CAAC;;IAEhD;IACA,MAAM8E,WAAW,GAAG,EAAE;;IAEtB;IACA,MAAMC,SAAS,GAAGC,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC;IACpC,MAAMC,oBAAoB,GAAG,IAAI9D,GAAG,CAAC,CAAC;IACtC,MAAM;MACJ+D,SAAS;MACTC;IACF,CAAC,GAAGV,OAAO,IAAI,CAAC,CAAC;IACjB,IAAI,CAACnI,gBAAgB,CAAC,IAAI,CAAC,CAACC,OAAO,CAAC2B,KAAK,IAAI;MAC3C,MAAMiC,aAAa,GAAGjC,KAAK,CAACnF,WAAW,CAAC,CAAC;;MAEzC;MACA,IAAI,CAAC2L,eAAe,EAAE;QACpB;QACA;QACA,CAACxG,KAAK,CAACe,MAAM,CAAC,CAAC;QACf;QACA,CAACa,YAAY,CAACG,IAAI,CAAC1B,IAAI,IAAItF,aAAa,CAACsF,IAAI,EAAE4B,aAAa,EAAE,IAAI,CAAC,CAAC,EAAE;UACpEwE,sBAAsB,CAAC3H,IAAI,CAACmD,aAAa,CAAC;QAC5C;QACAL,YAAY,CAAC9C,IAAI,CAACmD,aAAa,CAAC;MAClC;;MAEA;MACA,IAAI,CAACjC,KAAK,CAAC8C,KAAK,CAACoE,KAAK,IAAI,CAAClH,KAAK,CAAC8C,KAAK,CAACoE,KAAK,CAACvI,MAAM,EAAE;QACnD;MACF;;MAEA;MACA,IAAIsI,KAAK,IAAI,CAACjH,KAAK,CAACiG,YAAY,CAAC,CAAC,EAAE;QAClC;MACF;MACAc,oBAAoB,CAAC7D,GAAG,CAACjB,aAAa,CAACoB,IAAI,CAACsD,SAAS,CAAC,CAAC;;MAEvD;MACA,IAAI,CAACH,eAAe,IAAI5L,gBAAgB,CAACgH,YAAY,EAAEK,aAAa,EAAE+E,SAAS,CAAC,EAAE;QAChF,MAAMG,OAAO,GAAGnH,KAAK,CAACoH,aAAa,CAAC;UAClC3L,gBAAgB,EAAE;YAChB,GAAGhB,uBAAuB;YAC1B,GAAG,IAAI,CAACgB;UACV,CAAC;UACD,GAAG8K;QACL,CAAC,CAAC;;QAEF;QACAG,WAAW,CAAC5H,IAAI,CAACqI,OAAO,CAACE,IAAI,CAAC,OAAO;UACnChH,IAAI,EAAE4B,aAAa;UACnBb,MAAM,EAAE,EAAE;UACVE,QAAQ,EAAE;QACZ,CAAC,CAAC,CAAC,CAACgG,KAAK,CAACC,UAAU,IAAI;UACtB,MAAMC,YAAY,GAAG,EAAE;UACvB,MAAMC,cAAc,GAAG,EAAE;UACzBF,UAAU,CAAClJ,OAAO,GAAG,CAAC;YACpBqJ,IAAI,EAAE;cACJC;YACF,CAAC;YACDvG;UACF,CAAC,KAAK;YACJ,IAAIuG,WAAW,EAAE;cACfF,cAAc,CAAC3I,IAAI,CAAC,GAAGsC,MAAM,CAAC;YAChC,CAAC,MAAM;cACLoG,YAAY,CAAC1I,IAAI,CAAC,GAAGsC,MAAM,CAAC;YAC9B;UACF,CAAC,CAAC;UACF,IAAIoG,YAAY,CAAC7I,MAAM,EAAE;YACvB,OAAOiJ,OAAO,CAACC,MAAM,CAAC;cACpBxH,IAAI,EAAE4B,aAAa;cACnBb,MAAM,EAAEoG,YAAY;cACpBlG,QAAQ,EAAEmG;YACZ,CAAC,CAAC;UACJ;UACA,OAAO;YACLpH,IAAI,EAAE4B,aAAa;YACnBb,MAAM,EAAEoG,YAAY;YACpBlG,QAAQ,EAAEmG;UACZ,CAAC;QACH,CAAC,CAAC,CAAC;MACL;IACF,CAAC,CAAC;IACF,MAAMK,cAAc,GAAGtN,gBAAgB,CAACkM,WAAW,CAAC;IACpD,IAAI,CAAC/K,mBAAmB,GAAGmM,cAAc;;IAEzC;IACAA,cAAc,CAACR,KAAK,CAACS,OAAO,IAAIA,OAAO,CAAC,CAACV,IAAI,CAACU,OAAO,IAAI;MACvD,MAAMC,kBAAkB,GAAGD,OAAO,CAAC/J,GAAG,CAAC,CAAC;QACtCqC;MACF,CAAC,KAAKA,IAAI,CAAC;MACX,IAAI,CAACwD,eAAe,CAAC,IAAI,CAACxI,KAAK,EAAE2M,kBAAkB,EAAE;QACnDlE,IAAI,EAAE;MACR,CAAC,CAAC;MACF,IAAI,CAACyB,qBAAqB,CAACyC,kBAAkB,EAAED,OAAO,CAAC;IACzD,CAAC,CAAC;IACF,MAAME,aAAa,GAAGH,cAAc,CAACT,IAAI,CAAC,MAAM;MAC9C,IAAI,IAAI,CAAC1L,mBAAmB,KAAKmM,cAAc,EAAE;QAC/C,OAAOF,OAAO,CAACM,OAAO,CAAC,IAAI,CAACnM,cAAc,CAAC0K,sBAAsB,CAAC,CAAC;MACrE;MACA,OAAOmB,OAAO,CAACC,MAAM,CAAC,EAAE,CAAC;IAC3B,CAAC,CAAC,CAACP,KAAK,CAACS,OAAO,IAAI;MAClB,MAAMI,SAAS,GAAGJ,OAAO,CAAChJ,MAAM,CAACqJ,MAAM,IAAIA,MAAM,IAAIA,MAAM,CAAChH,MAAM,CAACzC,MAAM,CAAC;MAC1E,MAAM0J,YAAY,GAAGF,SAAS,CAAC,CAAC,CAAC,EAAE/G,MAAM,GAAG,CAAC,CAAC;MAC9C,OAAOwG,OAAO,CAACC,MAAM,CAAC;QACpBS,OAAO,EAAED,YAAY;QACrBnJ,MAAM,EAAE,IAAI,CAACnD,cAAc,CAAC6F,YAAY,CAAC;QACzC2G,WAAW,EAAEJ,SAAS;QACtBK,SAAS,EAAE,IAAI,CAAC7M,mBAAmB,KAAKmM;MAC1C,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACAG,aAAa,CAACX,KAAK,CAACmB,CAAC,IAAIA,CAAC,CAAC;;IAE3B;IACA,MAAMC,mBAAmB,GAAG9G,YAAY,CAAC7C,MAAM,CAACd,QAAQ,IAAI8I,oBAAoB,CAACf,GAAG,CAAC/H,QAAQ,CAACoF,IAAI,CAACsD,SAAS,CAAC,CAAC,CAAC;IAC/G,IAAI,CAACpB,qBAAqB,CAACmD,mBAAmB,CAAC;IAC/C,OAAOT,aAAa;EACtB,CAAC;;EAED;EACArL,MAAM,GAAGA,CAAA,KAAM;IACb,IAAI,CAAC6C,eAAe,CAAC,CAAC;IACtB,IAAI,CAAC9C,cAAc,CAAC,CAAC,CAAC0K,IAAI,CAACnI,MAAM,IAAI;MACnC,MAAM;QACJyJ;MACF,CAAC,GAAG,IAAI,CAACnN,SAAS;MAClB,IAAImN,QAAQ,EAAE;QACZ,IAAI;UACFA,QAAQ,CAACzJ,MAAM,CAAC;QAClB,CAAC,CAAC,OAAO0J,GAAG,EAAE;UACZ;UACAC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;QACpB;MACF;IACF,CAAC,CAAC,CAACtB,KAAK,CAACmB,CAAC,IAAI;MACZ,MAAM;QACJM;MACF,CAAC,GAAG,IAAI,CAACvN,SAAS;MAClB,IAAIuN,cAAc,EAAE;QAClBA,cAAc,CAACN,CAAC,CAAC;MACnB;IACF,CAAC,CAAC;EACJ,CAAC;AACH;AACA,SAASO,OAAOA,CAACC,IAAI,EAAE;EACrB,MAAMC,OAAO,GAAG5O,KAAK,CAAC6O,MAAM,CAAC,IAAI,CAAC;EAClC,MAAM,GAAGC,WAAW,CAAC,GAAG9O,KAAK,CAAC+O,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC1C,IAAI,CAACH,OAAO,CAACI,OAAO,EAAE;IACpB,IAAIL,IAAI,EAAE;MACRC,OAAO,CAACI,OAAO,GAAGL,IAAI;IACxB,CAAC,MAAM;MACL;MACA,MAAMM,aAAa,GAAGA,CAAA,KAAM;QAC1BH,WAAW,CAAC,CAAC,CAAC,CAAC;MACjB,CAAC;MACD,MAAMI,SAAS,GAAG,IAAIvO,SAAS,CAACsO,aAAa,CAAC;MAC9CL,OAAO,CAACI,OAAO,GAAGE,SAAS,CAAC3N,OAAO,CAAC,CAAC;IACvC;EACF;EACA,OAAO,CAACqN,OAAO,CAACI,OAAO,CAAC;AAC1B;AACA,eAAeN,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}