{"ast":null,"code":"import { useEvent } from '@rc-component/util';\nimport useState from \"@rc-component/util/es/hooks/useState\";\nimport useSyncState from \"@rc-component/util/es/hooks/useSyncState\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { STATUS_APPEAR, STATUS_ENTER, STATUS_LEAVE, STATUS_NONE, STEP_ACTIVE, STEP_PREPARE, STEP_PREPARED, STEP_START } from \"../interface\";\nimport useDomMotionEvents from \"./useDomMotionEvents\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStepQueue, { DoStep, isActive, SkipStep } from \"./useStepQueue\";\nexport default function useStatus(supportMotion, visible, getElement, {\n  motionEnter = true,\n  motionAppear = true,\n  motionLeave = true,\n  motionDeadline,\n  motionLeaveImmediately,\n  onAppearPrepare,\n  onEnterPrepare,\n  onLeavePrepare,\n  onAppearStart,\n  onEnterStart,\n  onLeaveStart,\n  onAppearActive,\n  onEnterActive,\n  onLeaveActive,\n  onAppearEnd,\n  onEnterEnd,\n  onLeaveEnd,\n  onVisibleChanged\n}) {\n  // Used for outer render usage to avoid `visible: false & status: none` to render nothing\n  const [asyncVisible, setAsyncVisible] = useState();\n  const [getStatus, setStatus] = useSyncState(STATUS_NONE);\n  const [style, setStyle] = useState(null);\n  const currentStatus = getStatus();\n  const mountedRef = useRef(false);\n  const deadlineRef = useRef(null);\n\n  // =========================== Dom Node ===========================\n  function getDomElement() {\n    return getElement();\n  }\n\n  // ========================== Motion End ==========================\n  const activeRef = useRef(false);\n\n  /**\n   * Clean up status & style\n   */\n  function updateMotionEndStatus() {\n    setStatus(STATUS_NONE);\n    setStyle(null, true);\n  }\n  const onInternalMotionEnd = useEvent(event => {\n    const status = getStatus();\n    // Do nothing since not in any transition status.\n    // This may happen when `motionDeadline` trigger.\n    if (status === STATUS_NONE) {\n      return;\n    }\n    const element = getDomElement();\n    if (event && !event.deadline && event.target !== element) {\n      // event exists\n      // not initiated by deadline\n      // transitionEnd not fired by inner elements\n      return;\n    }\n    const currentActive = activeRef.current;\n    let canEnd;\n    if (status === STATUS_APPEAR && currentActive) {\n      canEnd = onAppearEnd?.(element, event);\n    } else if (status === STATUS_ENTER && currentActive) {\n      canEnd = onEnterEnd?.(element, event);\n    } else if (status === STATUS_LEAVE && currentActive) {\n      canEnd = onLeaveEnd?.(element, event);\n    }\n\n    // Only update status when `canEnd` and not destroyed\n    if (currentActive && canEnd !== false) {\n      updateMotionEndStatus();\n    }\n  });\n  const [patchMotionEvents] = useDomMotionEvents(onInternalMotionEnd);\n\n  // ============================= Step =============================\n  const getEventHandlers = targetStatus => {\n    switch (targetStatus) {\n      case STATUS_APPEAR:\n        return {\n          [STEP_PREPARE]: onAppearPrepare,\n          [STEP_START]: onAppearStart,\n          [STEP_ACTIVE]: onAppearActive\n        };\n      case STATUS_ENTER:\n        return {\n          [STEP_PREPARE]: onEnterPrepare,\n          [STEP_START]: onEnterStart,\n          [STEP_ACTIVE]: onEnterActive\n        };\n      case STATUS_LEAVE:\n        return {\n          [STEP_PREPARE]: onLeavePrepare,\n          [STEP_START]: onLeaveStart,\n          [STEP_ACTIVE]: onLeaveActive\n        };\n      default:\n        return {};\n    }\n  };\n  const eventHandlers = React.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);\n  const [startStep, step] = useStepQueue(currentStatus, !supportMotion, newStep => {\n    // Only prepare step can be skip\n    if (newStep === STEP_PREPARE) {\n      const onPrepare = eventHandlers[STEP_PREPARE];\n      if (!onPrepare) {\n        return SkipStep;\n      }\n      return onPrepare(getDomElement());\n    }\n\n    // Rest step is sync update\n    if (step in eventHandlers) {\n      setStyle(eventHandlers[step]?.(getDomElement(), null) || null);\n    }\n    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {\n      // Patch events when motion needed\n      patchMotionEvents(getDomElement());\n      if (motionDeadline > 0) {\n        clearTimeout(deadlineRef.current);\n        deadlineRef.current = setTimeout(() => {\n          onInternalMotionEnd({\n            deadline: true\n          });\n        }, motionDeadline);\n      }\n    }\n    if (step === STEP_PREPARED) {\n      updateMotionEndStatus();\n    }\n    return DoStep;\n  });\n  const active = isActive(step);\n  activeRef.current = active;\n\n  // ============================ Status ============================\n  const visibleRef = useRef(null);\n\n  // Update with new status\n  useIsomorphicLayoutEffect(() => {\n    // When use Suspense, the `visible` will repeat trigger,\n    // But not real change of the `visible`, we need to skip it.\n    // https://github.com/ant-design/ant-design/issues/44379\n    if (mountedRef.current && visibleRef.current === visible) {\n      return;\n    }\n    setAsyncVisible(visible);\n    const isMounted = mountedRef.current;\n    mountedRef.current = true;\n\n    // if (!supportMotion) {\n    //   return;\n    // }\n\n    let nextStatus;\n\n    // Appear\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    }\n\n    // Enter\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    }\n\n    // Leave\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n    const nextEventHandlers = getEventHandlers(nextStatus);\n\n    // Update to next status\n    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {\n      setStatus(nextStatus);\n      startStep();\n    } else {\n      // Set back in case no motion but prev status has prepare step\n      setStatus(STATUS_NONE);\n    }\n    visibleRef.current = visible;\n  }, [visible]);\n\n  // ============================ Effect ============================\n  // Reset when motion changed\n  useEffect(() => {\n    if (\n    // Cancel appear\n    currentStatus === STATUS_APPEAR && !motionAppear ||\n    // Cancel enter\n    currentStatus === STATUS_ENTER && !motionEnter ||\n    // Cancel leave\n    currentStatus === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  useEffect(() => () => {\n    mountedRef.current = false;\n    clearTimeout(deadlineRef.current);\n  }, []);\n\n  // Trigger `onVisibleChanged`\n  const firstMountChangeRef = React.useRef(false);\n  useEffect(() => {\n    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged\n    if (asyncVisible) {\n      firstMountChangeRef.current = true;\n    }\n    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {\n      // Skip first render is invisible since it's nothing changed\n      if (firstMountChangeRef.current || asyncVisible) {\n        onVisibleChanged?.(asyncVisible);\n      }\n      firstMountChangeRef.current = true;\n    }\n  }, [asyncVisible, currentStatus]);\n\n  // ============================ Styles ============================\n  let mergedStyle = style;\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = {\n      transition: 'none',\n      ...mergedStyle\n    };\n  }\n  return [getStatus, step, mergedStyle, asyncVisible ?? visible];\n}","map":{"version":3,"names":["useEvent","useState","useSyncState","React","useEffect","useRef","STATUS_APPEAR","STATUS_ENTER","STATUS_LEAVE","STATUS_NONE","STEP_ACTIVE","STEP_PREPARE","STEP_PREPARED","STEP_START","useDomMotionEvents","useIsomorphicLayoutEffect","useStepQueue","DoStep","isActive","SkipStep","useStatus","supportMotion","visible","getElement","motionEnter","motionAppear","motionLeave","motionDeadline","motionLeaveImmediately","onAppearPrepare","onEnterPrepare","onLeavePrepare","onAppearStart","onEnterStart","onLeaveStart","onAppearActive","onEnterActive","onLeaveActive","onAppearEnd","onEnterEnd","onLeaveEnd","onVisibleChanged","asyncVisible","setAsyncVisible","getStatus","setStatus","style","setStyle","currentStatus","mountedRef","deadlineRef","getDomElement","activeRef","updateMotionEndStatus","onInternalMotionEnd","event","status","element","deadline","target","currentActive","current","canEnd","patchMotionEvents","getEventHandlers","targetStatus","eventHandlers","useMemo","startStep","step","newStep","onPrepare","clearTimeout","setTimeout","active","visibleRef","isMounted","nextStatus","nextEventHandlers","firstMountChangeRef","undefined","mergedStyle","transition"],"sources":["/Users/mnsh/Desktop/cyber-lynx/Cyber-LynX-php/frontend/node_modules/@rc-component/motion/es/hooks/useStatus.js"],"sourcesContent":["import { useEvent } from '@rc-component/util';\nimport useState from \"@rc-component/util/es/hooks/useState\";\nimport useSyncState from \"@rc-component/util/es/hooks/useSyncState\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { STATUS_APPEAR, STATUS_ENTER, STATUS_LEAVE, STATUS_NONE, STEP_ACTIVE, STEP_PREPARE, STEP_PREPARED, STEP_START } from \"../interface\";\nimport useDomMotionEvents from \"./useDomMotionEvents\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStepQueue, { DoStep, isActive, SkipStep } from \"./useStepQueue\";\nexport default function useStatus(supportMotion, visible, getElement, {\n  motionEnter = true,\n  motionAppear = true,\n  motionLeave = true,\n  motionDeadline,\n  motionLeaveImmediately,\n  onAppearPrepare,\n  onEnterPrepare,\n  onLeavePrepare,\n  onAppearStart,\n  onEnterStart,\n  onLeaveStart,\n  onAppearActive,\n  onEnterActive,\n  onLeaveActive,\n  onAppearEnd,\n  onEnterEnd,\n  onLeaveEnd,\n  onVisibleChanged\n}) {\n  // Used for outer render usage to avoid `visible: false & status: none` to render nothing\n  const [asyncVisible, setAsyncVisible] = useState();\n  const [getStatus, setStatus] = useSyncState(STATUS_NONE);\n  const [style, setStyle] = useState(null);\n  const currentStatus = getStatus();\n  const mountedRef = useRef(false);\n  const deadlineRef = useRef(null);\n\n  // =========================== Dom Node ===========================\n  function getDomElement() {\n    return getElement();\n  }\n\n  // ========================== Motion End ==========================\n  const activeRef = useRef(false);\n\n  /**\n   * Clean up status & style\n   */\n  function updateMotionEndStatus() {\n    setStatus(STATUS_NONE);\n    setStyle(null, true);\n  }\n  const onInternalMotionEnd = useEvent(event => {\n    const status = getStatus();\n    // Do nothing since not in any transition status.\n    // This may happen when `motionDeadline` trigger.\n    if (status === STATUS_NONE) {\n      return;\n    }\n    const element = getDomElement();\n    if (event && !event.deadline && event.target !== element) {\n      // event exists\n      // not initiated by deadline\n      // transitionEnd not fired by inner elements\n      return;\n    }\n    const currentActive = activeRef.current;\n    let canEnd;\n    if (status === STATUS_APPEAR && currentActive) {\n      canEnd = onAppearEnd?.(element, event);\n    } else if (status === STATUS_ENTER && currentActive) {\n      canEnd = onEnterEnd?.(element, event);\n    } else if (status === STATUS_LEAVE && currentActive) {\n      canEnd = onLeaveEnd?.(element, event);\n    }\n\n    // Only update status when `canEnd` and not destroyed\n    if (currentActive && canEnd !== false) {\n      updateMotionEndStatus();\n    }\n  });\n  const [patchMotionEvents] = useDomMotionEvents(onInternalMotionEnd);\n\n  // ============================= Step =============================\n  const getEventHandlers = targetStatus => {\n    switch (targetStatus) {\n      case STATUS_APPEAR:\n        return {\n          [STEP_PREPARE]: onAppearPrepare,\n          [STEP_START]: onAppearStart,\n          [STEP_ACTIVE]: onAppearActive\n        };\n      case STATUS_ENTER:\n        return {\n          [STEP_PREPARE]: onEnterPrepare,\n          [STEP_START]: onEnterStart,\n          [STEP_ACTIVE]: onEnterActive\n        };\n      case STATUS_LEAVE:\n        return {\n          [STEP_PREPARE]: onLeavePrepare,\n          [STEP_START]: onLeaveStart,\n          [STEP_ACTIVE]: onLeaveActive\n        };\n      default:\n        return {};\n    }\n  };\n  const eventHandlers = React.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);\n  const [startStep, step] = useStepQueue(currentStatus, !supportMotion, newStep => {\n    // Only prepare step can be skip\n    if (newStep === STEP_PREPARE) {\n      const onPrepare = eventHandlers[STEP_PREPARE];\n      if (!onPrepare) {\n        return SkipStep;\n      }\n      return onPrepare(getDomElement());\n    }\n\n    // Rest step is sync update\n    if (step in eventHandlers) {\n      setStyle(eventHandlers[step]?.(getDomElement(), null) || null);\n    }\n    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {\n      // Patch events when motion needed\n      patchMotionEvents(getDomElement());\n      if (motionDeadline > 0) {\n        clearTimeout(deadlineRef.current);\n        deadlineRef.current = setTimeout(() => {\n          onInternalMotionEnd({\n            deadline: true\n          });\n        }, motionDeadline);\n      }\n    }\n    if (step === STEP_PREPARED) {\n      updateMotionEndStatus();\n    }\n    return DoStep;\n  });\n  const active = isActive(step);\n  activeRef.current = active;\n\n  // ============================ Status ============================\n  const visibleRef = useRef(null);\n\n  // Update with new status\n  useIsomorphicLayoutEffect(() => {\n    // When use Suspense, the `visible` will repeat trigger,\n    // But not real change of the `visible`, we need to skip it.\n    // https://github.com/ant-design/ant-design/issues/44379\n    if (mountedRef.current && visibleRef.current === visible) {\n      return;\n    }\n    setAsyncVisible(visible);\n    const isMounted = mountedRef.current;\n    mountedRef.current = true;\n\n    // if (!supportMotion) {\n    //   return;\n    // }\n\n    let nextStatus;\n\n    // Appear\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    }\n\n    // Enter\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    }\n\n    // Leave\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n    const nextEventHandlers = getEventHandlers(nextStatus);\n\n    // Update to next status\n    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {\n      setStatus(nextStatus);\n      startStep();\n    } else {\n      // Set back in case no motion but prev status has prepare step\n      setStatus(STATUS_NONE);\n    }\n    visibleRef.current = visible;\n  }, [visible]);\n\n  // ============================ Effect ============================\n  // Reset when motion changed\n  useEffect(() => {\n    if (\n    // Cancel appear\n    currentStatus === STATUS_APPEAR && !motionAppear ||\n    // Cancel enter\n    currentStatus === STATUS_ENTER && !motionEnter ||\n    // Cancel leave\n    currentStatus === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  useEffect(() => () => {\n    mountedRef.current = false;\n    clearTimeout(deadlineRef.current);\n  }, []);\n\n  // Trigger `onVisibleChanged`\n  const firstMountChangeRef = React.useRef(false);\n  useEffect(() => {\n    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged\n    if (asyncVisible) {\n      firstMountChangeRef.current = true;\n    }\n    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {\n      // Skip first render is invisible since it's nothing changed\n      if (firstMountChangeRef.current || asyncVisible) {\n        onVisibleChanged?.(asyncVisible);\n      }\n      firstMountChangeRef.current = true;\n    }\n  }, [asyncVisible, currentStatus]);\n\n  // ============================ Styles ============================\n  let mergedStyle = style;\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = {\n      transition: 'none',\n      ...mergedStyle\n    };\n  }\n  return [getStatus, step, mergedStyle, asyncVisible ?? visible];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}